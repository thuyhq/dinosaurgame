require = function() {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }
        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function(r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }
      return n[i].exports;
    }
    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
    return o;
  }
  return r;
}()({
  Bot: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "eed84TSDIRK+ZOXDcDdx7Kv", "Bot");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        accel: 0,
        fallingPoint: 0,
        max: 0,
        groundPoint: 0,
        moveSpeed: 7,
        botName: {
          default: null,
          type: cc.Node
        }
      },
      onLoad: function onLoad() {
        this.isDead = false;
        this.isFalling = false;
        this.isGrowing = false;
        this.accTop = true;
        this.isBotDead = false;
        this.xSpeed = 0;
        this.ySpeed = 0;
        this.botNameComp = this.botName.getComponent(cc.Label);
        this.anim = this.getComponent(cc.Animation);
        this.runAnimState = this.anim.getAnimationState("dino");
        this.jumpAnimState = this.anim.getAnimationState("dino_jump");
        this.deadAnimState = this.anim.getAnimationState("dino_dead");
        this.duckAnimState = this.anim.getAnimationState("dino_duck");
        this.colliders = this.node.getComponents(cc.PolygonCollider);
        this.standCollider = this.colliders[0];
        this.duckCollider = this.colliders[1];
        var manager = cc.director.getCollisionManager();
        manager.enabled = true;
        manager.enabledDebugDraw = false;
      },
      onCollisionEnter: function onCollisionEnter(other, self) {
        if (0 == other.tag && "Enemy" == other.node.group) {
          this.moveSpeed = other.getComponent("Enemy").runSpeed;
          if (!this.deadAnimState.isPlaying) {
            this.isDead = true;
            this.anim.play("dino_dead");
            this.isBotDead = true;
          }
        }
      },
      start: function start() {},
      update: function update(dt) {
        if (this.game.isGameOver && this.isBotDead) return;
        if (this.isBotDead) {
          this.node.x -= this.moveSpeed;
          this.node.x <= -1500 && this.node.destroy();
          return;
        }
        this.accTop && !this.isFalling && this.isGrowing ? this.ySpeed += this.accel * dt : this.ySpeed -= 50 * this.accel / 100 * dt;
        this.ySpeed >= this.max && (this.ySpeed = this.max);
        this.node.y += this.ySpeed * dt;
        if (this.node.y <= this.groundPoint) {
          this.ySpeed = 0;
          this.node.y = this.groundPoint;
          this.isFalling = false;
          this.isGrowing = true;
          this.runAnimState.isPlaying || this.isDead || this.duckAnimState.isPlaying || this.anim.play("dino");
        }
        if (this.node.y >= this.fallingPoint) {
          this.accTop = false;
          this.isFalling = true;
        }
        if (this.game.isGameOver || !this.game.isGameStarted) {
          this.node.x += this.moveSpeed;
          this.node.x >= 900 && this.node.destroy();
        }
      }
    });
    cc._RF.pop();
  }, {} ],
  ButtonHold: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4af113jvz1GN4gfvJVI6cNP", "ButtonHold");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {},
      start: function start() {
        this.node.on(cc.Node.EventType.TOUCH_START, function(event) {
          cc.log("Click");
        });
        this.node.on(cc.Node.EventType.TOUCH_END, function(event) {
          cc.log("Release");
        });
      }
    });
    cc._RF.pop();
  }, {} ],
  ButtonPlayGame: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "be2fea3tEFNBpoLJkXljUbi", "ButtonPlayGame");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        nameLabel: {
          default: null,
          type: cc.Node
        }
      },
      onClick: function onClick() {
        "" == this.nameComp.string ? cc.sys.localStorage.setItem("guest_name", "Guest") : cc.sys.localStorage.setItem("guest_name", this.nameComp.string);
        cc.director.loadScene("game", function() {
          console.log("Play game");
        });
      },
      onLoad: function onLoad() {
        this.nameComp = this.nameLabel.getComponent(cc.EditBox);
      }
    });
    cc._RF.pop();
  }, {} ],
  CollusionManager: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "de9d9QH2/1FS5WWZZIBjzKc", "CollusionManager");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {},
      onEnable: function onEnable() {},
      onDisable: function onDisable() {
        cc.director.getCollisionManager().enabled = false;
      }
    });
    cc._RF.pop();
  }, {} ],
  1: [ function(require, module, exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len = b64.length;
      if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
      var validLen = b64.indexOf("=");
      -1 === validLen && (validLen = len);
      var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
      return [ validLen, placeHoldersLen ];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
      for (var i = 0; i < len; i += 4) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = 255 & tmp;
      }
      if (2 === placeHoldersLen) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = 255 & tmp;
      }
      if (1 === placeHoldersLen) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = 255 & tmp;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      if (1 === extraBytes) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (2 === extraBytes) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }, {} ],
  2: [ function(require, module, exports) {}, {} ],
  3: [ function(require, module, exports) {
    (function(global) {
      "use strict";
      var base64 = require("base64-js");
      var ieee754 = require("ieee754");
      var isArray = require("isarray");
      exports.Buffer = Buffer;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      Buffer.TYPED_ARRAY_SUPPORT = void 0 !== global.TYPED_ARRAY_SUPPORT ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
      exports.kMaxLength = kMaxLength();
      function typedArraySupport() {
        try {
          var arr = new Uint8Array(1);
          arr.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function() {
              return 42;
            }
          };
          return 42 === arr.foo() && "function" === typeof arr.subarray && 0 === arr.subarray(1, 1).byteLength;
        } catch (e) {
          return false;
        }
      }
      function kMaxLength() {
        return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function createBuffer(that, length) {
        if (kMaxLength() < length) throw new RangeError("Invalid typed array length");
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length);
          that.__proto__ = Buffer.prototype;
        } else {
          null === that && (that = new Buffer(length));
          that.length = length;
        }
        return that;
      }
      function Buffer(arg, encodingOrOffset, length) {
        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) return new Buffer(arg, encodingOrOffset, length);
        if ("number" === typeof arg) {
          if ("string" === typeof encodingOrOffset) throw new Error("If encoding is specified then the first argument must be a string");
          return allocUnsafe(this, arg);
        }
        return from(this, arg, encodingOrOffset, length);
      }
      Buffer.poolSize = 8192;
      Buffer._augment = function(arr) {
        arr.__proto__ = Buffer.prototype;
        return arr;
      };
      function from(that, value, encodingOrOffset, length) {
        if ("number" === typeof value) throw new TypeError('"value" argument must not be a number');
        if ("undefined" !== typeof ArrayBuffer && value instanceof ArrayBuffer) return fromArrayBuffer(that, value, encodingOrOffset, length);
        if ("string" === typeof value) return fromString(that, value, encodingOrOffset);
        return fromObject(that, value);
      }
      Buffer.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype;
        Buffer.__proto__ = Uint8Array;
        "undefined" !== typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        });
      }
      function assertSize(size) {
        if ("number" !== typeof size) throw new TypeError('"size" argument must be a number');
        if (size < 0) throw new RangeError('"size" argument must not be negative');
      }
      function alloc(that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) return createBuffer(that, size);
        if (void 0 !== fill) return "string" === typeof encoding ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
        return createBuffer(that, size);
      }
      Buffer.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : 0 | checked(size));
        if (!Buffer.TYPED_ARRAY_SUPPORT) for (var i = 0; i < size; ++i) that[i] = 0;
        return that;
      }
      Buffer.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString(that, string, encoding) {
        "string" === typeof encoding && "" !== encoding || (encoding = "utf8");
        if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
        var length = 0 | byteLength(string, encoding);
        that = createBuffer(that, length);
        var actual = that.write(string, encoding);
        actual !== length && (that = that.slice(0, actual));
        return that;
      }
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : 0 | checked(array.length);
        that = createBuffer(that, length);
        for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
        return that;
      }
      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength;
        if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("'offset' is out of bounds");
        if (array.byteLength < byteOffset + (length || 0)) throw new RangeError("'length' is out of bounds");
        array = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          that = array;
          that.__proto__ = Buffer.prototype;
        } else that = fromArrayLike(that, array);
        return that;
      }
      function fromObject(that, obj) {
        if (Buffer.isBuffer(obj)) {
          var len = 0 | checked(obj.length);
          that = createBuffer(that, len);
          if (0 === that.length) return that;
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if ("undefined" !== typeof ArrayBuffer && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if ("number" !== typeof obj.length || isnan(obj.length)) return createBuffer(that, 0);
            return fromArrayLike(that, obj);
          }
          if ("Buffer" === obj.type && isArray(obj.data)) return fromArrayLike(that, obj.data);
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function checked(length) {
        if (length >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        return 0 | length;
      }
      function SlowBuffer(length) {
        +length != length && (length = 0);
        return Buffer.alloc(+length);
      }
      Buffer.isBuffer = function isBuffer(b) {
        return !!(null != b && b._isBuffer);
      };
      Buffer.compare = function compare(a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError("Arguments must be Buffers");
        if (a === b) return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
         case "hex":
         case "utf8":
         case "utf-8":
         case "ascii":
         case "latin1":
         case "binary":
         case "base64":
         case "ucs2":
         case "ucs-2":
         case "utf16le":
         case "utf-16le":
          return true;

         default:
          return false;
        }
      };
      Buffer.concat = function concat(list, length) {
        if (!isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === list.length) return Buffer.alloc(0);
        var i;
        if (void 0 === length) {
          length = 0;
          for (i = 0; i < list.length; ++i) length += list[i].length;
        }
        var buffer = Buffer.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer.isBuffer(string)) return string.length;
        if ("undefined" !== typeof ArrayBuffer && "function" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
        "string" !== typeof string && (string = "" + string);
        var len = string.length;
        if (0 === len) return 0;
        var loweredCase = false;
        for (;;) switch (encoding) {
         case "ascii":
         case "latin1":
         case "binary":
          return len;

         case "utf8":
         case "utf-8":
         case void 0:
          return utf8ToBytes(string).length;

         case "ucs2":
         case "ucs-2":
         case "utf16le":
         case "utf-16le":
          return 2 * len;

         case "hex":
          return len >>> 1;

         case "base64":
          return base64ToBytes(string).length;

         default:
          if (loweredCase) return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
        }
      }
      Buffer.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        (void 0 === start || start < 0) && (start = 0);
        if (start > this.length) return "";
        (void 0 === end || end > this.length) && (end = this.length);
        if (end <= 0) return "";
        end >>>= 0;
        start >>>= 0;
        if (end <= start) return "";
        encoding || (encoding = "utf8");
        while (true) switch (encoding) {
         case "hex":
          return hexSlice(this, start, end);

         case "utf8":
         case "utf-8":
          return utf8Slice(this, start, end);

         case "ascii":
          return asciiSlice(this, start, end);

         case "latin1":
         case "binary":
          return latin1Slice(this, start, end);

         case "base64":
          return base64Slice(this, start, end);

         case "ucs2":
         case "ucs-2":
         case "utf16le":
         case "utf-16le":
          return utf16leSlice(this, start, end);

         default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
        }
      }
      Buffer.prototype._isBuffer = true;
      function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var i = 0; i < len; i += 2) swap(this, i, i + 1);
        return this;
      };
      Buffer.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer.prototype.toString = function toString() {
        var length = 0 | this.length;
        if (0 === length) return "";
        if (0 === arguments.length) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer.prototype.equals = function equals(b) {
        if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return 0 === Buffer.compare(this, b);
      };
      Buffer.prototype.inspect = function inspect() {
        var str = "";
        var max = exports.INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          this.length > max && (str += " ... ");
        }
        return "<Buffer " + str + ">";
      };
      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (!Buffer.isBuffer(target)) throw new TypeError("Argument must be a Buffer");
        void 0 === start && (start = 0);
        void 0 === end && (end = target ? target.length : 0);
        void 0 === thisStart && (thisStart = 0);
        void 0 === thisEnd && (thisEnd = this.length);
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
        if (thisStart >= thisEnd && start >= end) return 0;
        if (thisStart >= thisEnd) return -1;
        if (start >= end) return 1;
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (0 === buffer.length) return -1;
        if ("string" === typeof byteOffset) {
          encoding = byteOffset;
          byteOffset = 0;
        } else byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648);
        byteOffset = +byteOffset;
        isNaN(byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1);
        byteOffset < 0 && (byteOffset = buffer.length + byteOffset);
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (!dir) return -1;
          byteOffset = 0;
        }
        "string" === typeof val && (val = Buffer.from(val, encoding));
        if (Buffer.isBuffer(val)) {
          if (0 === val.length) return -1;
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        }
        if ("number" === typeof val) {
          val &= 255;
          if (Buffer.TYPED_ARRAY_SUPPORT && "function" === typeof Uint8Array.prototype.indexOf) return dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (void 0 !== encoding) {
          encoding = String(encoding).toLowerCase();
          if ("ucs2" === encoding || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding) {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i) {
          return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
            -1 === foundIndex && (foundIndex = i);
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            -1 !== foundIndex && (i -= i - foundIndex);
            foundIndex = -1;
          }
        } else {
          byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength);
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
        return -1 !== this.indexOf(val, byteOffset, encoding);
      };
      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (length) {
          length = Number(length);
          length > remaining && (length = remaining);
        } else length = remaining;
        var strLen = string.length;
        if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
        length > strLen / 2 && (length = strLen / 2);
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(2 * i, 2), 16);
          if (isNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function latin1Write(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer.prototype.write = function write(string, offset, length, encoding) {
        if (void 0 === offset) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (void 0 === length && "string" === typeof offset) {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else {
          if (!isFinite(offset)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          offset |= 0;
          if (isFinite(length)) {
            length |= 0;
            void 0 === encoding && (encoding = "utf8");
          } else {
            encoding = length;
            length = void 0;
          }
        }
        var remaining = this.length - offset;
        (void 0 === length || length > remaining) && (length = remaining);
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        encoding || (encoding = "utf8");
        var loweredCase = false;
        for (;;) switch (encoding) {
         case "hex":
          return hexWrite(this, string, offset, length);

         case "utf8":
         case "utf-8":
          return utf8Write(this, string, offset, length);

         case "ascii":
          return asciiWrite(this, string, offset, length);

         case "latin1":
         case "binary":
          return latin1Write(this, string, offset, length);

         case "base64":
          return base64Write(this, string, offset, length);

         case "ucs2":
         case "ucs-2":
         case "utf16le":
         case "utf-16le":
          return ucs2Write(this, string, offset, length);

         default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
        }
      };
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
             case 1:
              firstByte < 128 && (codePoint = firstByte);
              break;

             case 2:
              secondByte = buf[i + 1];
              if (128 === (192 & secondByte)) {
                tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte;
                tempCodePoint > 127 && (codePoint = tempCodePoint);
              }
              break;

             case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if (128 === (192 & secondByte) && 128 === (192 & thirdByte)) {
                tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte;
                tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint);
              }
              break;

             case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if (128 === (192 & secondByte) && 128 === (192 & thirdByte) && 128 === (192 & fourthByte)) {
                tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte;
                tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint);
              }
            }
          }
          if (null === codePoint) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | 1023 & codePoint;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
        var res = "";
        var i = 0;
        while (i < len) res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) ret += String.fromCharCode(127 & buf[i]);
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        (!start || start < 0) && (start = 0);
        (!end || end < 0 || end > len) && (end = len);
        var out = "";
        for (var i = start; i < end; ++i) out += toHex(buf[i]);
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
        return res;
      }
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = void 0 === end ? len : ~~end;
        if (start < 0) {
          start += len;
          start < 0 && (start = 0);
        } else start > len && (start = len);
        if (end < 0) {
          end += len;
          end < 0 && (end = 0);
        } else end > len && (end = len);
        end < start && (end = start);
        var newBuf;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) newBuf[i] = this[i + start];
        }
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
        offset |= 0;
        byteLength |= 0;
        noAssert || checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
        return val;
      };
      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
        offset |= 0;
        byteLength |= 0;
        noAssert || checkOffset(offset, byteLength, this.length);
        var val = this[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0 && (mul *= 256)) val += this[offset + --byteLength] * mul;
        return val;
      };
      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        noAssert || checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        noAssert || checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        noAssert || checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
      };
      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
        offset |= 0;
        byteLength |= 0;
        noAssert || checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
        mul *= 128;
        val >= mul && (val -= Math.pow(2, 8 * byteLength));
        return val;
      };
      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
        offset |= 0;
        byteLength |= 0;
        noAssert || checkOffset(offset, byteLength, this.length);
        var i = byteLength;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) val += this[offset + --i] * mul;
        mul *= 128;
        val >= mul && (val -= Math.pow(2, 8 * byteLength));
        return val;
      };
      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
        noAssert || checkOffset(offset, 1, this.length);
        if (!(128 & this[offset])) return this[offset];
        return -1 * (255 - this[offset] + 1);
      };
      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        noAssert || checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return 32768 & val ? 4294901760 | val : val;
      };
      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        noAssert || checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return 32768 & val ? 4294901760 | val : val;
      };
      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        noAssert || checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        noAssert || checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        noAssert || checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset |= 0;
        byteLength |= 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = 255 & value;
        while (++i < byteLength && (mul *= 256)) this[offset + i] = value / mul & 255;
        return offset + byteLength;
      };
      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset |= 0;
        byteLength |= 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength) - 1;
          checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var i = byteLength - 1;
        var mul = 1;
        this[offset + i] = 255 & value;
        while (--i >= 0 && (mul *= 256)) this[offset + i] = value / mul & 255;
        return offset + byteLength;
      };
      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 1, 255, 0);
        Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value));
        this[offset] = 255 & value;
        return offset + 1;
      };
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        value < 0 && (value = 65535 + value + 1);
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> 8 * (littleEndian ? i : 1 - i);
      }
      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = 255 & value;
          this[offset + 1] = value >>> 8;
        } else objectWriteUInt16(this, value, offset, true);
        return offset + 2;
      };
      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = 255 & value;
        } else objectWriteUInt16(this, value, offset, false);
        return offset + 2;
      };
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        value < 0 && (value = 4294967295 + value + 1);
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) buf[offset + i] = value >>> 8 * (littleEndian ? i : 3 - i) & 255;
      }
      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = 255 & value;
        } else objectWriteUInt32(this, value, offset, true);
        return offset + 4;
      };
      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = 255 & value;
        } else objectWriteUInt32(this, value, offset, false);
        return offset + 4;
      };
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset |= 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = 255 & value;
        while (++i < byteLength && (mul *= 256)) {
          value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1);
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset |= 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = byteLength - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = 255 & value;
        while (--i >= 0 && (mul *= 256)) {
          value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1);
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 1, 127, -128);
        Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value));
        value < 0 && (value = 255 + value + 1);
        this[offset] = 255 & value;
        return offset + 1;
      };
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = 255 & value;
          this[offset + 1] = value >>> 8;
        } else objectWriteUInt16(this, value, offset, true);
        return offset + 2;
      };
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = 255 & value;
        } else objectWriteUInt16(this, value, offset, false);
        return offset + 2;
      };
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = 255 & value;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else objectWriteUInt32(this, value, offset, true);
        return offset + 4;
      };
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset |= 0;
        noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648);
        value < 0 && (value = 4294967295 + value + 1);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = 255 & value;
        } else objectWriteUInt32(this, value, offset, false);
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        noAssert || checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        noAssert || checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        start || (start = 0);
        end || 0 === end || (end = this.length);
        targetStart >= target.length && (targetStart = target.length);
        targetStart || (targetStart = 0);
        end > 0 && end < start && (end = start);
        if (end === start) return 0;
        if (0 === target.length || 0 === this.length) return 0;
        if (targetStart < 0) throw new RangeError("targetStart out of bounds");
        if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        end > this.length && (end = this.length);
        target.length - targetStart < end - start && (end = target.length - targetStart + start);
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) for (i = len - 1; i >= 0; --i) target[i + targetStart] = this[i + start]; else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) for (i = 0; i < len; ++i) target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
        return len;
      };
      Buffer.prototype.fill = function fill(val, start, end, encoding) {
        if ("string" === typeof val) {
          if ("string" === typeof start) {
            encoding = start;
            start = 0;
            end = this.length;
          } else if ("string" === typeof end) {
            encoding = end;
            end = this.length;
          }
          if (1 === val.length) {
            var code = val.charCodeAt(0);
            code < 256 && (val = code);
          }
          if (void 0 !== encoding && "string" !== typeof encoding) throw new TypeError("encoding must be a string");
          if ("string" === typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        } else "number" === typeof val && (val &= 255);
        if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
        if (end <= start) return this;
        start >>>= 0;
        end = void 0 === end ? this.length : end >>> 0;
        val || (val = 0);
        var i;
        if ("number" === typeof val) for (i = start; i < end; ++i) this[i] = val; else {
          var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) str += "=";
        return str;
      }
      function stringtrim(str) {
        if (str.trim) return str.trim();
        return str.replace(/^\s+|\s+$/g, "");
      }
      function toHex(n) {
        if (n < 16) return "0" + n.toString(16);
        return n.toString(16);
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                (units -= 3) > -1 && bytes.push(239, 191, 189);
                continue;
              }
              if (i + 1 === length) {
                (units -= 3) > -1 && bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              (units -= 3) > -1 && bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = 65536 + (leadSurrogate - 55296 << 10 | codePoint - 56320);
          } else leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
          } else {
            if (!(codePoint < 1114112)) throw new Error("Invalid code point");
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) byteArray.push(255 & str.charCodeAt(i));
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isnan(val) {
        return val !== val;
      }
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "base64-js": 1,
    ieee754: 5,
    isarray: 4
  } ],
  4: [ function(require, module, exports) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return "[object Array]" == toString.call(arr);
    };
  }, {} ],
  5: [ function(require, module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = 8 * nBytes - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (;nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8) ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (;nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8) ;
      if (0 === e) e = 1 - eBias; else {
        if (e === eMax) return m ? NaN : Infinity * (s ? -1 : 1);
        m += Math.pow(2, mLen);
        e -= eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = 8 * nBytes - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || Infinity === value) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        value += e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e += eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (;mLen >= 8; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8) ;
      e = e << mLen | m;
      eLen += mLen;
      for (;eLen > 0; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8) ;
      buffer[offset + i - d] |= 128 * s;
    };
  }, {} ],
  6: [ function(require, module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        cachedSetTimeout = "function" === typeof setTimeout ? setTimeout : defaultSetTimout;
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        cachedClearTimeout = "function" === typeof clearTimeout ? clearTimeout : defaultClearTimeout;
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) return;
      draining = false;
      currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1;
      queue.length && drainQueue();
    }
    function drainQueue() {
      if (draining) return;
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) currentQueue && currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
      queue.push(new Item(fun, args));
      1 !== queue.length || draining || runTimeout(drainQueue);
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
  }, {} ],
  7: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var util = require("@firebase/util");
    var contains = function(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    var DEFAULT_ENTRY_NAME = "[DEFAULT]";
    var tokenListeners = [];
    var FirebaseAppImpl = function() {
      function FirebaseAppImpl(options, config, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = config.name;
        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled || false;
        this.options_ = util.deepCopy(options);
        this.INTERNAL = {
          getUid: function() {
            return null;
          },
          getToken: function() {
            return Promise.resolve(null);
          },
          addAuthTokenListener: function(callback) {
            tokenListeners.push(callback);
            setTimeout(function() {
              return callback(null);
            }, 0);
          },
          removeAuthTokenListener: function(callback) {
            tokenListeners = tokenListeners.filter(function(listener) {
              return listener !== callback;
            });
          }
        };
      }
      Object.defineProperty(FirebaseAppImpl.prototype, "automaticDataCollectionEnabled", {
        get: function() {
          this.checkDestroyed_();
          return this._automaticDataCollectionEnabled;
        },
        set: function(val) {
          this.checkDestroyed_();
          this._automaticDataCollectionEnabled = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function() {
          this.checkDestroyed_();
          return this.name_;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function() {
          this.checkDestroyed_();
          return this.options_;
        },
        enumerable: true,
        configurable: true
      });
      FirebaseAppImpl.prototype.delete = function() {
        var _this = this;
        return new Promise(function(resolve) {
          _this.checkDestroyed_();
          resolve();
        }).then(function() {
          _this.firebase_.INTERNAL.removeApp(_this.name_);
          var services = [];
          Object.keys(_this.services_).forEach(function(serviceKey) {
            Object.keys(_this.services_[serviceKey]).forEach(function(instanceKey) {
              services.push(_this.services_[serviceKey][instanceKey]);
            });
          });
          return Promise.all(services.map(function(service) {
            return service.INTERNAL.delete();
          }));
        }).then(function() {
          _this.isDeleted_ = true;
          _this.services_ = {};
        });
      };
      FirebaseAppImpl.prototype._getService = function(name, instanceIdentifier) {
        void 0 === instanceIdentifier && (instanceIdentifier = DEFAULT_ENTRY_NAME);
        this.checkDestroyed_();
        this.services_[name] || (this.services_[name] = {});
        if (!this.services_[name][instanceIdentifier]) {
          var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : void 0;
          var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
          this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
      };
      FirebaseAppImpl.prototype.extendApp = function(props) {
        var _this = this;
        util.deepExtend(this, props);
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
          tokenListeners.forEach(function(listener) {
            _this.INTERNAL.addAuthTokenListener(listener);
          });
          tokenListeners = [];
        }
      };
      FirebaseAppImpl.prototype.checkDestroyed_ = function() {
        this.isDeleted_ && error("app-deleted", {
          name: this.name_
        });
      };
      return FirebaseAppImpl;
    }();
    FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log("dc");
    function createFirebaseNamespace() {
      var apps_ = {};
      var factories = {};
      var appHooks = {};
      var namespace = {
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: "5.0.4",
        INTERNAL: {
          registerService: registerService,
          createFirebaseNamespace: createFirebaseNamespace,
          extendNamespace: extendNamespace,
          createSubscribe: util.createSubscribe,
          ErrorFactory: util.ErrorFactory,
          removeApp: removeApp,
          factories: factories,
          useAsService: useAsService,
          Promise: Promise,
          deepExtend: util.deepExtend
        }
      };
      util.patchProperty(namespace, "default", namespace);
      Object.defineProperty(namespace, "apps", {
        get: getApps
      });
      function removeApp(name) {
        var app = apps_[name];
        callAppHooks(app, "delete");
        delete apps_[name];
      }
      function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        contains(apps_, name) || error("no-app", {
          name: name
        });
        return apps_[name];
      }
      util.patchProperty(app, "App", FirebaseAppImpl);
      function initializeApp(options, rawConfig) {
        void 0 === rawConfig && (rawConfig = {});
        if ("object" !== typeof rawConfig || null === rawConfig) {
          var name_1 = rawConfig;
          rawConfig = {
            name: name_1
          };
        }
        var config = rawConfig;
        void 0 === config.name && (config.name = DEFAULT_ENTRY_NAME);
        var name = config.name;
        "string" === typeof name && name || error("bad-app-name", {
          name: name + ""
        });
        contains(apps_, name) && error("duplicate-app", {
          name: name
        });
        var app = new FirebaseAppImpl(options, config, namespace);
        apps_[name] = app;
        callAppHooks(app, "create");
        return app;
      }
      function getApps() {
        return Object.keys(apps_).map(function(name) {
          return apps_[name];
        });
      }
      function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        factories[name] && error("duplicate-service", {
          name: name
        });
        factories[name] = createService;
        if (appHook) {
          appHooks[name] = appHook;
          getApps().forEach(function(app) {
            appHook("create", app);
          });
        }
        var serviceNamespace = function(appArg) {
          void 0 === appArg && (appArg = app());
          "function" !== typeof appArg[name] && error("invalid-app-argument", {
            name: name
          });
          return appArg[name]();
        };
        void 0 !== serviceProperties && util.deepExtend(serviceNamespace, serviceProperties);
        namespace[name] = serviceNamespace;
        FirebaseAppImpl.prototype[name] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          var serviceFxn = this._getService.bind(this, name);
          return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
      }
      function extendNamespace(props) {
        util.deepExtend(namespace, props);
      }
      function callAppHooks(app, eventName) {
        Object.keys(factories).forEach(function(serviceName) {
          var factoryName = useAsService(app, serviceName);
          if (null === factoryName) return;
          appHooks[factoryName] && appHooks[factoryName](eventName, app);
        });
      }
      function useAsService(app, name) {
        if ("serverAuth" === name) return null;
        var useService = name;
        var options = app.options;
        return useService;
      }
      return namespace;
    }
    function error(code, args) {
      throw appErrors.create(code, args);
    }
    var errors = {
      "no-app": "No Firebase App '{$name}' has been created - call Firebase App.initializeApp()",
      "bad-app-name": "Illegal App name: '{$name}",
      "duplicate-app": "Firebase App named '{$name}' already exists",
      "app-deleted": "Firebase App named '{$name}' already deleted",
      "duplicate-service": "Firebase service named '{$name}' already registered",
      "sa-not-supported": "Initializing the Firebase SDK with a service account is only allowed in a Node.js environment. On client devices, you should instead initialize the SDK with an api key and auth domain",
      "invalid-app-argument": "firebase.{$name}() takes either no argument or a Firebase App instance."
    };
    var appErrors = new util.ErrorFactory("app", "Firebase", errors);
    var firebase = createFirebaseNamespace();
    exports.firebase = firebase;
    exports.default = firebase;
  }, {
    "@firebase/util": 16
  } ],
  8: [ function(require, module, exports) {
    (function(global) {
      (function() {
        var firebase = require("@firebase/app").default;
        var g, aa = aa || {}, k = this;
        function l(a) {
          return "string" == typeof a;
        }
        function ba(a) {
          return "boolean" == typeof a;
        }
        function ca() {}
        function da(a) {
          var b = typeof a;
          if ("object" == b) {
            if (!a) return "null";
            if (a instanceof Array) return "array";
            if (a instanceof Object) return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c) return "object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
          } else if ("function" == b && "undefined" == typeof a.call) return "object";
          return b;
        }
        function ea(a) {
          return null === a;
        }
        function fa(a) {
          return "array" == da(a);
        }
        function ha(a) {
          var b = da(a);
          return "array" == b || "object" == b && "number" == typeof a.length;
        }
        function n(a) {
          return "function" == da(a);
        }
        function q(a) {
          var b = typeof a;
          return "object" == b && null != a || "function" == b;
        }
        var ia = "closure_uid_" + (1e9 * Math.random() >>> 0), ja = 0;
        function ka(a, b, c) {
          return a.call.apply(a.bind, arguments);
        }
        function la(a, b, c) {
          if (!a) throw Error();
          if (2 < arguments.length) {
            var d = Array.prototype.slice.call(arguments, 2);
            return function() {
              var c = Array.prototype.slice.call(arguments);
              Array.prototype.unshift.apply(c, d);
              return a.apply(b, c);
            };
          }
          return function() {
            return a.apply(b, arguments);
          };
        }
        function r(a, b, c) {
          r = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
          return r.apply(null, arguments);
        }
        function ma(a, b) {
          var c = Array.prototype.slice.call(arguments, 1);
          return function() {
            var b = c.slice();
            b.push.apply(b, arguments);
            return a.apply(this, b);
          };
        }
        var na = Date.now || function() {
          return +new Date();
        };
        function t(a, b) {
          function c() {}
          c.prototype = b.prototype;
          a.nb = b.prototype;
          a.prototype = new c();
          a.prototype.constructor = a;
          a.ed = function(a, c, f) {
            for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++) d[e - 2] = arguments[e];
            return b.prototype[c].apply(a, d);
          };
        }
        function oa(a) {
          a.prototype.then = a.prototype.then;
          a.prototype.$goog_Thenable = !0;
        }
        function pa(a) {
          if (!a) return !1;
          try {
            return !!a.$goog_Thenable;
          } catch (b) {
            return !1;
          }
        }
        function u(a) {
          if (Error.captureStackTrace) Error.captureStackTrace(this, u); else {
            var b = Error().stack;
            b && (this.stack = b);
          }
          a && (this.message = String(a));
        }
        t(u, Error);
        u.prototype.name = "CustomError";
        function qa(a, b) {
          a = a.split("%s");
          for (var c = "", d = a.length - 1, e = 0; e < d; e++) c += a[e] + (e < b.length ? b[e] : "%s");
          u.call(this, c + a[d]);
        }
        t(qa, u);
        qa.prototype.name = "AssertionError";
        function ra(a, b) {
          throw new qa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
        }
        function sa(a, b) {
          this.c = a;
          this.f = b;
          this.b = 0;
          this.a = null;
        }
        sa.prototype.get = function() {
          if (0 < this.b) {
            this.b--;
            var a = this.a;
            this.a = a.next;
            a.next = null;
          } else a = this.c();
          return a;
        };
        function ta(a, b) {
          a.f(b);
          100 > a.b && (a.b++, b.next = a.a, a.a = b);
        }
        function ua() {
          this.b = this.a = null;
        }
        var wa = new sa(function() {
          return new va();
        }, function(a) {
          a.reset();
        });
        ua.prototype.add = function(a, b) {
          var c = wa.get();
          c.set(a, b);
          this.b ? this.b.next = c : this.a = c;
          this.b = c;
        };
        function xa() {
          var a = ya, b = null;
          a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);
          return b;
        }
        function va() {
          this.next = this.b = this.a = null;
        }
        va.prototype.set = function(a, b) {
          this.a = a;
          this.b = b;
          this.next = null;
        };
        va.prototype.reset = function() {
          this.next = this.b = this.a = null;
        };
        var za = Array.prototype.indexOf ? function(a, b) {
          return Array.prototype.indexOf.call(a, b, void 0);
        } : function(a, b) {
          if (l(a)) return l(b) && 1 == b.length ? a.indexOf(b, 0) : -1;
          for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c;
          return -1;
        }, v = Array.prototype.forEach ? function(a, b, c) {
          Array.prototype.forEach.call(a, b, c);
        } : function(a, b, c) {
          for (var d = a.length, e = l(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
        };
        function Aa(a, b) {
          var c = a.length, d = l(a) ? a.split("") : a;
          for (--c; 0 <= c; --c) c in d && b.call(void 0, d[c], c, a);
        }
        var Ba = Array.prototype.map ? function(a, b) {
          return Array.prototype.map.call(a, b, void 0);
        } : function(a, b) {
          for (var c = a.length, d = Array(c), e = l(a) ? a.split("") : a, f = 0; f < c; f++) f in e && (d[f] = b.call(void 0, e[f], f, a));
          return d;
        }, Ca = Array.prototype.some ? function(a, b) {
          return Array.prototype.some.call(a, b, void 0);
        } : function(a, b) {
          for (var c = a.length, d = l(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) return !0;
          return !1;
        };
        function Da(a) {
          a: {
            var b = Ea;
            for (var c = a.length, d = l(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) {
              b = e;
              break a;
            }
            b = -1;
          }
          return 0 > b ? null : l(a) ? a.charAt(b) : a[b];
        }
        function Fa(a, b) {
          return 0 <= za(a, b);
        }
        function Ga(a, b) {
          b = za(a, b);
          var c;
          (c = 0 <= b) && Array.prototype.splice.call(a, b, 1);
          return c;
        }
        function w(a, b) {
          var c = 0;
          Aa(a, function(d, e) {
            b.call(void 0, d, e, a) && 1 == Array.prototype.splice.call(a, e, 1).length && c++;
          });
        }
        function Ha(a) {
          return Array.prototype.concat.apply([], arguments);
        }
        function Ia(a) {
          var b = a.length;
          if (0 < b) {
            for (var c = Array(b), d = 0; d < b; d++) c[d] = a[d];
            return c;
          }
          return [];
        }
        function Ja(a, b) {
          for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length; ) d += c.shift() + e.shift();
          return d + c.join("%s");
        }
        var Ka = String.prototype.trim ? function(a) {
          return a.trim();
        } : function(a) {
          return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
        };
        function La(a) {
          if (!Ma.test(a)) return a;
          -1 != a.indexOf("&") && (a = a.replace(Na, "&amp;"));
          -1 != a.indexOf("<") && (a = a.replace(Oa, "&lt;"));
          -1 != a.indexOf(">") && (a = a.replace(Pa, "&gt;"));
          -1 != a.indexOf('"') && (a = a.replace(Qa, "&quot;"));
          -1 != a.indexOf("'") && (a = a.replace(Ra, "&#39;"));
          -1 != a.indexOf("\0") && (a = a.replace(Sa, "&#0;"));
          return a;
        }
        var Na = /&/g, Oa = /</g, Pa = />/g, Qa = /"/g, Ra = /'/g, Sa = /\x00/g, Ma = /[\x00&<>"']/;
        function x(a, b) {
          return -1 != a.indexOf(b);
        }
        function Ta(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        var Ua;
        a: {
          var Va = k.navigator;
          if (Va) {
            var Wa = Va.userAgent;
            if (Wa) {
              Ua = Wa;
              break a;
            }
          }
          Ua = "";
        }
        function y(a) {
          return x(Ua, a);
        }
        function Xa(a, b) {
          for (var c in a) b.call(void 0, a[c], c, a);
        }
        function Ya(a) {
          for (var b in a) return !1;
          return !0;
        }
        function Za(a) {
          var b = {}, c;
          for (c in a) b[c] = a[c];
          return b;
        }
        var $a = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
        function ab(a, b) {
          for (var c, d, e = 1; e < arguments.length; e++) {
            d = arguments[e];
            for (c in d) a[c] = d[c];
            for (var f = 0; f < $a.length; f++) c = $a[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
          }
        }
        function bb(a) {
          k.setTimeout(function() {
            throw a;
          }, 0);
        }
        var cb;
        function db() {
          var a = k.MessageChannel;
          "undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !y("Presto") && (a = function() {
            var a = document.createElement("IFRAME");
            a.style.display = "none";
            a.src = "";
            document.documentElement.appendChild(a);
            var b = a.contentWindow;
            a = b.document;
            a.open();
            a.write("");
            a.close();
            var c = "callImmediate" + Math.random(), d = "file:" == b.location.protocol ? "*" : b.location.protocol + "//" + b.location.host;
            a = r(function(a) {
              "*" != d && a.origin != d || a.data != c || this.port1.onmessage();
            }, this);
            b.addEventListener("message", a, !1);
            this.port1 = {};
            this.port2 = {
              postMessage: function() {
                b.postMessage(c, d);
              }
            };
          });
          if ("undefined" !== typeof a && !y("Trident") && !y("MSIE")) {
            var b = new a(), c = {}, d = c;
            b.port1.onmessage = function() {
              if (void 0 !== c.next) {
                c = c.next;
                var a = c.vb;
                c.vb = null;
                a();
              }
            };
            return function(a) {
              d.next = {
                vb: a
              };
              d = d.next;
              b.port2.postMessage(0);
            };
          }
          return "undefined" !== typeof document && "onreadystatechange" in document.createElement("SCRIPT") ? function(a) {
            var b = document.createElement("SCRIPT");
            b.onreadystatechange = function() {
              b.onreadystatechange = null;
              b.parentNode.removeChild(b);
              b = null;
              a();
              a = null;
            };
            document.documentElement.appendChild(b);
          } : function(a) {
            k.setTimeout(a, 0);
          };
        }
        function eb(a, b) {
          fb || gb();
          hb || (fb(), hb = !0);
          ya.add(a, b);
        }
        var fb;
        function gb() {
          if (k.Promise && k.Promise.resolve) {
            var a = k.Promise.resolve(void 0);
            fb = function() {
              a.then(ib);
            };
          } else fb = function() {
            var a = ib;
            !n(k.setImmediate) || k.Window && k.Window.prototype && !y("Edge") && k.Window.prototype.setImmediate == k.setImmediate ? (cb || (cb = db()), 
            cb(a)) : k.setImmediate(a);
          };
        }
        var hb = !1, ya = new ua();
        function ib() {
          for (var a; a = xa(); ) {
            try {
              a.a.call(a.b);
            } catch (b) {
              bb(b);
            }
            ta(wa, a);
          }
          hb = !1;
        }
        function A(a, b) {
          this.a = jb;
          this.i = void 0;
          this.f = this.b = this.c = null;
          this.g = this.h = !1;
          if (a != ca) try {
            var c = this;
            a.call(b, function(a) {
              kb(c, lb, a);
            }, function(a) {
              if (!(a instanceof mb)) try {
                if (a instanceof Error) throw a;
                throw Error("Promise rejected.");
              } catch (e) {}
              kb(c, nb, a);
            });
          } catch (d) {
            kb(this, nb, d);
          }
        }
        var jb = 0, lb = 2, nb = 3;
        function ob() {
          this.next = this.f = this.b = this.g = this.a = null;
          this.c = !1;
        }
        ob.prototype.reset = function() {
          this.f = this.b = this.g = this.a = null;
          this.c = !1;
        };
        var pb = new sa(function() {
          return new ob();
        }, function(a) {
          a.reset();
        });
        function qb(a, b, c) {
          var d = pb.get();
          d.g = a;
          d.b = b;
          d.f = c;
          return d;
        }
        function B(a) {
          if (a instanceof A) return a;
          var b = new A(ca);
          kb(b, lb, a);
          return b;
        }
        function C(a) {
          return new A(function(b, c) {
            c(a);
          });
        }
        function rb(a, b, c) {
          sb(a, b, c, null) || eb(ma(b, a));
        }
        function tb(a) {
          return new A(function(b, c) {
            var d = a.length, e = [];
            if (d) for (var f = function(a, c) {
              d--;
              e[a] = c;
              0 == d && b(e);
            }, h = function(a) {
              c(a);
            }, m = 0, p; m < a.length; m++) p = a[m], rb(p, ma(f, m), h); else b(e);
          });
        }
        function ub(a) {
          return new A(function(b) {
            var c = a.length, d = [];
            if (c) for (var e = function(a, e, f) {
              c--;
              d[a] = e ? {
                Cb: !0,
                value: f
              } : {
                Cb: !1,
                reason: f
              };
              0 == c && b(d);
            }, f = 0, h; f < a.length; f++) h = a[f], rb(h, ma(e, f, !0), ma(e, f, !1)); else b(d);
          });
        }
        A.prototype.then = function(a, b, c) {
          return vb(this, n(a) ? a : null, n(b) ? b : null, c);
        };
        oa(A);
        g = A.prototype;
        g.ia = function(a, b) {
          a = qb(a, a, b);
          a.c = !0;
          wb(this, a);
          return this;
        };
        g.s = function(a, b) {
          return vb(this, null, a, b);
        };
        g.cancel = function(a) {
          this.a == jb && eb(function() {
            var b = new mb(a);
            xb(this, b);
          }, this);
        };
        function xb(a, b) {
          if (a.a == jb) if (a.c) {
            var c = a.c;
            if (c.b) {
              for (var d = 0, e = null, f = null, h = c.b; h && (h.c || (d++, h.a == a && (e = h), 
              !(e && 1 < d))); h = h.next) e || (f = h);
              e && (c.a == jb && 1 == d ? xb(c, b) : (f ? (d = f, d.next == c.f && (c.f = d), 
              d.next = d.next.next) : yb(c), zb(c, e, nb, b)));
            }
            a.c = null;
          } else kb(a, nb, b);
        }
        function wb(a, b) {
          a.b || a.a != lb && a.a != nb || Ab(a);
          a.f ? a.f.next = b : a.b = b;
          a.f = b;
        }
        function vb(a, b, c, d) {
          var e = qb(null, null, null);
          e.a = new A(function(a, h) {
            e.g = b ? function(c) {
              try {
                var e = b.call(d, c);
                a(e);
              } catch (z) {
                h(z);
              }
            } : a;
            e.b = c ? function(b) {
              try {
                var e = c.call(d, b);
                void 0 === e && b instanceof mb ? h(b) : a(e);
              } catch (z) {
                h(z);
              }
            } : h;
          });
          e.a.c = a;
          wb(a, e);
          return e.a;
        }
        g.Nc = function(a) {
          this.a = jb;
          kb(this, lb, a);
        };
        g.Oc = function(a) {
          this.a = jb;
          kb(this, nb, a);
        };
        function kb(a, b, c) {
          a.a == jb && (a === c && (b = nb, c = new TypeError("Promise cannot resolve to itself")), 
          a.a = 1, sb(c, a.Nc, a.Oc, a) || (a.i = c, a.a = b, a.c = null, Ab(a), b != nb || c instanceof mb || Bb(a, c)));
        }
        function sb(a, b, c, d) {
          if (a instanceof A) return wb(a, qb(b || ca, c || null, d)), !0;
          if (pa(a)) return a.then(b, c, d), !0;
          if (q(a)) try {
            var e = a.then;
            if (n(e)) return Cb(a, e, b, c, d), !0;
          } catch (f) {
            return c.call(d, f), !0;
          }
          return !1;
        }
        function Cb(a, b, c, d, e) {
          function f(a) {
            m || (m = !0, d.call(e, a));
          }
          function h(a) {
            m || (m = !0, c.call(e, a));
          }
          var m = !1;
          try {
            b.call(a, h, f);
          } catch (p) {
            f(p);
          }
        }
        function Ab(a) {
          a.h || (a.h = !0, eb(a.Yb, a));
        }
        function yb(a) {
          var b = null;
          a.b && (b = a.b, a.b = b.next, b.next = null);
          a.b || (a.f = null);
          return b;
        }
        g.Yb = function() {
          for (var a; a = yb(this); ) zb(this, a, this.a, this.i);
          this.h = !1;
        };
        function zb(a, b, c, d) {
          if (c == nb && b.b && !b.c) for (;a && a.g; a = a.c) a.g = !1;
          if (b.a) b.a.c = null, Db(b, c, d); else try {
            b.c ? b.g.call(b.f) : Db(b, c, d);
          } catch (e) {
            Eb.call(null, e);
          }
          ta(pb, b);
        }
        function Db(a, b, c) {
          b == lb ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
        }
        function Bb(a, b) {
          a.g = !0;
          eb(function() {
            a.g && Eb.call(null, b);
          });
        }
        var Eb = bb;
        function mb(a) {
          u.call(this, a);
        }
        t(mb, u);
        mb.prototype.name = "cancel";
        function Fb() {
          0 != Gb && (Hb[this[ia] || (this[ia] = ++ja)] = this);
          this.pa = this.pa;
          this.ja = this.ja;
        }
        var Gb = 0, Hb = {};
        Fb.prototype.pa = !1;
        function Ib(a) {
          if (!a.pa && (a.pa = !0, a.ua(), 0 != Gb)) {
            var b = a[ia] || (a[ia] = ++ja);
            if (0 != Gb && a.ja && 0 < a.ja.length) throw Error(a + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");
            delete Hb[b];
          }
        }
        Fb.prototype.ua = function() {
          if (this.ja) for (;this.ja.length; ) this.ja.shift()();
        };
        function Jb(a) {
          Jb[" "](a);
          return a;
        }
        Jb[" "] = ca;
        function Kb(a, b) {
          var c = Lb;
          return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
        }
        var Mb = y("Opera"), Nb = y("Trident") || y("MSIE"), Ob = y("Edge"), Pb = Ob || Nb, Qb = y("Gecko") && !(x(Ua.toLowerCase(), "webkit") && !y("Edge")) && !(y("Trident") || y("MSIE")) && !y("Edge"), Rb = x(Ua.toLowerCase(), "webkit") && !y("Edge");
        function Sb() {
          var a = k.document;
          return a ? a.documentMode : void 0;
        }
        var Tb;
        a: {
          var Ub = "", Vb = function() {
            var a = Ua;
            if (Qb) return /rv:([^\);]+)(\)|;)/.exec(a);
            if (Ob) return /Edge\/([\d\.]+)/.exec(a);
            if (Nb) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
            if (Rb) return /WebKit\/(\S+)/.exec(a);
            if (Mb) return /(?:Version)[ \/]?(\S+)/.exec(a);
          }();
          Vb && (Ub = Vb ? Vb[1] : "");
          if (Nb) {
            var Wb = Sb();
            if (null != Wb && Wb > parseFloat(Ub)) {
              Tb = String(Wb);
              break a;
            }
          }
          Tb = Ub;
        }
        var Lb = {};
        function Xb(a) {
          return Kb(a, function() {
            for (var b = 0, c = Ka(String(Tb)).split("."), d = Ka(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
              var h = c[f] || "", m = d[f] || "";
              do {
                h = /(\d*)(\D*)(.*)/.exec(h) || [ "", "", "", "" ];
                m = /(\d*)(\D*)(.*)/.exec(m) || [ "", "", "", "" ];
                if (0 == h[0].length && 0 == m[0].length) break;
                b = Ta(0 == h[1].length ? 0 : parseInt(h[1], 10), 0 == m[1].length ? 0 : parseInt(m[1], 10)) || Ta(0 == h[2].length, 0 == m[2].length) || Ta(h[2], m[2]);
                h = h[3];
                m = m[3];
              } while (0 == b);
            }
            return 0 <= b;
          });
        }
        var Yb;
        var Zb = k.document;
        Yb = Zb && Nb ? Sb() || ("CSS1Compat" == Zb.compatMode ? parseInt(Tb, 10) : 5) : void 0;
        var $b = Object.freeze || function(a) {
          return a;
        };
        var ac = !Nb || 9 <= Number(Yb), bc = Nb && !Xb("9"), cc = function() {
          if (!k.addEventListener || !Object.defineProperty) return !1;
          var a = !1, b = Object.defineProperty({}, "passive", {
            get: function() {
              a = !0;
            }
          });
          k.addEventListener("test", ca, b);
          k.removeEventListener("test", ca, b);
          return a;
        }();
        function D(a, b) {
          this.type = a;
          this.b = this.target = b;
          this.Jb = !0;
        }
        D.prototype.preventDefault = function() {
          this.Jb = !1;
        };
        function dc(a, b) {
          D.call(this, a ? a.type : "");
          this.relatedTarget = this.b = this.target = null;
          this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
          this.key = "";
          this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;
          this.pointerId = 0;
          this.pointerType = "";
          this.a = null;
          if (a) {
            var c = this.type = a.type, d = a.changedTouches ? a.changedTouches[0] : null;
            this.target = a.target || a.srcElement;
            this.b = b;
            if (b = a.relatedTarget) {
              if (Qb) {
                a: {
                  try {
                    Jb(b.nodeName);
                    var e = !0;
                    break a;
                  } catch (f) {}
                  e = !1;
                }
                e || (b = null);
              }
            } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);
            this.relatedTarget = b;
            null === d ? (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, 
            this.screenX = a.screenX || 0, this.screenY = a.screenY || 0) : (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, 
            this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, 
            this.screenY = d.screenY || 0);
            this.button = a.button;
            this.key = a.key || "";
            this.ctrlKey = a.ctrlKey;
            this.altKey = a.altKey;
            this.shiftKey = a.shiftKey;
            this.metaKey = a.metaKey;
            this.pointerId = a.pointerId || 0;
            this.pointerType = l(a.pointerType) ? a.pointerType : ec[a.pointerType] || "";
            this.a = a;
            a.defaultPrevented && this.preventDefault();
          }
        }
        t(dc, D);
        var ec = $b({
          2: "touch",
          3: "pen",
          4: "mouse"
        });
        dc.prototype.preventDefault = function() {
          dc.nb.preventDefault.call(this);
          var a = this.a;
          if (a.preventDefault) a.preventDefault(); else if (a.returnValue = !1, bc) try {
            (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) && (a.keyCode = -1);
          } catch (b) {}
        };
        dc.prototype.f = function() {
          return this.a;
        };
        var fc = "closure_listenable_" + (1e6 * Math.random() | 0), gc = 0;
        function hc(a, b, c, d, e) {
          this.listener = a;
          this.proxy = null;
          this.src = b;
          this.type = c;
          this.capture = !!d;
          this.La = e;
          this.key = ++gc;
          this.na = this.Ia = !1;
        }
        function ic(a) {
          a.na = !0;
          a.listener = null;
          a.proxy = null;
          a.src = null;
          a.La = null;
        }
        function jc(a) {
          this.src = a;
          this.a = {};
          this.b = 0;
        }
        jc.prototype.add = function(a, b, c, d, e) {
          var f = a.toString();
          a = this.a[f];
          a || (a = this.a[f] = [], this.b++);
          var h = kc(a, b, d, e);
          -1 < h ? (b = a[h], c || (b.Ia = !1)) : (b = new hc(b, this.src, f, !!d, e), b.Ia = c, 
          a.push(b));
          return b;
        };
        function lc(a, b) {
          var c = b.type;
          c in a.a && Ga(a.a[c], b) && (ic(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
        }
        function kc(a, b, c, d) {
          for (var e = 0; e < a.length; ++e) {
            var f = a[e];
            if (!f.na && f.listener == b && f.capture == !!c && f.La == d) return e;
          }
          return -1;
        }
        var mc = "closure_lm_" + (1e6 * Math.random() | 0), nc = {}, oc = 0;
        function pc(a, b, c, d, e) {
          if (d && d.once) rc(a, b, c, d, e); else if (fa(b)) for (var f = 0; f < b.length; f++) pc(a, b[f], c, d, e); else c = sc(c), 
          a && a[fc] ? tc(a, b, c, q(d) ? !!d.capture : !!d, e) : uc(a, b, c, !1, d, e);
        }
        function uc(a, b, c, d, e, f) {
          if (!b) throw Error("Invalid event type");
          var h = q(e) ? !!e.capture : !!e, m = vc(a);
          m || (a[mc] = m = new jc(a));
          c = m.add(b, c, d, h, f);
          if (!c.proxy) {
            d = wc();
            c.proxy = d;
            d.src = a;
            d.listener = c;
            if (a.addEventListener) cc || (e = h), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e); else if (a.attachEvent) a.attachEvent(xc(b.toString()), d); else {
              if (!a.addListener || !a.removeListener) throw Error("addEventListener and attachEvent are unavailable.");
              a.addListener(d);
            }
            oc++;
          }
        }
        function wc() {
          var a = yc, b = ac ? function(c) {
            return a.call(b.src, b.listener, c);
          } : function(c) {
            c = a.call(b.src, b.listener, c);
            if (!c) return c;
          };
          return b;
        }
        function rc(a, b, c, d, e) {
          if (fa(b)) for (var f = 0; f < b.length; f++) rc(a, b[f], c, d, e); else c = sc(c), 
          a && a[fc] ? zc(a, b, c, q(d) ? !!d.capture : !!d, e) : uc(a, b, c, !0, d, e);
        }
        function E(a, b, c, d, e) {
          if (fa(b)) for (var f = 0; f < b.length; f++) E(a, b[f], c, d, e); else d = q(d) ? !!d.capture : !!d, 
          c = sc(c), a && a[fc] ? (a = a.m, b = String(b).toString(), b in a.a && (f = a.a[b], 
          c = kc(f, c, d, e), -1 < c && (ic(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], 
          a.b--)))) : a && (a = vc(a)) && (b = a.a[b.toString()], a = -1, b && (a = kc(b, c, d, e)), 
          (c = -1 < a ? b[a] : null) && Ac(c));
        }
        function Ac(a) {
          if ("number" != typeof a && a && !a.na) {
            var b = a.src;
            if (b && b[fc]) lc(b.m, a); else {
              var c = a.type, d = a.proxy;
              b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(xc(c), d) : b.addListener && b.removeListener && b.removeListener(d);
              oc--;
              (c = vc(b)) ? (lc(c, a), 0 == c.b && (c.src = null, b[mc] = null)) : ic(a);
            }
          }
        }
        function xc(a) {
          return a in nc ? nc[a] : nc[a] = "on" + a;
        }
        function Bc(a, b, c, d) {
          var e = !0;
          if ((a = vc(a)) && (b = a.a[b.toString()])) for (b = b.concat(), a = 0; a < b.length; a++) {
            var f = b[a];
            f && f.capture == c && !f.na && (f = Cc(f, d), e = e && !1 !== f);
          }
          return e;
        }
        function Cc(a, b) {
          var c = a.listener, d = a.La || a.src;
          a.Ia && Ac(a);
          return c.call(d, b);
        }
        function yc(a, b) {
          if (a.na) return !0;
          if (!ac) {
            if (!b) a: {
              b = [ "window", "event" ];
              for (var c = k, d = 0; d < b.length; d++) if (c = c[b[d]], null == c) {
                b = null;
                break a;
              }
              b = c;
            }
            d = b;
            b = new dc(d, this);
            c = !0;
            if (!(0 > d.keyCode || void 0 != d.returnValue)) {
              a: {
                var e = !1;
                if (0 == d.keyCode) try {
                  d.keyCode = -1;
                  break a;
                } catch (h) {
                  e = !0;
                }
                (e || void 0 == d.returnValue) && (d.returnValue = !0);
              }
              d = [];
              for (e = b.b; e; e = e.parentNode) d.push(e);
              a = a.type;
              for (e = d.length - 1; 0 <= e; e--) {
                b.b = d[e];
                var f = Bc(d[e], a, !0, b);
                c = c && f;
              }
              for (e = 0; e < d.length; e++) b.b = d[e], f = Bc(d[e], a, !1, b), c = c && f;
            }
            return c;
          }
          return Cc(a, new dc(b, this));
        }
        function vc(a) {
          a = a[mc];
          return a instanceof jc ? a : null;
        }
        var Dc = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
        function sc(a) {
          if (n(a)) return a;
          a[Dc] || (a[Dc] = function(b) {
            return a.handleEvent(b);
          });
          return a[Dc];
        }
        function F() {
          Fb.call(this);
          this.m = new jc(this);
          this.Rb = this;
          this.Ua = null;
        }
        t(F, Fb);
        F.prototype[fc] = !0;
        F.prototype.addEventListener = function(a, b, c, d) {
          pc(this, a, b, c, d);
        };
        F.prototype.removeEventListener = function(a, b, c, d) {
          E(this, a, b, c, d);
        };
        F.prototype.dispatchEvent = function(a) {
          var b, c = this.Ua;
          if (c) for (b = []; c; c = c.Ua) b.push(c);
          c = this.Rb;
          var d = a.type || a;
          if (l(a)) a = new D(a, c); else if (a instanceof D) a.target = a.target || c; else {
            var e = a;
            a = new D(d, c);
            ab(a, e);
          }
          e = !0;
          if (b) for (var f = b.length - 1; 0 <= f; f--) {
            var h = a.b = b[f];
            e = Ec(h, d, !0, a) && e;
          }
          h = a.b = c;
          e = Ec(h, d, !0, a) && e;
          e = Ec(h, d, !1, a) && e;
          if (b) for (f = 0; f < b.length; f++) h = a.b = b[f], e = Ec(h, d, !1, a) && e;
          return e;
        };
        F.prototype.ua = function() {
          F.nb.ua.call(this);
          if (this.m) {
            var a = this.m, b = 0, c;
            for (c in a.a) {
              for (var d = a.a[c], e = 0; e < d.length; e++) ++b, ic(d[e]);
              delete a.a[c];
              a.b--;
            }
          }
          this.Ua = null;
        };
        function tc(a, b, c, d, e) {
          a.m.add(String(b), c, !1, d, e);
        }
        function zc(a, b, c, d, e) {
          a.m.add(String(b), c, !0, d, e);
        }
        function Ec(a, b, c, d) {
          b = a.m.a[String(b)];
          if (!b) return !0;
          b = b.concat();
          for (var e = !0, f = 0; f < b.length; ++f) {
            var h = b[f];
            if (h && !h.na && h.capture == c) {
              var m = h.listener, p = h.La || h.src;
              h.Ia && lc(a.m, h);
              e = !1 !== m.call(p, d) && e;
            }
          }
          return e && 0 != d.Jb;
        }
        function Fc(a, b, c) {
          if (n(a)) c && (a = r(a, c)); else {
            if (!a || "function" != typeof a.handleEvent) throw Error("Invalid listener argument");
            a = r(a.handleEvent, a);
          }
          return 2147483647 < Number(b) ? -1 : k.setTimeout(a, b || 0);
        }
        function Gc(a) {
          var b = null;
          return new A(function(c, d) {
            b = Fc(function() {
              c(void 0);
            }, a);
            -1 == b && d(Error("Failed to schedule timer."));
          }).s(function(a) {
            k.clearTimeout(b);
            throw a;
          });
        }
        function Hc(a) {
          if (a.S && "function" == typeof a.S) return a.S();
          if (l(a)) return a.split("");
          if (ha(a)) {
            for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);
            return b;
          }
          b = [];
          c = 0;
          for (d in a) b[c++] = a[d];
          return b;
        }
        function Ic(a) {
          if (a.U && "function" == typeof a.U) return a.U();
          if (!a.S || "function" != typeof a.S) {
            if (ha(a) || l(a)) {
              var b = [];
              a = a.length;
              for (var c = 0; c < a; c++) b.push(c);
              return b;
            }
            b = [];
            c = 0;
            for (var d in a) b[c++] = d;
            return b;
          }
        }
        function Jc(a, b) {
          if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0); else if (ha(a) || l(a)) v(a, b, void 0); else for (var c = Ic(a), d = Hc(a), e = d.length, f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
        }
        function Kc(a, b) {
          this.b = {};
          this.a = [];
          this.c = 0;
          var c = arguments.length;
          if (1 < c) {
            if (c % 2) throw Error("Uneven number of arguments");
            for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1]);
          } else if (a) if (a instanceof Kc) for (c = a.U(), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d])); else for (d in a) this.set(d, a[d]);
        }
        g = Kc.prototype;
        g.S = function() {
          Lc(this);
          for (var a = [], b = 0; b < this.a.length; b++) a.push(this.b[this.a[b]]);
          return a;
        };
        g.U = function() {
          Lc(this);
          return this.a.concat();
        };
        g.clear = function() {
          this.b = {};
          this.c = this.a.length = 0;
        };
        function Lc(a) {
          if (a.c != a.a.length) {
            for (var b = 0, c = 0; b < a.a.length; ) {
              var d = a.a[b];
              Mc(a.b, d) && (a.a[c++] = d);
              b++;
            }
            a.a.length = c;
          }
          if (a.c != a.a.length) {
            var e = {};
            for (c = b = 0; b < a.a.length; ) d = a.a[b], Mc(e, d) || (a.a[c++] = d, e[d] = 1), 
            b++;
            a.a.length = c;
          }
        }
        g.get = function(a, b) {
          return Mc(this.b, a) ? this.b[a] : b;
        };
        g.set = function(a, b) {
          Mc(this.b, a) || (this.c++, this.a.push(a));
          this.b[a] = b;
        };
        g.forEach = function(a, b) {
          for (var c = this.U(), d = 0; d < c.length; d++) {
            var e = c[d], f = this.get(e);
            a.call(b, f, e, this);
          }
        };
        function Mc(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        var Nc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
        function Oc(a, b) {
          if (a) {
            a = a.split("&");
            for (var c = 0; c < a.length; c++) {
              var d = a[c].indexOf("="), e = null;
              if (0 <= d) {
                var f = a[c].substring(0, d);
                e = a[c].substring(d + 1);
              } else f = a[c];
              b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
            }
          }
        }
        function Pc(a, b) {
          this.b = this.m = this.c = "";
          this.i = null;
          this.h = this.g = "";
          this.f = !1;
          if (a instanceof Pc) {
            this.f = void 0 !== b ? b : a.f;
            Rc(this, a.c);
            this.m = a.m;
            this.b = a.b;
            Sc(this, a.i);
            this.g = a.g;
            b = a.a;
            var c = new Tc();
            c.c = b.c;
            b.a && (c.a = new Kc(b.a), c.b = b.b);
            Uc(this, c);
            this.h = a.h;
          } else a && (c = String(a).match(Nc)) ? (this.f = !!b, Rc(this, c[1] || "", !0), 
          this.m = Vc(c[2] || ""), this.b = Vc(c[3] || "", !0), Sc(this, c[4]), this.g = Vc(c[5] || "", !0), 
          Uc(this, c[6] || "", !0), this.h = Vc(c[7] || "")) : (this.f = !!b, this.a = new Tc(null, this.f));
        }
        Pc.prototype.toString = function() {
          var a = [], b = this.c;
          b && a.push(Wc(b, Xc, !0), ":");
          var c = this.b;
          (c || "file" == b) && (a.push("//"), (b = this.m) && a.push(Wc(b, Xc, !0), "@"), 
          a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.i, 
          null != c && a.push(":", String(c)));
          (c = this.g) && (this.b && "/" != c.charAt(0) && a.push("/"), a.push(Wc(c, "/" == c.charAt(0) ? Yc : Zc, !0)));
          (c = this.a.toString()) && a.push("?", c);
          (c = this.h) && a.push("#", Wc(c, $c));
          return a.join("");
        };
        function Rc(a, b, c) {
          a.c = c ? Vc(b, !0) : b;
          a.c && (a.c = a.c.replace(/:$/, ""));
        }
        function Sc(a, b) {
          if (b) {
            b = Number(b);
            if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);
            a.i = b;
          } else a.i = null;
        }
        function Uc(a, b, c) {
          b instanceof Tc ? (a.a = b, ad(a.a, a.f)) : (c || (b = Wc(b, bd)), a.a = new Tc(b, a.f));
        }
        function G(a, b, c) {
          a.a.set(b, c);
        }
        function cd(a, b) {
          return a.a.get(b);
        }
        function dd(a) {
          return a instanceof Pc ? new Pc(a) : new Pc(a, void 0);
        }
        function ed(a, b) {
          var c = new Pc(null, void 0);
          Rc(c, "https");
          a && (c.b = a);
          b && (c.g = b);
          return c;
        }
        function Vc(a, b) {
          return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
        }
        function Wc(a, b, c) {
          return l(a) ? (a = encodeURI(a).replace(b, fd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), 
          a) : null;
        }
        function fd(a) {
          a = a.charCodeAt(0);
          return "%" + (a >> 4 & 15).toString(16) + (15 & a).toString(16);
        }
        var Xc = /[#\/\?@]/g, Zc = /[#\?:]/g, Yc = /[#\?]/g, bd = /[#\?@]/g, $c = /#/g;
        function Tc(a, b) {
          this.b = this.a = null;
          this.c = a || null;
          this.f = !!b;
        }
        function gd(a) {
          a.a || (a.a = new Kc(), a.b = 0, a.c && Oc(a.c, function(b, c) {
            a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
          }));
        }
        function hd(a) {
          var b = Ic(a);
          if ("undefined" == typeof b) throw Error("Keys are undefined");
          var c = new Tc(null, void 0);
          a = Hc(a);
          for (var d = 0; d < b.length; d++) {
            var e = b[d], f = a[d];
            fa(f) ? id(c, e, f) : c.add(e, f);
          }
          return c;
        }
        g = Tc.prototype;
        g.add = function(a, b) {
          gd(this);
          this.c = null;
          a = jd(this, a);
          var c = this.a.get(a);
          c || this.a.set(a, c = []);
          c.push(b);
          this.b += 1;
          return this;
        };
        function kd(a, b) {
          gd(a);
          b = jd(a, b);
          Mc(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, a = a.a, Mc(a.b, b) && (delete a.b[b], 
          a.c--, a.a.length > 2 * a.c && Lc(a)));
        }
        g.clear = function() {
          this.a = this.c = null;
          this.b = 0;
        };
        function ld(a, b) {
          gd(a);
          b = jd(a, b);
          return Mc(a.a.b, b);
        }
        g.forEach = function(a, b) {
          gd(this);
          this.a.forEach(function(c, d) {
            v(c, function(c) {
              a.call(b, c, d, this);
            }, this);
          }, this);
        };
        g.U = function() {
          gd(this);
          for (var a = this.a.S(), b = this.a.U(), c = [], d = 0; d < b.length; d++) for (var e = a[d], f = 0; f < e.length; f++) c.push(b[d]);
          return c;
        };
        g.S = function(a) {
          gd(this);
          var b = [];
          if (l(a)) ld(this, a) && (b = Ha(b, this.a.get(jd(this, a)))); else {
            a = this.a.S();
            for (var c = 0; c < a.length; c++) b = Ha(b, a[c]);
          }
          return b;
        };
        g.set = function(a, b) {
          gd(this);
          this.c = null;
          a = jd(this, a);
          ld(this, a) && (this.b -= this.a.get(a).length);
          this.a.set(a, [ b ]);
          this.b += 1;
          return this;
        };
        g.get = function(a, b) {
          a = a ? this.S(a) : [];
          return 0 < a.length ? String(a[0]) : b;
        };
        function id(a, b, c) {
          kd(a, b);
          0 < c.length && (a.c = null, a.a.set(jd(a, b), Ia(c)), a.b += c.length);
        }
        g.toString = function() {
          if (this.c) return this.c;
          if (!this.a) return "";
          for (var a = [], b = this.a.U(), c = 0; c < b.length; c++) {
            var d = b[c], e = encodeURIComponent(String(d));
            d = this.S(d);
            for (var f = 0; f < d.length; f++) {
              var h = e;
              "" !== d[f] && (h += "=" + encodeURIComponent(String(d[f])));
              a.push(h);
            }
          }
          return this.c = a.join("&");
        };
        function jd(a, b) {
          b = String(b);
          a.f && (b = b.toLowerCase());
          return b;
        }
        function ad(a, b) {
          b && !a.f && (gd(a), a.c = null, a.a.forEach(function(a, b) {
            var c = b.toLowerCase();
            b != c && (kd(this, b), id(this, c, a));
          }, a));
          a.f = b;
        }
        var md = !Nb || 9 <= Number(Yb);
        function nd() {
          this.a = "";
          this.b = od;
        }
        nd.prototype.ma = !0;
        nd.prototype.la = function() {
          return this.a;
        };
        nd.prototype.toString = function() {
          return "Const{" + this.a + "}";
        };
        function pd(a) {
          if (a instanceof nd && a.constructor === nd && a.b === od) return a.a;
          ra("expected object of type Const, got '" + a + "'");
          return "type_error:Const";
        }
        var od = {};
        function qd(a) {
          var b = new nd();
          b.a = a;
          return b;
        }
        qd("");
        function rd() {
          this.a = "";
          this.b = sd;
        }
        rd.prototype.ma = !0;
        rd.prototype.la = function() {
          return this.a;
        };
        rd.prototype.toString = function() {
          return "TrustedResourceUrl{" + this.a + "}";
        };
        function td(a) {
          if (a instanceof rd && a.constructor === rd && a.b === sd) return a.a;
          ra("expected object of type TrustedResourceUrl, got '" + a + "' of type " + da(a));
          return "type_error:TrustedResourceUrl";
        }
        function ud(a, b) {
          var c = pd(a);
          if (!vd.test(c)) throw Error("Invalid TrustedResourceUrl format: " + c);
          a = c.replace(wd, function(a, e) {
            if (!Object.prototype.hasOwnProperty.call(b, e)) throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b));
            a = b[e];
            return a instanceof nd ? pd(a) : encodeURIComponent(String(a));
          });
          return xd(a);
        }
        var wd = /%{(\w+)}/g, vd = /^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank#/i, sd = {};
        function xd(a) {
          var b = new rd();
          b.a = a;
          return b;
        }
        function yd() {
          this.a = "";
          this.b = zd;
        }
        yd.prototype.ma = !0;
        yd.prototype.la = function() {
          return this.a;
        };
        yd.prototype.toString = function() {
          return "SafeUrl{" + this.a + "}";
        };
        function Ad(a) {
          if (a instanceof yd && a.constructor === yd && a.b === zd) return a.a;
          ra("expected object of type SafeUrl, got '" + a + "' of type " + da(a));
          return "type_error:SafeUrl";
        }
        var Bd = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
        function Cd(a) {
          if (a instanceof yd) return a;
          a = a.ma ? a.la() : String(a);
          Bd.test(a) || (a = "about:invalid#zClosurez");
          return Dd(a);
        }
        var zd = {};
        function Dd(a) {
          var b = new yd();
          b.a = a;
          return b;
        }
        Dd("about:blank");
        function Ed() {
          this.a = "";
          this.b = Fd;
        }
        Ed.prototype.ma = !0;
        Ed.prototype.la = function() {
          return this.a;
        };
        Ed.prototype.toString = function() {
          return "SafeHtml{" + this.a + "}";
        };
        function Gd(a) {
          if (a instanceof Ed && a.constructor === Ed && a.b === Fd) return a.a;
          ra("expected object of type SafeHtml, got '" + a + "' of type " + da(a));
          return "type_error:SafeHtml";
        }
        var Fd = {};
        function Hd(a) {
          var b = new Ed();
          b.a = a;
          return b;
        }
        Hd("<!DOCTYPE html>");
        Hd("");
        Hd("<br>");
        function Id(a) {
          var b = document;
          return l(a) ? b.getElementById(a) : a;
        }
        function Jd(a, b) {
          Xa(b, function(b, d) {
            b && b.ma && (b = b.la());
            "style" == d ? a.style.cssText = b : "class" == d ? a.className = b : "for" == d ? a.htmlFor = b : Kd.hasOwnProperty(d) ? a.setAttribute(Kd[d], b) : 0 == d.lastIndexOf("aria-", 0) || 0 == d.lastIndexOf("data-", 0) ? a.setAttribute(d, b) : a[d] = b;
          });
        }
        var Kd = {
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          colspan: "colSpan",
          frameborder: "frameBorder",
          height: "height",
          maxlength: "maxLength",
          nonce: "nonce",
          role: "role",
          rowspan: "rowSpan",
          type: "type",
          usemap: "useMap",
          valign: "vAlign",
          width: "width"
        };
        function Ld(a, b, c) {
          var d = arguments, e = document, f = String(d[0]), h = d[1];
          if (!md && h && (h.name || h.type)) {
            f = [ "<", f ];
            h.name && f.push(' name="', La(h.name), '"');
            if (h.type) {
              f.push(' type="', La(h.type), '"');
              var m = {};
              ab(m, h);
              delete m.type;
              h = m;
            }
            f.push(">");
            f = f.join("");
          }
          f = e.createElement(f);
          h && (l(h) ? f.className = h : fa(h) ? f.className = h.join(" ") : Jd(f, h));
          2 < d.length && Md(e, f, d);
          return f;
        }
        function Md(a, b, c) {
          function d(c) {
            c && b.appendChild(l(c) ? a.createTextNode(c) : c);
          }
          for (var e = 2; e < c.length; e++) {
            var f = c[e];
            !ha(f) || q(f) && 0 < f.nodeType ? d(f) : v(Nd(f) ? Ia(f) : f, d);
          }
        }
        function Nd(a) {
          if (a && "number" == typeof a.length) {
            if (q(a)) return "function" == typeof a.item || "string" == typeof a.item;
            if (n(a)) return "function" == typeof a.item;
          }
          return !1;
        }
        function Od(a) {
          var b = [];
          Pd(new Qd(), a, b);
          return b.join("");
        }
        function Qd() {}
        function Pd(a, b, c) {
          if (null == b) c.push("null"); else {
            if ("object" == typeof b) {
              if (fa(b)) {
                var d = b;
                b = d.length;
                c.push("[");
                for (var e = "", f = 0; f < b; f++) c.push(e), Pd(a, d[f], c), e = ",";
                c.push("]");
                return;
              }
              if (!(b instanceof String || b instanceof Number || b instanceof Boolean)) {
                c.push("{");
                e = "";
                for (d in b) Object.prototype.hasOwnProperty.call(b, d) && (f = b[d], "function" != typeof f && (c.push(e), 
                Rd(d, c), c.push(":"), Pd(a, f, c), e = ","));
                c.push("}");
                return;
              }
              b = b.valueOf();
            }
            switch (typeof b) {
             case "string":
              Rd(b, c);
              break;

             case "number":
              c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");
              break;

             case "boolean":
              c.push(String(b));
              break;

             case "function":
              c.push("null");
              break;

             default:
              throw Error("Unknown type: " + typeof b);
            }
          }
        }
        var Sd = {
          '"': '\\"',
          "\\": "\\\\",
          "/": "\\/",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "\t": "\\t",
          "\v": "\\u000b"
        }, Td = /\uffff/.test("") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
        function Rd(a, b) {
          b.push('"', a.replace(Td, function(a) {
            var b = Sd[a];
            b || (b = "\\u" + (65536 | a.charCodeAt(0)).toString(16).substr(1), Sd[a] = b);
            return b;
          }), '"');
        }
        function Ud() {
          var a = H();
          return Nb && !!Yb && 11 == Yb || /Edge\/\d+/.test(a);
        }
        function Vd() {
          return k.window && k.window.location.href || self && self.location && self.location.href || "";
        }
        function Wd(a, b) {
          b = b || k.window;
          var c = "about:blank";
          a && (c = Ad(Cd(a)));
          b.location.href = c;
        }
        function Xd(a, b) {
          var c = [], d;
          for (d in a) d in b ? typeof a[d] != typeof b[d] ? c.push(d) : "object" == typeof a[d] && null != a[d] && null != b[d] ? 0 < Xd(a[d], b[d]).length && c.push(d) : a[d] !== b[d] && c.push(d) : c.push(d);
          for (d in b) d in a || c.push(d);
          return c;
        }
        function Yd() {
          var a = H();
          a = Zd(a) != $d ? null : (a = a.match(/\sChrome\/(\d+)/i)) && 2 == a.length ? parseInt(a[1], 10) : null;
          return !(a && 30 > a) && (!Nb || !Yb || 9 < Yb);
        }
        function ae(a) {
          a = (a || H()).toLowerCase();
          return !!(a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/));
        }
        function be(a) {
          a = a || k.window;
          try {
            a.close();
          } catch (b) {}
        }
        function ce(a, b, c) {
          var d = Math.floor(1e9 * Math.random()).toString();
          b = b || 500;
          c = c || 600;
          var e = (window.screen.availHeight - c) / 2, f = (window.screen.availWidth - b) / 2;
          b = {
            width: b,
            height: c,
            top: 0 < e ? e : 0,
            left: 0 < f ? f : 0,
            location: !0,
            resizable: !0,
            statusbar: !0,
            toolbar: !1
          };
          c = H().toLowerCase();
          d && (b.target = d, x(c, "crios/") && (b.target = "_blank"));
          Zd(H()) == de && (a = a || "http://localhost", b.scrollbars = !0);
          c = a || "";
          (a = b) || (a = {});
          d = window;
          b = c instanceof yd ? c : Cd("undefined" != typeof c.href ? c.href : String(c));
          c = a.target || c.target;
          e = [];
          for (h in a) switch (h) {
           case "width":
           case "height":
           case "top":
           case "left":
            e.push(h + "=" + a[h]);
            break;

           case "target":
           case "noopener":
           case "noreferrer":
            break;

           default:
            e.push(h + "=" + (a[h] ? 1 : 0));
          }
          var h = e.join(",");
          (y("iPhone") && !y("iPod") && !y("iPad") || y("iPad") || y("iPod")) && d.navigator && d.navigator.standalone && c && "_self" != c ? (h = d.document.createElement("A"), 
          b instanceof yd || b instanceof yd || (b = b.ma ? b.la() : String(b), Bd.test(b) || (b = "about:invalid#zClosurez"), 
          b = Dd(b)), h.href = Ad(b), h.setAttribute("target", c), a.noreferrer && h.setAttribute("rel", "noreferrer"), 
          a = document.createEvent("MouseEvent"), a.initMouseEvent("click", !0, !0, d, 1), 
          h.dispatchEvent(a), h = {}) : a.noreferrer ? (h = d.open("", c, h), a = Ad(b), h && (Pb && x(a, ";") && (a = "'" + a.replace(/'/g, "%27") + "'"), 
          h.opener = null, qd("b/12014412, meta tag with sanitized URL"), a = '<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + La(a) + '">', 
          a = Hd(a), h.document.write(Gd(a)), h.document.close())) : (h = d.open(Ad(b), c, h)) && a.noopener && (h.opener = null);
          if (h) try {
            h.focus();
          } catch (m) {}
          return h;
        }
        function ee(a) {
          return new A(function(b) {
            function c() {
              Gc(2e3).then(function() {
                if (a && !a.closed) return c();
                b();
              });
            }
            return c();
          });
        }
        var fe = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        function ge() {
          var a = null;
          return new A(function(b) {
            "complete" == k.document.readyState ? b() : (a = function() {
              b();
            }, rc(window, "load", a));
          }).s(function(b) {
            E(window, "load", a);
            throw b;
          });
        }
        function he() {
          return ie(void 0) ? ge().then(function() {
            return new A(function(a, b) {
              var c = k.document, d = setTimeout(function() {
                b(Error("Cordova framework is not ready."));
              }, 1e3);
              c.addEventListener("deviceready", function() {
                clearTimeout(d);
                a();
              }, !1);
            });
          }) : C(Error("Cordova must run in an Android or iOS file scheme."));
        }
        function ie(a) {
          a = a || H();
          return !("file:" !== je() || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
        }
        function ke() {
          var a = k.window;
          try {
            return !(!a || a == a.top);
          } catch (b) {
            return !1;
          }
        }
        function le() {
          return "object" !== typeof k.window && "function" === typeof k.importScripts;
        }
        function me() {
          return firebase.INTERNAL.hasOwnProperty("reactNative") ? "ReactNative" : firebase.INTERNAL.hasOwnProperty("node") ? "Node" : le() ? "Worker" : "Browser";
        }
        function ne() {
          var a = me();
          return "ReactNative" === a || "Node" === a;
        }
        function oe() {
          for (var a = 50, b = []; 0 < a; ) b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), 
          a--;
          return b.join("");
        }
        var de = "Firefox", $d = "Chrome";
        function Zd(a) {
          var b = a.toLowerCase();
          if (x(b, "opera/") || x(b, "opr/") || x(b, "opios/")) return "Opera";
          if (x(b, "iemobile")) return "IEMobile";
          if (x(b, "msie") || x(b, "trident/")) return "IE";
          if (x(b, "edge/")) return "Edge";
          if (x(b, "firefox/")) return de;
          if (x(b, "silk/")) return "Silk";
          if (x(b, "blackberry")) return "Blackberry";
          if (x(b, "webos")) return "Webos";
          if (x(b, "safari/") && !x(b, "chrome/") && !x(b, "crios/") && !x(b, "android")) return "Safari";
          if ((x(b, "chrome/") || x(b, "crios/")) && !x(b, "edge/")) return $d;
          if (x(b, "android")) return "Android";
          if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && 2 == a.length) return a[1];
          return "Other";
        }
        var pe = {
          Uc: "FirebaseCore-web",
          Wc: "FirebaseUI-web"
        };
        function qe(a, b) {
          b = b || [];
          var c = [], d = {}, e;
          for (e in pe) d[pe[e]] = !0;
          for (e = 0; e < b.length; e++) "undefined" !== typeof d[b[e]] && (delete d[b[e]], 
          c.push(b[e]));
          c.sort();
          b = c;
          b.length || (b = [ "FirebaseCore-web" ]);
          c = me();
          "Browser" === c ? (d = H(), c = Zd(d)) : "Worker" === c && (d = H(), c = Zd(d) + "-" + c);
          return c + "/JsCore/" + a + "/" + b.join(",");
        }
        function H() {
          return k.navigator && k.navigator.userAgent || "";
        }
        function I(a, b) {
          a = a.split(".");
          b = b || k;
          for (var c = 0; c < a.length && "object" == typeof b && null != b; c++) b = b[a[c]];
          c != a.length && (b = void 0);
          return b;
        }
        function re() {
          try {
            var a = k.localStorage, b = se();
            if (a) return a.setItem(b, "1"), a.removeItem(b), !Ud() || !!k.indexedDB;
          } catch (c) {
            return le() && !!k.indexedDB;
          }
          return !1;
        }
        function te() {
          return (ue() || "chrome-extension:" === je() || ie()) && !ne() && re() && !le();
        }
        function ue() {
          return "http:" === je() || "https:" === je();
        }
        function je() {
          return k.location && k.location.protocol || null;
        }
        function ve(a) {
          a = a || H();
          return !ae(a) && Zd(a) != de;
        }
        function we(a) {
          return "undefined" === typeof a ? null : Od(a);
        }
        function xe(a) {
          var b = {}, c;
          for (c in a) a.hasOwnProperty(c) && null !== a[c] && void 0 !== a[c] && (b[c] = a[c]);
          return b;
        }
        function ye(a) {
          if (null !== a) return JSON.parse(a);
        }
        function se(a) {
          return a || Math.floor(1e9 * Math.random()).toString();
        }
        function ze(a) {
          a = a || H();
          return "Safari" != Zd(a) && !a.toLowerCase().match(/iphone|ipad|ipod/);
        }
        function Ae() {
          var a = k.___jsl;
          if (a && a.H) for (var b in a.H) if (a.H[b].r = a.H[b].r || [], a.H[b].L = a.H[b].L || [], 
          a.H[b].r = a.H[b].L.concat(), a.CP) for (var c = 0; c < a.CP.length; c++) a.CP[c] = null;
        }
        function Be(a, b) {
          if (a > b) throw Error("Short delay should be less than long delay!");
          this.a = a;
          this.c = b;
          a = H();
          b = me();
          this.b = ae(a) || "ReactNative" === b;
        }
        Be.prototype.get = function() {
          var a = k.navigator;
          return (a && "boolean" === typeof a.onLine && (ue() || "chrome-extension:" === je() || "undefined" !== typeof a.connection) ? a.onLine : 1) ? this.b ? this.c : this.a : Math.min(5e3, this.a);
        };
        function Ce() {
          var a = k.document;
          return !a || "undefined" === typeof a.visibilityState || "visible" == a.visibilityState;
        }
        function De() {
          var a = k.document, b = null;
          return Ce() || !a ? B() : new A(function(c) {
            b = function() {
              Ce() && (a.removeEventListener("visibilitychange", b, !1), c());
            };
            a.addEventListener("visibilitychange", b, !1);
          }).s(function(c) {
            a.removeEventListener("visibilitychange", b, !1);
            throw c;
          });
        }
        function Ee(a) {
          try {
            var b = new Date(parseInt(a, 10));
            if (!isNaN(b.getTime()) && !/[^0-9]/.test(a)) return b.toUTCString();
          } catch (c) {}
          return null;
        }
        function Fe() {
          return !(!I("fireauth.oauthhelper", k) && !I("fireauth.iframe", k));
        }
        var Ge = {};
        function He(a) {
          Ge[a] || (Ge[a] = !0, "undefined" !== typeof console && "function" === typeof console.warn && console.warn(a));
        }
        var Ie;
        try {
          var Je = {};
          Object.defineProperty(Je, "abcd", {
            configurable: !0,
            enumerable: !0,
            value: 1
          });
          Object.defineProperty(Je, "abcd", {
            configurable: !0,
            enumerable: !0,
            value: 2
          });
          Ie = 2 == Je.abcd;
        } catch (a) {
          Ie = !1;
        }
        function J(a, b, c) {
          Ie ? Object.defineProperty(a, b, {
            configurable: !0,
            enumerable: !0,
            value: c
          }) : a[b] = c;
        }
        function K(a, b) {
          if (b) for (var c in b) b.hasOwnProperty(c) && J(a, c, b[c]);
        }
        function Ke(a) {
          var b = {};
          K(b, a);
          return b;
        }
        function Le(a) {
          var b = {}, c;
          for (c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
          return b;
        }
        function Me(a, b) {
          if (!b || !b.length) return !0;
          if (!a) return !1;
          for (var c = 0; c < b.length; c++) {
            var d = a[b[c]];
            if (void 0 === d || null === d || "" === d) return !1;
          }
          return !0;
        }
        function Ne(a) {
          var b = a;
          if ("object" == typeof a && null != a) {
            b = "length" in a ? [] : {};
            for (var c in a) J(b, c, Ne(a[c]));
          }
          return b;
        }
        function Oe(a) {
          var b = {}, c = a[Pe], d = a[Qe];
          a = a[Re];
          if (!a || a != Se && !c) throw Error("Invalid provider user info!");
          b[Te] = d || null;
          b[Ue] = c || null;
          J(this, Ve, a);
          J(this, We, Ne(b));
        }
        var Se = "EMAIL_SIGNIN", Pe = "email", Qe = "newEmail", Re = "requestType", Ue = "email", Te = "fromEmail", We = "data", Ve = "operation";
        function L(a, b) {
          this.code = Xe + a;
          this.message = b || Ye[a] || "";
        }
        t(L, Error);
        L.prototype.D = function() {
          return {
            code: this.code,
            message: this.message
          };
        };
        L.prototype.toJSON = function() {
          return this.D();
        };
        function Ze(a) {
          var b = a && a.code;
          return b ? new L(b.substring(Xe.length), a.message) : null;
        }
        var Xe = "auth/", Ye = {
          "argument-error": "",
          "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
          "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
          "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
          "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
          "cordova-not-ready": "Cordova framework is not ready.",
          "cors-unsupported": "This browser is not supported.",
          "credential-already-in-use": "This credential is already associated with a different user account.",
          "custom-token-mismatch": "The custom token corresponds to a different audience.",
          "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
          "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
          "email-already-in-use": "The email address is already in use by another account.",
          "expired-action-code": "The action code has expired. ",
          "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
          "internal-error": "An internal error has occurred.",
          "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
          "invalid-app-id": "The mobile app identifier is not registed for the current project.",
          "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
          "invalid-auth-event": "An internal error has occurred.",
          "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.",
          "invalid-continue-uri": "The continue URL provided in the request is invalid.",
          "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
          "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
          "invalid-email": "The email address is badly formatted.",
          "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
          "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
          "invalid-credential": "The supplied auth credential is malformed or has expired.",
          "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
          "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
          "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
          "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
          "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
          "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
          "wrong-password": "The password is invalid or the user does not have a password.",
          "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
          "invalid-provider-id": "The specified provider ID is invalid.",
          "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
          "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
          "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
          "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
          "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
          "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
          "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
          "missing-continue-uri": "A continue URL must be provided in the request.",
          "missing-iframe-start": "An internal error has occurred.",
          "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
          "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
          "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
          "app-deleted": "This instance of FirebaseApp has been deleted.",
          "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
          "network-request-failed": "A network error (such as timeout, interrupted connection or unreachable host) has occurred.",
          "no-auth-event": "An internal error has occurred.",
          "no-such-provider": "User was not linked to an account with the given provider.",
          "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
          "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
          "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
          "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
          "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
          "provider-already-linked": "User can only be linked to one identity for the given provider.",
          "quota-exceeded": "The project's quota for this operation has been exceeded.",
          "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
          "redirect-operation-pending": "A redirect sign-in operation is already pending.",
          timeout: "The operation has timed out.",
          "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
          "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
          "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
          "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
          "user-cancelled": "User did not grant your application the permissions it requested.",
          "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
          "user-disabled": "The user account has been disabled by an administrator.",
          "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
          "user-signed-out": "",
          "weak-password": "The password must be 6 characters long or more.",
          "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled."
        };
        function $e(a) {
          var b = a[af];
          if ("undefined" === typeof b) throw new L("missing-continue-uri");
          if ("string" !== typeof b || "string" === typeof b && !b.length) throw new L("invalid-continue-uri");
          this.h = b;
          this.b = this.a = null;
          this.g = !1;
          var c = a[bf];
          if (c && "object" === typeof c) {
            b = c[cf];
            var d = c[df];
            c = c[ef];
            if ("string" === typeof b && b.length) {
              this.a = b;
              if ("undefined" !== typeof d && "boolean" !== typeof d) throw new L("argument-error", df + " property must be a boolean when specified.");
              this.g = !!d;
              if ("undefined" !== typeof c && ("string" !== typeof c || "string" === typeof c && !c.length)) throw new L("argument-error", ef + " property must be a non empty string when specified.");
              this.b = c || null;
            } else {
              if ("undefined" !== typeof b) throw new L("argument-error", cf + " property must be a non empty string when specified.");
              if ("undefined" !== typeof d || "undefined" !== typeof c) throw new L("missing-android-pkg-name");
            }
          } else if ("undefined" !== typeof c) throw new L("argument-error", bf + " property must be a non null object when specified.");
          this.f = null;
          if ((b = a[ff]) && "object" === typeof b) {
            if (b = b[gf], "string" === typeof b && b.length) this.f = b; else if ("undefined" !== typeof b) throw new L("argument-error", gf + " property must be a non empty string when specified.");
          } else if ("undefined" !== typeof b) throw new L("argument-error", ff + " property must be a non null object when specified.");
          a = a[hf];
          if ("undefined" !== typeof a && "boolean" !== typeof a) throw new L("argument-error", hf + " property must be a boolean when specified.");
          this.c = !!a;
        }
        var bf = "android", hf = "handleCodeInApp", ff = "iOS", af = "url", df = "installApp", ef = "minimumVersion", cf = "packageName", gf = "bundleId";
        function jf(a) {
          var b = {};
          b.continueUrl = a.h;
          b.canHandleCodeInApp = a.c;
          (b.androidPackageName = a.a) && (b.androidMinimumVersion = a.b, b.androidInstallApp = a.g);
          b.iOSBundleId = a.f;
          for (var c in b) null === b[c] && delete b[c];
          return b;
        }
        function kf(a) {
          return Ba(a, function(a) {
            a = a.toString(16);
            return 1 < a.length ? a : "0" + a;
          }).join("");
        }
        var lf = null, mf = null;
        function nf(a) {
          var b = "";
          of(a, function(a) {
            b += String.fromCharCode(a);
          });
          return b;
        }
        function of(a, b) {
          function c(b) {
            for (;d < a.length; ) {
              var c = a.charAt(d++), e = mf[c];
              if (null != e) return e;
              if (!/^[\s\xa0]*$/.test(c)) throw Error("Unknown base64 encoding at char: " + c);
            }
            return b;
          }
          pf();
          for (var d = 0; ;) {
            var e = c(-1), f = c(0), h = c(64), m = c(64);
            if (64 === m && -1 === e) break;
            b(e << 2 | f >> 4);
            64 != h && (b(f << 4 & 240 | h >> 2), 64 != m && b(h << 6 & 192 | m));
          }
        }
        function pf() {
          if (!lf) {
            lf = {};
            mf = {};
            for (var a = 0; 65 > a; a++) lf[a] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a), 
            mf[lf[a]] = a, 62 <= a && (mf["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)] = a);
          }
        }
        function qf(a) {
          this.c = a.sub;
          na();
          this.a = a.provider_id || a.firebase && a.firebase.sign_in_provider || null;
          this.b = !!a.is_anonymous || "anonymous" == this.a;
        }
        qf.prototype.f = function() {
          return this.b;
        };
        function rf(a) {
          return (a = sf(a)) && a.sub && a.iss && a.aud && a.exp ? new qf(a) : null;
        }
        function sf(a) {
          if (!a) return null;
          a = a.split(".");
          if (3 != a.length) return null;
          a = a[1];
          for (var b = (4 - a.length % 4) % 4, c = 0; c < b; c++) a += ".";
          try {
            return JSON.parse(nf(a));
          } catch (d) {}
          return null;
        }
        var tf = "oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "), uf = [ "client_id", "response_type", "scope", "redirect_uri", "state" ], vf = {
          Vc: {
            Ma: "locale",
            Ba: 500,
            Aa: 600,
            Na: "facebook.com",
            gb: uf
          },
          Xc: {
            Ma: null,
            Ba: 500,
            Aa: 620,
            Na: "github.com",
            gb: uf
          },
          Yc: {
            Ma: "hl",
            Ba: 515,
            Aa: 680,
            Na: "google.com",
            gb: uf
          },
          dd: {
            Ma: "lang",
            Ba: 485,
            Aa: 705,
            Na: "twitter.com",
            gb: tf
          }
        };
        function wf(a) {
          for (var b in vf) if (vf[b].Na == a) return vf[b];
          return null;
        }
        function xf(a) {
          var b = {};
          b["facebook.com"] = yf;
          b["google.com"] = zf;
          b["github.com"] = Af;
          b["twitter.com"] = Bf;
          var c = a && a[Cf];
          try {
            if (c) return b[c] ? new b[c](a) : new Df(a);
            if ("undefined" !== typeof a[Ef]) return new Ff(a);
          } catch (d) {}
          return null;
        }
        var Ef = "idToken", Cf = "providerId";
        function Ff(a) {
          var b = a[Cf];
          if (!b && a[Ef]) {
            var c = rf(a[Ef]);
            c && c.a && (b = c.a);
          }
          if (!b) throw Error("Invalid additional user info!");
          "anonymous" != b && "custom" != b || (b = null);
          c = !1;
          "undefined" !== typeof a.isNewUser ? c = !!a.isNewUser : "identitytoolkit#SignupNewUserResponse" === a.kind && (c = !0);
          J(this, "providerId", b);
          J(this, "isNewUser", c);
        }
        function Df(a) {
          Ff.call(this, a);
          a = ye(a.rawUserInfo || "{}");
          J(this, "profile", Ne(a || {}));
        }
        t(Df, Ff);
        function yf(a) {
          Df.call(this, a);
          if ("facebook.com" != this.providerId) throw Error("Invalid provider ID!");
        }
        t(yf, Df);
        function Af(a) {
          Df.call(this, a);
          if ("github.com" != this.providerId) throw Error("Invalid provider ID!");
          J(this, "username", this.profile && this.profile.login || null);
        }
        t(Af, Df);
        function zf(a) {
          Df.call(this, a);
          if ("google.com" != this.providerId) throw Error("Invalid provider ID!");
        }
        t(zf, Df);
        function Bf(a) {
          Df.call(this, a);
          if ("twitter.com" != this.providerId) throw Error("Invalid provider ID!");
          J(this, "username", a.screenName || null);
        }
        t(Bf, Df);
        function Gf(a) {
          this.a = dd(a);
        }
        function Hf(a) {
          var b = dd(a), c = cd(b, "link"), d = cd(dd(c), "link");
          b = cd(b, "deep_link_id");
          return cd(dd(b), "link") || b || d || c || a;
        }
        function If(a, b) {
          return a.then(function(a) {
            if (a[M]) {
              var c = rf(a[M]);
              if (!c || b != c.c) throw new L("user-mismatch");
              return a;
            }
            throw new L("user-mismatch");
          }).s(function(a) {
            throw a && a.code && a.code == Xe + "user-not-found" ? new L("user-mismatch") : a;
          });
        }
        function Jf(a, b, c) {
          if (b.idToken || b.accessToken) b.idToken && J(this, "idToken", b.idToken), b.accessToken && J(this, "accessToken", b.accessToken); else {
            if (!b.oauthToken || !b.oauthTokenSecret) throw new L("internal-error", "failed to construct a credential");
            J(this, "accessToken", b.oauthToken), J(this, "secret", b.oauthTokenSecret);
          }
          J(this, "providerId", a);
          J(this, "signInMethod", c);
        }
        Jf.prototype.ya = function(a) {
          return Kf(a, Lf(this));
        };
        Jf.prototype.c = function(a, b) {
          var c = Lf(this);
          c.idToken = b;
          return Mf(a, c);
        };
        Jf.prototype.f = function(a, b) {
          var c = Lf(this);
          return If(Nf(a, c), b);
        };
        function Lf(a) {
          var b = {};
          a.idToken && (b.id_token = a.idToken);
          a.accessToken && (b.access_token = a.accessToken);
          a.secret && (b.oauth_token_secret = a.secret);
          b.providerId = a.providerId;
          return {
            postBody: hd(b).toString(),
            requestUri: "http://localhost"
          };
        }
        Jf.prototype.D = function() {
          var a = {
            providerId: this.providerId,
            signInMethod: this.signInMethod
          };
          this.idToken && (a.oauthIdToken = this.idToken);
          this.accessToken && (a.oauthAccessToken = this.accessToken);
          this.secret && (a.oauthTokenSecret = this.secret);
          return a;
        };
        function Of(a, b) {
          this.Dc = b || [];
          K(this, {
            providerId: a,
            isOAuthProvider: !0
          });
          this.xb = {};
          this.bb = (wf(a) || {}).Ma || null;
          this.Za = null;
        }
        Of.prototype.Da = function(a) {
          this.xb = Za(a);
          return this;
        };
        function N(a) {
          Of.call(this, a, uf);
          this.a = [];
        }
        t(N, Of);
        N.prototype.ta = function(a) {
          Fa(this.a, a) || this.a.push(a);
          return this;
        };
        N.prototype.Db = function() {
          return Ia(this.a);
        };
        N.prototype.credential = function(a, b) {
          if (!a && !b) throw new L("argument-error", "credential failed: must provide the ID token and/or the access token.");
          return new Jf(this.providerId, {
            idToken: a || null,
            accessToken: b || null
          }, this.providerId);
        };
        function Pf() {
          N.call(this, "facebook.com");
        }
        t(Pf, N);
        J(Pf, "PROVIDER_ID", "facebook.com");
        J(Pf, "FACEBOOK_SIGN_IN_METHOD", "facebook.com");
        function Qf(a) {
          if (!a) throw new L("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
          var b = a;
          q(a) && (b = a.accessToken);
          return new Pf().credential(null, b);
        }
        function Rf() {
          N.call(this, "github.com");
        }
        t(Rf, N);
        J(Rf, "PROVIDER_ID", "github.com");
        J(Rf, "GITHUB_SIGN_IN_METHOD", "github.com");
        function Sf(a) {
          if (!a) throw new L("argument-error", "credential failed: expected 1 argument (the OAuth access token).");
          var b = a;
          q(a) && (b = a.accessToken);
          return new Rf().credential(null, b);
        }
        function Tf() {
          N.call(this, "google.com");
          this.ta("profile");
        }
        t(Tf, N);
        J(Tf, "PROVIDER_ID", "google.com");
        J(Tf, "GOOGLE_SIGN_IN_METHOD", "google.com");
        function Uf(a, b) {
          var c = a;
          q(a) && (c = a.idToken, b = a.accessToken);
          return new Tf().credential(c, b);
        }
        function Vf() {
          Of.call(this, "twitter.com", tf);
        }
        t(Vf, Of);
        J(Vf, "PROVIDER_ID", "twitter.com");
        J(Vf, "TWITTER_SIGN_IN_METHOD", "twitter.com");
        function Wf(a, b) {
          var c = a;
          q(c) || (c = {
            oauthToken: a,
            oauthTokenSecret: b
          });
          if (!c.oauthToken || !c.oauthTokenSecret) throw new L("argument-error", "credential failed: expected 2 arguments (the OAuth access token and secret).");
          return new Jf("twitter.com", c, "twitter.com");
        }
        function Xf(a, b, c) {
          this.a = a;
          this.b = b;
          J(this, "providerId", "password");
          J(this, "signInMethod", c === O.EMAIL_LINK_SIGN_IN_METHOD ? O.EMAIL_LINK_SIGN_IN_METHOD : O.EMAIL_PASSWORD_SIGN_IN_METHOD);
        }
        Xf.prototype.ya = function(a) {
          return this.signInMethod == O.EMAIL_LINK_SIGN_IN_METHOD ? P(a, Yf, {
            email: this.a,
            oobCode: this.b
          }) : P(a, Zf, {
            email: this.a,
            password: this.b
          });
        };
        Xf.prototype.c = function(a, b) {
          return this.signInMethod == O.EMAIL_LINK_SIGN_IN_METHOD ? P(a, $f, {
            idToken: b,
            email: this.a,
            oobCode: this.b
          }) : P(a, ag, {
            idToken: b,
            email: this.a,
            password: this.b
          });
        };
        Xf.prototype.f = function(a, b) {
          return If(this.ya(a), b);
        };
        Xf.prototype.D = function() {
          return {
            email: this.a,
            password: this.b,
            signInMethod: this.signInMethod
          };
        };
        function O() {
          K(this, {
            providerId: "password",
            isOAuthProvider: !1
          });
        }
        function bg(a, b) {
          b = cg(b);
          if (!b) throw new L("argument-error", "Invalid email link!");
          return new Xf(a, b, O.EMAIL_LINK_SIGN_IN_METHOD);
        }
        function cg(a) {
          a = Hf(a);
          a = new Gf(a);
          var b = cd(a.a, "oobCode") || null;
          return "signIn" === (cd(a.a, "mode") || null) && b ? b : null;
        }
        K(O, {
          PROVIDER_ID: "password"
        });
        K(O, {
          EMAIL_LINK_SIGN_IN_METHOD: "emailLink"
        });
        K(O, {
          EMAIL_PASSWORD_SIGN_IN_METHOD: "password"
        });
        function dg(a) {
          if (!(a.Sa && a.Ra || a.Fa && a.$)) throw new L("internal-error");
          this.a = a;
          J(this, "providerId", "phone");
          J(this, "signInMethod", "phone");
        }
        dg.prototype.ya = function(a) {
          return a.Ta(eg(this));
        };
        dg.prototype.c = function(a, b) {
          var c = eg(this);
          c.idToken = b;
          return P(a, fg, c);
        };
        dg.prototype.f = function(a, b) {
          var c = eg(this);
          c.operation = "REAUTH";
          a = P(a, gg, c);
          return If(a, b);
        };
        dg.prototype.D = function() {
          var a = {
            providerId: "phone"
          };
          this.a.Sa && (a.verificationId = this.a.Sa);
          this.a.Ra && (a.verificationCode = this.a.Ra);
          this.a.Fa && (a.temporaryProof = this.a.Fa);
          this.a.$ && (a.phoneNumber = this.a.$);
          return a;
        };
        function eg(a) {
          return a.a.Fa && a.a.$ ? {
            temporaryProof: a.a.Fa,
            phoneNumber: a.a.$
          } : {
            sessionInfo: a.a.Sa,
            code: a.a.Ra
          };
        }
        function hg(a) {
          try {
            this.a = a || firebase.auth();
          } catch (b) {
            throw new L("argument-error", "Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");
          }
          K(this, {
            providerId: "phone",
            isOAuthProvider: !1
          });
        }
        hg.prototype.Ta = function(a, b) {
          var c = this.a.b;
          return B(b.verify()).then(function(d) {
            if (!l(d)) throw new L("argument-error", "An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");
            switch (b.type) {
             case "recaptcha":
              return ig(c, {
                phoneNumber: a,
                recaptchaToken: d
              }).then(function(a) {
                "function" === typeof b.reset && b.reset();
                return a;
              }, function(a) {
                "function" === typeof b.reset && b.reset();
                throw a;
              });

             default:
              throw new L("argument-error", 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');
            }
          });
        };
        function jg(a, b) {
          if (!a) throw new L("missing-verification-id");
          if (!b) throw new L("missing-verification-code");
          return new dg({
            Sa: a,
            Ra: b
          });
        }
        K(hg, {
          PROVIDER_ID: "phone"
        });
        K(hg, {
          PHONE_SIGN_IN_METHOD: "phone"
        });
        function kg(a) {
          if (a.temporaryProof && a.phoneNumber) return new dg({
            Fa: a.temporaryProof,
            $: a.phoneNumber
          });
          var b = a && a.providerId;
          if (!b || "password" === b) return null;
          var c = a && a.oauthAccessToken, d = a && a.oauthTokenSecret;
          a = a && a.oauthIdToken;
          try {
            switch (b) {
             case "google.com":
              return Uf(a, c);

             case "facebook.com":
              return Qf(c);

             case "github.com":
              return Sf(c);

             case "twitter.com":
              return Wf(c, d);

             default:
              return new N(b).credential(a, c);
            }
          } catch (e) {
            return null;
          }
        }
        function lg(a) {
          if (!a.isOAuthProvider) throw new L("invalid-oauth-provider");
        }
        function mg(a, b, c, d, e) {
          this.b = a;
          this.c = b || null;
          this.f = c || null;
          this.g = d || null;
          this.a = e || null;
          if (!this.f && !this.a) throw new L("invalid-auth-event");
          if (this.f && this.a) throw new L("invalid-auth-event");
          if (this.f && !this.g) throw new L("invalid-auth-event");
        }
        mg.prototype.D = function() {
          return {
            type: this.b,
            eventId: this.c,
            urlResponse: this.f,
            sessionId: this.g,
            error: this.a && this.a.D()
          };
        };
        function ng(a) {
          a = a || {};
          return a.type ? new mg(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && Ze(a.error)) : null;
        }
        function og() {
          this.b = null;
          this.a = [];
        }
        var pg = null;
        og.prototype.subscribe = function(a) {
          var b = this;
          this.a.push(a);
          this.b || (this.b = function(a) {
            for (var c = 0; c < b.a.length; c++) b.a[c](a);
          }, a = I("universalLinks.subscribe", k), "function" === typeof a && a(null, this.b));
        };
        og.prototype.unsubscribe = function(a) {
          w(this.a, function(b) {
            return b == a;
          });
        };
        function qg(a) {
          var b = "unauthorized-domain", c = void 0, d = dd(a);
          a = d.b;
          d = d.c;
          "chrome-extension" == d ? c = Ja("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : "http" == d || "https" == d ? c = Ja("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.", a) : b = "operation-not-supported-in-this-environment";
          L.call(this, b, c);
        }
        t(qg, L);
        function rg(a, b, c) {
          L.call(this, a, c);
          a = b || {};
          a.yb && J(this, "email", a.yb);
          a.$ && J(this, "phoneNumber", a.$);
          a.credential && J(this, "credential", a.credential);
        }
        t(rg, L);
        rg.prototype.D = function() {
          var a = {
            code: this.code,
            message: this.message
          };
          this.email && (a.email = this.email);
          this.phoneNumber && (a.phoneNumber = this.phoneNumber);
          var b = this.credential && this.credential.D();
          b && ab(a, b);
          return a;
        };
        rg.prototype.toJSON = function() {
          return this.D();
        };
        function sg(a) {
          if (a.code) {
            var b = a.code || "";
            0 == b.indexOf(Xe) && (b = b.substring(Xe.length));
            var c = {
              credential: kg(a)
            };
            if (a.email) c.yb = a.email; else {
              if (!a.phoneNumber) return new L(b, a.message || void 0);
              c.$ = a.phoneNumber;
            }
            return new rg(b, c, a.message);
          }
          return null;
        }
        var tg = /^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;
        function ug() {}
        ug.prototype.c = null;
        function vg(a) {
          return a.c || (a.c = a.b());
        }
        var wg;
        function xg() {}
        t(xg, ug);
        xg.prototype.a = function() {
          var a = yg(this);
          return a ? new ActiveXObject(a) : new XMLHttpRequest();
        };
        xg.prototype.b = function() {
          var a = {};
          yg(this) && (a[0] = !0, a[1] = !0);
          return a;
        };
        function yg(a) {
          if (!a.f && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
            for (var b = [ "MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ], c = 0; c < b.length; c++) {
              var d = b[c];
              try {
                return new ActiveXObject(d), a.f = d;
              } catch (e) {}
            }
            throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
          }
          return a.f;
        }
        wg = new xg();
        function zg() {}
        t(zg, ug);
        zg.prototype.a = function() {
          var a = new XMLHttpRequest();
          if ("withCredentials" in a) return a;
          if ("undefined" != typeof XDomainRequest) return new Ag();
          throw Error("Unsupported browser");
        };
        zg.prototype.b = function() {
          return {};
        };
        function Ag() {
          this.a = new XDomainRequest();
          this.readyState = 0;
          this.onreadystatechange = null;
          this.responseText = "";
          this.status = -1;
          this.statusText = "";
          this.a.onload = r(this.ec, this);
          this.a.onerror = r(this.Eb, this);
          this.a.onprogress = r(this.fc, this);
          this.a.ontimeout = r(this.ic, this);
        }
        g = Ag.prototype;
        g.open = function(a, b, c) {
          if (null != c && !c) throw Error("Only async requests are supported.");
          this.a.open(a, b);
        };
        g.send = function(a) {
          if (a) {
            if ("string" != typeof a) throw Error("Only string data is supported");
            this.a.send(a);
          } else this.a.send();
        };
        g.abort = function() {
          this.a.abort();
        };
        g.setRequestHeader = function() {};
        g.getResponseHeader = function(a) {
          return "content-type" == a.toLowerCase() ? this.a.contentType : "";
        };
        g.ec = function() {
          this.status = 200;
          this.responseText = this.a.responseText;
          Bg(this, 4);
        };
        g.Eb = function() {
          this.status = 500;
          this.responseText = "";
          Bg(this, 4);
        };
        g.ic = function() {
          this.Eb();
        };
        g.fc = function() {
          this.status = 200;
          Bg(this, 1);
        };
        function Bg(a, b) {
          a.readyState = b;
          a.onreadystatechange && a.onreadystatechange();
        }
        g.getAllResponseHeaders = function() {
          return "content-type: " + this.a.contentType;
        };
        function Cg(a, b, c) {
          this.reset(a, b, c, void 0, void 0);
        }
        Cg.prototype.a = null;
        var Dg = 0;
        Cg.prototype.reset = function(a, b, c, d, e) {
          "number" == typeof e || Dg++;
          d || na();
          delete this.a;
        };
        function Eg(a) {
          this.f = a;
          this.b = this.c = this.a = null;
        }
        function Fg(a, b) {
          this.name = a;
          this.value = b;
        }
        Fg.prototype.toString = function() {
          return this.name;
        };
        var Gg = new Fg("SEVERE", 1e3), Hg = new Fg("WARNING", 900), Ig = new Fg("CONFIG", 700), Jg = new Fg("FINE", 500);
        function Kg(a) {
          if (a.c) return a.c;
          if (a.a) return Kg(a.a);
          ra("Root logger has no level set.");
          return null;
        }
        Eg.prototype.log = function(a, b, c) {
          if (a.value >= Kg(this).value) for (n(b) && (b = b()), a = new Cg(a, String(b), this.f), 
          c && (a.a = c), c = this; c; ) c = c.a;
        };
        var Lg = {}, Mg = null;
        function Ng(a) {
          Mg || (Mg = new Eg(""), Lg[""] = Mg, Mg.c = Ig);
          var b;
          if (!(b = Lg[a])) {
            b = new Eg(a);
            var c = a.lastIndexOf("."), d = a.substr(c + 1);
            c = Ng(a.substr(0, c));
            c.b || (c.b = {});
            c.b[d] = b;
            b.a = c;
            Lg[a] = b;
          }
          return b;
        }
        function Og(a, b) {
          a && a.log(Jg, b, void 0);
        }
        function Pg(a) {
          this.f = a;
        }
        t(Pg, ug);
        Pg.prototype.a = function() {
          return new Qg(this.f);
        };
        Pg.prototype.b = function(a) {
          return function() {
            return a;
          };
        }({});
        function Qg(a) {
          F.call(this);
          this.i = a;
          this.readyState = Rg;
          this.status = 0;
          this.responseText = this.statusText = "";
          this.onreadystatechange = null;
          this.g = new Headers();
          this.b = null;
          this.h = "GET";
          this.c = "";
          this.a = !1;
          this.f = Ng("goog.net.FetchXmlHttp");
        }
        t(Qg, F);
        var Rg = 0;
        g = Qg.prototype;
        g.open = function(a, b) {
          if (this.readyState != Rg) throw this.abort(), Error("Error reopening a connection");
          this.h = a;
          this.c = b;
          this.readyState = 1;
          Sg(this);
        };
        g.send = function(a) {
          if (1 != this.readyState) throw this.abort(), Error("need to call open() first. ");
          this.a = !0;
          var b = {
            headers: this.g,
            method: this.h,
            credentials: void 0,
            cache: void 0
          };
          a && (b.body = a);
          this.i.fetch(new Request(this.c, b)).then(this.hc.bind(this), this.Fb.bind(this));
        };
        g.abort = function() {
          this.responseText = "";
          this.g = new Headers();
          this.status = 0;
          1 <= this.readyState && this.a && 4 != this.readyState && (this.readyState = 4, 
          this.a = !1, Sg(this));
          this.readyState = Rg;
        };
        g.hc = function(a) {
          this.a && (this.b || (this.b = a.headers, this.readyState = 2, Sg(this)), this.a && (this.readyState = 3, 
          Sg(this), this.a && a.text().then(this.gc.bind(this, a), this.Fb.bind(this))));
        };
        g.gc = function(a, b) {
          this.a && (this.status = a.status, this.statusText = a.statusText, this.responseText = b, 
          this.readyState = 4, Sg(this));
        };
        g.Fb = function(a) {
          var b = this.f;
          b && b.log(Hg, "Failed to fetch url " + this.c, a instanceof Error ? a : Error(a));
          this.a && (this.readyState = 4, Sg(this));
        };
        g.setRequestHeader = function(a, b) {
          this.g.append(a, b);
        };
        g.getResponseHeader = function(a) {
          return this.b ? this.b.get(a.toLowerCase()) || "" : ((a = this.f) && a.log(Hg, "Attempting to get response header but no headers have been received for url: " + this.c, void 0), 
          "");
        };
        g.getAllResponseHeaders = function() {
          if (!this.b) {
            var a = this.f;
            a && a.log(Hg, "Attempting to get all response headers but no headers have been received for url: " + this.c, void 0);
            return "";
          }
          a = [];
          for (var b = this.b.entries(), c = b.next(); !c.done; ) c = c.value, a.push(c[0] + ": " + c[1]), 
          c = b.next();
          return a.join("\r\n");
        };
        function Sg(a) {
          a.onreadystatechange && a.onreadystatechange.call(a);
        }
        function Tg(a) {
          F.call(this);
          this.headers = new Kc();
          this.C = a || null;
          this.c = !1;
          this.w = this.a = null;
          this.h = this.N = this.l = "";
          this.f = this.I = this.i = this.G = !1;
          this.g = 0;
          this.u = null;
          this.o = Ug;
          this.v = this.O = !1;
        }
        t(Tg, F);
        var Ug = "";
        Tg.prototype.b = Ng("goog.net.XhrIo");
        var Vg = /^https?$/i, Wg = [ "POST", "PUT" ];
        function Xg(a, b, c, d, e) {
          if (a.a) throw Error("[goog.net.XhrIo] Object is active with another request=" + a.l + "; newUri=" + b);
          c = c ? c.toUpperCase() : "GET";
          a.l = b;
          a.h = "";
          a.N = c;
          a.G = !1;
          a.c = !0;
          a.a = a.C ? a.C.a() : wg.a();
          a.w = a.C ? vg(a.C) : vg(wg);
          a.a.onreadystatechange = r(a.Ib, a);
          try {
            Og(a.b, Yg(a, "Opening Xhr")), a.I = !0, a.a.open(c, String(b), !0), a.I = !1;
          } catch (h) {
            Og(a.b, Yg(a, "Error opening Xhr: " + h.message));
            Zg(a, h);
            return;
          }
          b = d || "";
          var f = new Kc(a.headers);
          e && Jc(e, function(a, b) {
            f.set(b, a);
          });
          e = Da(f.U());
          d = k.FormData && b instanceof k.FormData;
          !Fa(Wg, c) || e || d || f.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
          f.forEach(function(a, b) {
            this.a.setRequestHeader(b, a);
          }, a);
          a.o && (a.a.responseType = a.o);
          "withCredentials" in a.a && a.a.withCredentials !== a.O && (a.a.withCredentials = a.O);
          try {
            $g(a), 0 < a.g && (a.v = ah(a.a), Og(a.b, Yg(a, "Will abort after " + a.g + "ms if incomplete, xhr2 " + a.v)), 
            a.v ? (a.a.timeout = a.g, a.a.ontimeout = r(a.Ga, a)) : a.u = Fc(a.Ga, a.g, a)), 
            Og(a.b, Yg(a, "Sending request")), a.i = !0, a.a.send(b), a.i = !1;
          } catch (h) {
            Og(a.b, Yg(a, "Send error: " + h.message)), Zg(a, h);
          }
        }
        function ah(a) {
          return Nb && Xb(9) && "number" == typeof a.timeout && void 0 !== a.ontimeout;
        }
        function Ea(a) {
          return "content-type" == a.toLowerCase();
        }
        g = Tg.prototype;
        g.Ga = function() {
          "undefined" != typeof aa && this.a && (this.h = "Timed out after " + this.g + "ms, aborting", 
          Og(this.b, Yg(this, this.h)), this.dispatchEvent("timeout"), this.abort(8));
        };
        function Zg(a, b) {
          a.c = !1;
          a.a && (a.f = !0, a.a.abort(), a.f = !1);
          a.h = b;
          bh(a);
          ch(a);
        }
        function bh(a) {
          a.G || (a.G = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"));
        }
        g.abort = function() {
          this.a && this.c && (Og(this.b, Yg(this, "Aborting")), this.c = !1, this.f = !0, 
          this.a.abort(), this.f = !1, this.dispatchEvent("complete"), this.dispatchEvent("abort"), 
          ch(this));
        };
        g.ua = function() {
          this.a && (this.c && (this.c = !1, this.f = !0, this.a.abort(), this.f = !1), ch(this, !0));
          Tg.nb.ua.call(this);
        };
        g.Ib = function() {
          this.pa || (this.I || this.i || this.f ? dh(this) : this.wc());
        };
        g.wc = function() {
          dh(this);
        };
        function dh(a) {
          if (a.c && "undefined" != typeof aa) if (a.w[1] && 4 == eh(a) && 2 == fh(a)) Og(a.b, Yg(a, "Local request error detected and ignored")); else if (a.i && 4 == eh(a)) Fc(a.Ib, 0, a); else if (a.dispatchEvent("readystatechange"), 
          4 == eh(a)) {
            Og(a.b, Yg(a, "Request complete"));
            a.c = !1;
            try {
              var b = fh(a);
              a: switch (b) {
               case 200:
               case 201:
               case 202:
               case 204:
               case 206:
               case 304:
               case 1223:
                var c = !0;
                break a;

               default:
                c = !1;
              }
              var d;
              if (!(d = c)) {
                var e;
                if (e = 0 === b) {
                  var f = String(a.l).match(Nc)[1] || null;
                  if (!f && k.self && k.self.location) {
                    var h = k.self.location.protocol;
                    f = h.substr(0, h.length - 1);
                  }
                  e = !Vg.test(f ? f.toLowerCase() : "");
                }
                d = e;
              }
              if (d) a.dispatchEvent("complete"), a.dispatchEvent("success"); else {
                try {
                  var m = 2 < eh(a) ? a.a.statusText : "";
                } catch (p) {
                  Og(a.b, "Can not get status: " + p.message), m = "";
                }
                a.h = m + " [" + fh(a) + "]";
                bh(a);
              }
            } finally {
              ch(a);
            }
          }
        }
        function ch(a, b) {
          if (a.a) {
            $g(a);
            var c = a.a, d = a.w[0] ? ca : null;
            a.a = null;
            a.w = null;
            b || a.dispatchEvent("ready");
            try {
              c.onreadystatechange = d;
            } catch (e) {
              (a = a.b) && a.log(Gg, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
            }
          }
        }
        function $g(a) {
          a.a && a.v && (a.a.ontimeout = null);
          a.u && (k.clearTimeout(a.u), a.u = null);
        }
        function eh(a) {
          return a.a ? a.a.readyState : 0;
        }
        function fh(a) {
          try {
            return 2 < eh(a) ? a.a.status : -1;
          } catch (b) {
            return -1;
          }
        }
        function gh(a) {
          try {
            return a.a ? a.a.responseText : "";
          } catch (b) {
            return Og(a.b, "Can not get responseText: " + b.message), "";
          }
        }
        g.getResponse = function() {
          try {
            if (!this.a) return null;
            if ("response" in this.a) return this.a.response;
            switch (this.o) {
             case Ug:
             case "text":
              return this.a.responseText;

             case "arraybuffer":
              if ("mozResponseArrayBuffer" in this.a) return this.a.mozResponseArrayBuffer;
            }
            var a = this.b;
            a && a.log(Gg, "Response type " + this.o + " is not supported on this browser", void 0);
            return null;
          } catch (b) {
            return Og(this.b, "Can not get response: " + b.message), null;
          }
        };
        function Yg(a, b) {
          return b + " [" + a.N + " " + a.l + " " + fh(a) + "]";
        }
        function hh(a, b) {
          this.g = [];
          this.v = a;
          this.u = b || null;
          this.f = this.a = !1;
          this.c = void 0;
          this.l = this.w = this.i = !1;
          this.h = 0;
          this.b = null;
          this.m = 0;
        }
        hh.prototype.cancel = function(a) {
          if (this.a) this.c instanceof hh && this.c.cancel(); else {
            if (this.b) {
              var b = this.b;
              delete this.b;
              a ? b.cancel(a) : (b.m--, 0 >= b.m && b.cancel());
            }
            this.v ? this.v.call(this.u, this) : this.l = !0;
            this.a || (a = new ih(this), jh(this), kh(this, !1, a));
          }
        };
        hh.prototype.o = function(a, b) {
          this.i = !1;
          kh(this, a, b);
        };
        function kh(a, b, c) {
          a.a = !0;
          a.c = c;
          a.f = !b;
          lh(a);
        }
        function jh(a) {
          if (a.a) {
            if (!a.l) throw new mh(a);
            a.l = !1;
          }
        }
        hh.prototype.C = function() {
          jh(this);
          kh(this, !0, null);
        };
        function nh(a, b) {
          oh(a, null, b, void 0);
        }
        function oh(a, b, c, d) {
          a.g.push([ b, c, d ]);
          a.a && lh(a);
        }
        hh.prototype.then = function(a, b, c) {
          var d, e, f = new A(function(a, b) {
            d = a;
            e = b;
          });
          oh(this, d, function(a) {
            a instanceof ih ? f.cancel() : e(a);
          });
          return f.then(a, b, c);
        };
        oa(hh);
        function ph(a) {
          return Ca(a.g, function(a) {
            return n(a[1]);
          });
        }
        function lh(a) {
          if (a.h && a.a && ph(a)) {
            var b = a.h, c = qh[b];
            c && (k.clearTimeout(c.a), delete qh[b]);
            a.h = 0;
          }
          a.b && (a.b.m--, delete a.b);
          b = a.c;
          for (var d = c = !1; a.g.length && !a.i; ) {
            var e = a.g.shift(), f = e[0], h = e[1];
            e = e[2];
            if (f = a.f ? h : f) try {
              var m = f.call(e || a.u, b);
              void 0 !== m && (a.f = a.f && (m == b || m instanceof Error), a.c = b = m);
              (pa(b) || "function" === typeof k.Promise && b instanceof k.Promise) && (d = !0, 
              a.i = !0);
            } catch (p) {
              b = p, a.f = !0, ph(a) || (c = !0);
            }
          }
          a.c = b;
          d && (m = r(a.o, a, !0), d = r(a.o, a, !1), b instanceof hh ? (oh(b, m, d), b.w = !0) : b.then(m, d));
          c && (b = new rh(b), qh[b.a] = b, a.h = b.a);
        }
        function mh() {
          u.call(this);
        }
        t(mh, u);
        mh.prototype.message = "Deferred has already fired";
        mh.prototype.name = "AlreadyCalledError";
        function ih() {
          u.call(this);
        }
        t(ih, u);
        ih.prototype.message = "Deferred was canceled";
        ih.prototype.name = "CanceledError";
        function rh(a) {
          this.a = k.setTimeout(r(this.c, this), 0);
          this.b = a;
        }
        rh.prototype.c = function() {
          delete qh[this.a];
          throw this.b;
        };
        var qh = {};
        function sh(a) {
          var b = {}, c = b.document || document, d = td(a), e = document.createElement("SCRIPT"), f = {
            Kb: e,
            Ga: void 0
          }, h = new hh(th, f), m = null, p = null != b.timeout ? b.timeout : 5e3;
          0 < p && (m = window.setTimeout(function() {
            uh(e, !0);
            var a = new vh(wh, "Timeout reached for loading script " + d);
            jh(h);
            kh(h, !1, a);
          }, p), f.Ga = m);
          e.onload = e.onreadystatechange = function() {
            e.readyState && "loaded" != e.readyState && "complete" != e.readyState || (uh(e, b.fd || !1, m), 
            h.C());
          };
          e.onerror = function() {
            uh(e, !0, m);
            var a = new vh(xh, "Error while loading script " + d);
            jh(h);
            kh(h, !1, a);
          };
          f = b.attributes || {};
          ab(f, {
            type: "text/javascript",
            charset: "UTF-8"
          });
          Jd(e, f);
          e.src = td(a);
          yh(c).appendChild(e);
          return h;
        }
        function yh(a) {
          var b;
          return (b = (a || document).getElementsByTagName("HEAD")) && 0 != b.length ? b[0] : a.documentElement;
        }
        function th() {
          if (this && this.Kb) {
            var a = this.Kb;
            a && "SCRIPT" == a.tagName && uh(a, !0, this.Ga);
          }
        }
        function uh(a, b, c) {
          null != c && k.clearTimeout(c);
          a.onload = ca;
          a.onerror = ca;
          a.onreadystatechange = ca;
          b && window.setTimeout(function() {
            a && a.parentNode && a.parentNode.removeChild(a);
          }, 0);
        }
        var xh = 0, wh = 1;
        function vh(a, b) {
          var c = "Jsloader error (code #" + a + ")";
          b && (c += ": " + b);
          u.call(this, c);
          this.code = a;
        }
        t(vh, u);
        function zh(a) {
          this.f = a;
        }
        t(zh, ug);
        zh.prototype.a = function() {
          return new this.f();
        };
        zh.prototype.b = function() {
          return {};
        };
        function Ah(a, b, c) {
          this.b = a;
          a = b || {};
          this.i = a.secureTokenEndpoint || "https://securetoken.googleapis.com/v1/token";
          this.m = a.secureTokenTimeout || Bh;
          this.f = Za(a.secureTokenHeaders || Ch);
          this.g = a.firebaseEndpoint || "https://www.googleapis.com/identitytoolkit/v3/relyingparty/";
          this.h = a.firebaseTimeout || Dh;
          this.a = Za(a.firebaseHeaders || Eh);
          c && (this.a["X-Client-Version"] = c, this.f["X-Client-Version"] = c);
          c = "Node" == me();
          c = k.XMLHttpRequest || c && firebase.INTERNAL.node && firebase.INTERNAL.node.XMLHttpRequest;
          if (!c && !le()) throw new L("internal-error", "The XMLHttpRequest compatibility library was not found.");
          this.c = void 0;
          le() ? this.c = new Pg(self) : ne() ? this.c = new zh(c) : this.c = new zg();
        }
        var Fh, M = "idToken", Bh = new Be(3e4, 6e4), Ch = {
          "Content-Type": "application/x-www-form-urlencoded"
        }, Dh = new Be(3e4, 6e4), Eh = {
          "Content-Type": "application/json"
        };
        function Gh(a, b) {
          b ? a.a["X-Firebase-Locale"] = b : delete a.a["X-Firebase-Locale"];
        }
        function Hh(a, b) {
          b ? (a.a["X-Client-Version"] = b, a.f["X-Client-Version"] = b) : (delete a.a["X-Client-Version"], 
          delete a.f["X-Client-Version"]);
        }
        function Ih(a, b, c, d, e, f, h) {
          Yd() || le() ? a = r(a.o, a) : (Fh || (Fh = new A(function(a, b) {
            Jh(a, b);
          })), a = r(a.l, a));
          a(b, c, d, e, f, h);
        }
        Ah.prototype.o = function(a, b, c, d, e, f) {
          if (le() && ("undefined" === typeof k.fetch || "undefined" === typeof k.Headers || "undefined" === typeof k.Request)) throw new L("operation-not-supported-in-this-environment", "fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.");
          var h = new Tg(this.c);
          if (f) {
            h.g = Math.max(0, f);
            var m = setTimeout(function() {
              h.dispatchEvent("timeout");
            }, f);
          }
          tc(h, "complete", function() {
            m && clearTimeout(m);
            var a = null;
            try {
              a = JSON.parse(gh(this)) || null;
            } catch (z) {
              a = null;
            }
            b && b(a);
          });
          zc(h, "ready", function() {
            m && clearTimeout(m);
            Ib(this);
          });
          zc(h, "timeout", function() {
            m && clearTimeout(m);
            Ib(this);
            b && b(null);
          });
          Xg(h, a, c, d, e);
        };
        var Kh = qd("https://apis.google.com/js/client.js?onload=%{onload}"), Lh = "__fcb" + Math.floor(1e6 * Math.random()).toString();
        function Jh(a, b) {
          if (((window.gapi || {}).client || {}).request) a(); else {
            k[Lh] = function() {
              ((window.gapi || {}).client || {}).request ? a() : b(Error("CORS_UNSUPPORTED"));
            };
            var c = ud(Kh, {
              onload: Lh
            });
            nh(sh(c), function() {
              b(Error("CORS_UNSUPPORTED"));
            });
          }
        }
        Ah.prototype.l = function(a, b, c, d, e) {
          var f = this;
          Fh.then(function() {
            window.gapi.client.setApiKey(f.b);
            var h = window.gapi.auth.getToken();
            window.gapi.auth.setToken(null);
            window.gapi.client.request({
              path: a,
              method: c,
              body: d,
              headers: e,
              authType: "none",
              callback: function(a) {
                window.gapi.auth.setToken(h);
                b && b(a);
              }
            });
          }).s(function(a) {
            b && b({
              error: {
                message: a && a.message || "CORS_UNSUPPORTED"
              }
            });
          });
        };
        function Mh(a, b) {
          return new A(function(c, d) {
            "refresh_token" == b.grant_type && b.refresh_token || "authorization_code" == b.grant_type && b.code ? Ih(a, a.i + "?key=" + encodeURIComponent(a.b), function(a) {
              a ? a.error ? d(Nh(a)) : a.access_token && a.refresh_token ? c(a) : d(new L("internal-error")) : d(new L("network-request-failed"));
            }, "POST", hd(b).toString(), a.f, a.m.get()) : d(new L("internal-error"));
          });
        }
        function Oh(a, b, c, d, e, f) {
          var h = dd(a.g + b);
          G(h, "key", a.b);
          f && G(h, "cb", na().toString());
          var m = "GET" == c;
          if (m) for (var p in d) d.hasOwnProperty(p) && G(h, p, d[p]);
          return new A(function(b, f) {
            Ih(a, h.toString(), function(a) {
              a ? a.error ? f(Nh(a, e || {})) : b(a) : f(new L("network-request-failed"));
            }, c, m ? void 0 : Od(xe(d)), a.a, a.h.get());
          });
        }
        function Ph(a) {
          if (!tg.test(a.email)) throw new L("invalid-email");
        }
        function Qh(a) {
          "email" in a && Ph(a);
        }
        function Rh(a, b) {
          return P(a, Sh, {
            identifier: b,
            continueUri: ue() ? Vd() : "http://localhost"
          }).then(function(a) {
            return a.allProviders || [];
          });
        }
        function Th(a, b) {
          return P(a, Sh, {
            identifier: b,
            continueUri: ue() ? Vd() : "http://localhost"
          }).then(function(a) {
            return a.signinMethods || [];
          });
        }
        function Uh(a) {
          return P(a, Vh, {}).then(function(a) {
            return a.authorizedDomains || [];
          });
        }
        function Wh(a) {
          if (!a[M]) throw new L("internal-error");
        }
        function Xh(a) {
          if (a.phoneNumber || a.temporaryProof) {
            if (!a.phoneNumber || !a.temporaryProof) throw new L("internal-error");
          } else {
            if (!a.sessionInfo) throw new L("missing-verification-id");
            if (!a.code) throw new L("missing-verification-code");
          }
        }
        Ah.prototype.Pa = function() {
          return P(this, Yh, {});
        };
        Ah.prototype.ob = function(a, b) {
          return P(this, Zh, {
            idToken: a,
            email: b
          });
        };
        Ah.prototype.pb = function(a, b) {
          return P(this, ag, {
            idToken: a,
            password: b
          });
        };
        var $h = {
          displayName: "DISPLAY_NAME",
          photoUrl: "PHOTO_URL"
        };
        g = Ah.prototype;
        g.qb = function(a, b) {
          var c = {
            idToken: a
          }, d = [];
          Xa($h, function(a, f) {
            var e = b[f];
            null === e ? d.push(a) : f in b && (c[f] = e);
          });
          d.length && (c.deleteAttribute = d);
          return P(this, Zh, c);
        };
        g.jb = function(a, b) {
          a = {
            requestType: "PASSWORD_RESET",
            email: a
          };
          ab(a, b);
          return P(this, ai, a);
        };
        g.kb = function(a, b) {
          a = {
            requestType: "EMAIL_SIGNIN",
            email: a
          };
          ab(a, b);
          return P(this, bi, a);
        };
        g.ib = function(a, b) {
          a = {
            requestType: "VERIFY_EMAIL",
            idToken: a
          };
          ab(a, b);
          return P(this, ci, a);
        };
        function ig(a, b) {
          return P(a, di, b);
        }
        g.Ta = function(a) {
          return P(this, ei, a);
        };
        function fi(a, b, c) {
          return P(a, gi, {
            idToken: b,
            deleteProvider: c
          });
        }
        function hi(a) {
          if (!a.requestUri || !a.sessionId && !a.postBody) throw new L("internal-error");
        }
        function ii(a) {
          var b = null;
          a.needConfirmation ? (a.code = "account-exists-with-different-credential", b = sg(a)) : "FEDERATED_USER_ID_ALREADY_LINKED" == a.errorMessage ? (a.code = "credential-already-in-use", 
          b = sg(a)) : "EMAIL_EXISTS" == a.errorMessage ? (a.code = "email-already-in-use", 
          b = sg(a)) : a.errorMessage && (b = ji(a.errorMessage));
          if (b) throw b;
          if (!a[M]) throw new L("internal-error");
        }
        function Kf(a, b) {
          b.returnIdpCredential = !0;
          return P(a, ki, b);
        }
        function Mf(a, b) {
          b.returnIdpCredential = !0;
          return P(a, li, b);
        }
        function Nf(a, b) {
          b.returnIdpCredential = !0;
          b.autoCreate = !1;
          return P(a, mi, b);
        }
        function ni(a) {
          if (!a.oobCode) throw new L("invalid-action-code");
        }
        g.Ya = function(a, b) {
          return P(this, oi, {
            oobCode: a,
            newPassword: b
          });
        };
        g.Ja = function(a) {
          return P(this, pi, {
            oobCode: a
          });
        };
        g.Va = function(a) {
          return P(this, qi, {
            oobCode: a
          });
        };
        var qi = {
          endpoint: "setAccountInfo",
          B: ni,
          da: "email"
        }, pi = {
          endpoint: "resetPassword",
          B: ni,
          J: function(a) {
            var b = a.requestType;
            if (!b || !a.email && "EMAIL_SIGNIN" != b) throw new L("internal-error");
          }
        }, ri = {
          endpoint: "signupNewUser",
          B: function(a) {
            Ph(a);
            if (!a.password) throw new L("weak-password");
          },
          J: Wh,
          R: !0
        }, Sh = {
          endpoint: "createAuthUri"
        }, si = {
          endpoint: "deleteAccount",
          T: [ "idToken" ]
        }, gi = {
          endpoint: "setAccountInfo",
          T: [ "idToken", "deleteProvider" ],
          B: function(a) {
            if (!fa(a.deleteProvider)) throw new L("internal-error");
          }
        }, Yf = {
          endpoint: "emailLinkSignin",
          T: [ "email", "oobCode" ],
          B: Ph,
          J: Wh,
          R: !0
        }, $f = {
          endpoint: "emailLinkSignin",
          T: [ "idToken", "email", "oobCode" ],
          B: Ph,
          J: Wh,
          R: !0
        }, ti = {
          endpoint: "getAccountInfo"
        }, bi = {
          endpoint: "getOobConfirmationCode",
          T: [ "requestType" ],
          B: function(a) {
            if ("EMAIL_SIGNIN" != a.requestType) throw new L("internal-error");
            Ph(a);
          },
          da: "email"
        }, ci = {
          endpoint: "getOobConfirmationCode",
          T: [ "idToken", "requestType" ],
          B: function(a) {
            if ("VERIFY_EMAIL" != a.requestType) throw new L("internal-error");
          },
          da: "email"
        }, ai = {
          endpoint: "getOobConfirmationCode",
          T: [ "requestType" ],
          B: function(a) {
            if ("PASSWORD_RESET" != a.requestType) throw new L("internal-error");
            Ph(a);
          },
          da: "email"
        }, Vh = {
          tb: !0,
          endpoint: "getProjectConfig",
          Hb: "GET"
        }, ui = {
          tb: !0,
          endpoint: "getRecaptchaParam",
          Hb: "GET",
          J: function(a) {
            if (!a.recaptchaSiteKey) throw new L("internal-error");
          }
        }, oi = {
          endpoint: "resetPassword",
          B: ni,
          da: "email"
        }, di = {
          endpoint: "sendVerificationCode",
          T: [ "phoneNumber", "recaptchaToken" ],
          da: "sessionInfo"
        }, Zh = {
          endpoint: "setAccountInfo",
          T: [ "idToken" ],
          B: Qh,
          R: !0
        }, ag = {
          endpoint: "setAccountInfo",
          T: [ "idToken" ],
          B: function(a) {
            Qh(a);
            if (!a.password) throw new L("weak-password");
          },
          J: Wh,
          R: !0
        }, Yh = {
          endpoint: "signupNewUser",
          J: Wh,
          R: !0
        }, ki = {
          endpoint: "verifyAssertion",
          B: hi,
          J: ii,
          R: !0
        }, mi = {
          endpoint: "verifyAssertion",
          B: hi,
          J: function(a) {
            if (a.errorMessage && "USER_NOT_FOUND" == a.errorMessage) throw new L("user-not-found");
            if (a.errorMessage) throw ji(a.errorMessage);
            if (!a[M]) throw new L("internal-error");
          },
          R: !0
        }, li = {
          endpoint: "verifyAssertion",
          B: function(a) {
            hi(a);
            if (!a.idToken) throw new L("internal-error");
          },
          J: ii,
          R: !0
        }, vi = {
          endpoint: "verifyCustomToken",
          B: function(a) {
            if (!a.token) throw new L("invalid-custom-token");
          },
          J: Wh,
          R: !0
        }, Zf = {
          endpoint: "verifyPassword",
          B: function(a) {
            Ph(a);
            if (!a.password) throw new L("wrong-password");
          },
          J: Wh,
          R: !0
        }, ei = {
          endpoint: "verifyPhoneNumber",
          B: Xh,
          J: Wh
        }, fg = {
          endpoint: "verifyPhoneNumber",
          B: function(a) {
            if (!a.idToken) throw new L("internal-error");
            Xh(a);
          },
          J: function(a) {
            if (a.temporaryProof) throw a.code = "credential-already-in-use", sg(a);
            Wh(a);
          }
        }, gg = {
          Xb: {
            USER_NOT_FOUND: "user-not-found"
          },
          endpoint: "verifyPhoneNumber",
          B: Xh,
          J: Wh
        };
        function P(a, b, c) {
          if (!Me(c, b.T)) return C(new L("internal-error"));
          var d = b.Hb || "POST", e;
          return B(c).then(b.B).then(function() {
            b.R && (c.returnSecureToken = !0);
            return Oh(a, b.endpoint, d, c, b.Xb, b.tb || !1);
          }).then(function(a) {
            return e = a;
          }).then(b.J).then(function() {
            if (!b.da) return e;
            if (!(b.da in e)) throw new L("internal-error");
            return e[b.da];
          });
        }
        function ji(a) {
          return Nh({
            error: {
              errors: [ {
                message: a
              } ],
              code: 400,
              message: a
            }
          });
        }
        function Nh(a, b) {
          var c = (a.error && a.error.errors && a.error.errors[0] || {}).reason || "";
          var d = {
            keyInvalid: "invalid-api-key",
            ipRefererBlocked: "app-not-authorized"
          };
          if (c = d[c] ? new L(d[c]) : null) return c;
          c = a.error && a.error.message || "";
          d = {
            INVALID_CUSTOM_TOKEN: "invalid-custom-token",
            CREDENTIAL_MISMATCH: "custom-token-mismatch",
            MISSING_CUSTOM_TOKEN: "internal-error",
            INVALID_IDENTIFIER: "invalid-email",
            MISSING_CONTINUE_URI: "internal-error",
            INVALID_EMAIL: "invalid-email",
            INVALID_PASSWORD: "wrong-password",
            USER_DISABLED: "user-disabled",
            MISSING_PASSWORD: "internal-error",
            EMAIL_EXISTS: "email-already-in-use",
            PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
            INVALID_IDP_RESPONSE: "invalid-credential",
            FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
            INVALID_MESSAGE_PAYLOAD: "invalid-message-payload",
            INVALID_RECIPIENT_EMAIL: "invalid-recipient-email",
            INVALID_SENDER: "invalid-sender",
            EMAIL_NOT_FOUND: "user-not-found",
            RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
            EXPIRED_OOB_CODE: "expired-action-code",
            INVALID_OOB_CODE: "invalid-action-code",
            MISSING_OOB_CODE: "internal-error",
            INVALID_PROVIDER_ID: "invalid-provider-id",
            CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
            INVALID_ID_TOKEN: "invalid-user-token",
            TOKEN_EXPIRED: "user-token-expired",
            USER_NOT_FOUND: "user-token-expired",
            CORS_UNSUPPORTED: "cors-unsupported",
            DYNAMIC_LINK_NOT_ACTIVATED: "dynamic-link-not-activated",
            INVALID_APP_ID: "invalid-app-id",
            TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
            WEAK_PASSWORD: "weak-password",
            OPERATION_NOT_ALLOWED: "operation-not-allowed",
            USER_CANCELLED: "user-cancelled",
            CAPTCHA_CHECK_FAILED: "captcha-check-failed",
            INVALID_APP_CREDENTIAL: "invalid-app-credential",
            INVALID_CODE: "invalid-verification-code",
            INVALID_PHONE_NUMBER: "invalid-phone-number",
            INVALID_SESSION_INFO: "invalid-verification-id",
            INVALID_TEMPORARY_PROOF: "invalid-credential",
            MISSING_APP_CREDENTIAL: "missing-app-credential",
            MISSING_CODE: "missing-verification-code",
            MISSING_PHONE_NUMBER: "missing-phone-number",
            MISSING_SESSION_INFO: "missing-verification-id",
            QUOTA_EXCEEDED: "quota-exceeded",
            SESSION_EXPIRED: "code-expired",
            INVALID_CONTINUE_URI: "invalid-continue-uri",
            MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
            MISSING_IOS_BUNDLE_ID: "missing-ios-bundle-id",
            UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
            INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
            INVALID_CERT_HASH: "invalid-cert-hash"
          };
          ab(d, b || {});
          b = (b = c.match(/^[^\s]+\s*:\s*(.*)$/)) && 1 < b.length ? b[1] : void 0;
          for (var e in d) if (0 === c.indexOf(e)) return new L(d[e], b);
          !b && a && (b = we(a));
          return new L("internal-error", b);
        }
        var wi = {
          $c: {
            $a: "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
            hb: "https://securetoken.googleapis.com/v1/token",
            id: "p"
          },
          bd: {
            $a: "https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",
            hb: "https://staging-securetoken.sandbox.googleapis.com/v1/token",
            id: "s"
          },
          cd: {
            $a: "https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/",
            hb: "https://test-securetoken.sandbox.googleapis.com/v1/token",
            id: "t"
          }
        };
        function xi(a) {
          for (var b in wi) if (wi[b].id === a) return a = wi[b], {
            firebaseEndpoint: a.$a,
            secureTokenEndpoint: a.hb
          };
          return null;
        }
        var yi;
        yi = xi("__EID__") ? "__EID__" : void 0;
        function zi(a) {
          this.b = a;
          this.a = null;
          this.eb = Ai(this);
        }
        function Ai(a) {
          return Bi().then(function() {
            return new A(function(b, c) {
              I("gapi.iframes.getContext")().open({
                where: document.body,
                url: a.b,
                messageHandlersFilter: I("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"),
                attributes: {
                  style: {
                    position: "absolute",
                    top: "-100px",
                    width: "1px",
                    height: "1px"
                  }
                },
                dontclear: !0
              }, function(d) {
                function e() {
                  clearTimeout(f);
                  b();
                }
                a.a = d;
                a.a.restyle({
                  setHideOnLeave: !1
                });
                var f = setTimeout(function() {
                  c(Error("Network Error"));
                }, Ci.get());
                d.ping(e).then(e, function() {
                  c(Error("Network Error"));
                });
              });
            });
          });
        }
        function Di(a, b) {
          return a.eb.then(function() {
            return new A(function(c) {
              a.a.send(b.type, b, c, I("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
            });
          });
        }
        function Ei(a, b) {
          a.eb.then(function() {
            a.a.register("authEvent", b, I("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"));
          });
        }
        var Fi = qd("https://apis.google.com/js/api.js?onload=%{onload}"), Gi = new Be(3e4, 6e4), Ci = new Be(5e3, 15e3), Hi = null;
        function Bi() {
          return Hi || (Hi = new A(function(a, b) {
            function c() {
              Ae();
              I("gapi.load")("gapi.iframes", {
                callback: a,
                ontimeout: function() {
                  Ae();
                  b(Error("Network Error"));
                },
                timeout: Gi.get()
              });
            }
            if (I("gapi.iframes.Iframe")) a(); else if (I("gapi.load")) c(); else {
              var d = "__iframefcb" + Math.floor(1e6 * Math.random()).toString();
              k[d] = function() {
                I("gapi.load") ? c() : b(Error("Network Error"));
              };
              d = ud(Fi, {
                onload: d
              });
              B(sh(d)).s(function() {
                b(Error("Network Error"));
              });
            }
          }).s(function(a) {
            Hi = null;
            throw a;
          }));
        }
        function Ii(a, b, c) {
          this.i = a;
          this.g = b;
          this.h = c;
          this.f = null;
          this.a = ed(this.i, "/__/auth/iframe");
          G(this.a, "apiKey", this.g);
          G(this.a, "appName", this.h);
          this.b = null;
          this.c = [];
        }
        Ii.prototype.toString = function() {
          this.f ? G(this.a, "v", this.f) : kd(this.a.a, "v");
          this.b ? G(this.a, "eid", this.b) : kd(this.a.a, "eid");
          this.c.length ? G(this.a, "fw", this.c.join(",")) : kd(this.a.a, "fw");
          return this.a.toString();
        };
        function Ji(a, b, c, d, e) {
          this.o = a;
          this.l = b;
          this.c = c;
          this.m = d;
          this.h = this.g = this.i = null;
          this.a = e;
          this.f = null;
        }
        Ji.prototype.toString = function() {
          var a = ed(this.o, "/__/auth/handler");
          G(a, "apiKey", this.l);
          G(a, "appName", this.c);
          G(a, "authType", this.m);
          if (this.a.isOAuthProvider) {
            var b = this.a;
            try {
              var c = firebase.app(this.c).auth().ea();
            } catch (m) {
              c = null;
            }
            b.Za = c;
            G(a, "providerId", this.a.providerId);
            b = this.a;
            c = xe(b.xb);
            for (var d in c) c[d] = c[d].toString();
            d = b.Dc;
            c = Za(c);
            for (var e = 0; e < d.length; e++) {
              var f = d[e];
              f in c && delete c[f];
            }
            b.bb && b.Za && !c[b.bb] && (c[b.bb] = b.Za);
            Ya(c) || G(a, "customParameters", we(c));
          }
          "function" === typeof this.a.Db && (b = this.a.Db(), b.length && G(a, "scopes", b.join(",")));
          this.i ? G(a, "redirectUrl", this.i) : kd(a.a, "redirectUrl");
          this.g ? G(a, "eventId", this.g) : kd(a.a, "eventId");
          this.h ? G(a, "v", this.h) : kd(a.a, "v");
          if (this.b) for (var h in this.b) this.b.hasOwnProperty(h) && !cd(a, h) && G(a, h, this.b[h]);
          this.f ? G(a, "eid", this.f) : kd(a.a, "eid");
          h = Ki(this.c);
          h.length && G(a, "fw", h.join(","));
          return a.toString();
        };
        function Ki(a) {
          try {
            return firebase.app(a).auth().xa();
          } catch (b) {
            return [];
          }
        }
        function Li(a, b, c, d, e) {
          this.l = a;
          this.f = b;
          this.b = c;
          this.c = d || null;
          this.h = e || null;
          this.o = this.u = this.v = null;
          this.g = [];
          this.m = this.a = null;
        }
        function Mi(a) {
          var b = Vd();
          return Uh(a).then(function(a) {
            a: {
              var c = dd(b), e = c.c;
              c = c.b;
              for (var f = 0; f < a.length; f++) {
                var h = a[f];
                var m = c;
                var p = e;
                0 == h.indexOf("chrome-extension://") ? m = dd(h).b == m && "chrome-extension" == p : "http" != p && "https" != p ? m = !1 : fe.test(h) ? m = m == h : (h = h.split(".").join("\\."), 
                m = new RegExp("^(.+\\." + h + "|" + h + ")$", "i").test(m));
                if (m) {
                  a = !0;
                  break a;
                }
              }
              a = !1;
            }
            if (!a) throw new qg(Vd());
          });
        }
        function Ni(a) {
          if (a.m) return a.m;
          a.m = ge().then(function() {
            if (!a.u) {
              var b = a.c, c = a.h, d = Ki(a.b), e = new Ii(a.l, a.f, a.b);
              e.f = b;
              e.b = c;
              e.c = Ia(d || []);
              a.u = e.toString();
            }
            a.i = new zi(a.u);
            Oi(a);
          });
          return a.m;
        }
        g = Li.prototype;
        g.Ea = function(a, b, c) {
          var d = new L("popup-closed-by-user"), e = new L("web-storage-unsupported"), f = this, h = !1;
          return this.ga().then(function() {
            Pi(f).then(function(c) {
              c || (a && be(a), b(e), h = !0);
            });
          }).s(function() {}).then(function() {
            if (!h) return ee(a);
          }).then(function() {
            if (!h) return Gc(c).then(function() {
              b(d);
            });
          });
        };
        g.Lb = function() {
          var a = H();
          return !ve(a) && !ze(a);
        };
        g.Gb = function() {
          return !1;
        };
        g.Bb = function(a, b, c, d, e, f, h) {
          if (!a) return C(new L("popup-blocked"));
          if (h && !ve()) return this.ga().s(function(b) {
            be(a);
            e(b);
          }), d(), B();
          this.a || (this.a = Mi(Qi(this)));
          var m = this;
          return this.a.then(function() {
            var b = m.ga().s(function(b) {
              be(a);
              e(b);
              throw b;
            });
            d();
            return b;
          }).then(function() {
            lg(c);
            if (!h) {
              var d = Ri(m.l, m.f, m.b, b, c, null, f, m.c, void 0, m.h);
              Wd(d, a);
            }
          }).s(function(a) {
            "auth/network-request-failed" == a.code && (m.a = null);
            throw a;
          });
        };
        function Qi(a) {
          a.o || (a.v = a.c ? qe(a.c, Ki(a.b)) : null, a.o = new Ah(a.f, xi(a.h), a.v));
          return a.o;
        }
        g.Ca = function(a, b, c) {
          this.a || (this.a = Mi(Qi(this)));
          var d = this;
          return this.a.then(function() {
            lg(b);
            var e = Ri(d.l, d.f, d.b, a, b, Vd(), c, d.c, void 0, d.h);
            Wd(e);
          }).s(function(a) {
            "auth/network-request-failed" == a.code && (d.a = null);
            throw a;
          });
        };
        g.ga = function() {
          var a = this;
          return Ni(this).then(function() {
            return a.i.eb;
          }).s(function() {
            a.a = null;
            throw new L("network-request-failed");
          });
        };
        g.Qb = function() {
          return !0;
        };
        function Ri(a, b, c, d, e, f, h, m, p, z) {
          a = new Ji(a, b, c, d, e);
          a.i = f;
          a.g = h;
          a.h = m;
          a.b = Za(p || null);
          a.f = z;
          return a.toString();
        }
        function Oi(a) {
          if (!a.i) throw Error("IfcHandler must be initialized!");
          Ei(a.i, function(b) {
            var c = {};
            if (b && b.authEvent) {
              var d = !1;
              b = ng(b.authEvent);
              for (c = 0; c < a.g.length; c++) d = a.g[c](b) || d;
              c = {};
              c.status = d ? "ACK" : "ERROR";
              return B(c);
            }
            c.status = "ERROR";
            return B(c);
          });
        }
        function Pi(a) {
          var b = {
            type: "webStorageSupport"
          };
          return Ni(a).then(function() {
            return Di(a.i, b);
          }).then(function(a) {
            if (a && a.length && "undefined" !== typeof a[0].webStorageSupport) return a[0].webStorageSupport;
            throw Error();
          });
        }
        g.va = function(a) {
          this.g.push(a);
        };
        g.Ka = function(a) {
          w(this.g, function(b) {
            return b == a;
          });
        };
        function Si(a) {
          this.a = a || firebase.INTERNAL.reactNative && firebase.INTERNAL.reactNative.AsyncStorage;
          if (!this.a) throw new L("internal-error", "The React Native compatibility library was not found.");
          this.type = "asyncStorage";
        }
        g = Si.prototype;
        g.get = function(a) {
          return B(this.a.getItem(a)).then(function(a) {
            return a && ye(a);
          });
        };
        g.set = function(a, b) {
          return B(this.a.setItem(a, we(b)));
        };
        g.P = function(a) {
          return B(this.a.removeItem(a));
        };
        g.Y = function() {};
        g.ca = function() {};
        function Ti(a) {
          this.b = a;
          this.a = {};
          this.c = r(this.f, this);
        }
        var Ui = [];
        function Vi() {
          var a = le() ? self : null;
          v(Ui, function(c) {
            c.b == a && (b = c);
          });
          if (!b) {
            var b = new Ti(a);
            Ui.push(b);
          }
          return b;
        }
        Ti.prototype.f = function(a) {
          var b = a.data.eventType, c = a.data.eventId, d = this.a[b];
          if (d && 0 < d.length) {
            a.ports[0].postMessage({
              status: "ack",
              eventId: c,
              eventType: b,
              response: null
            });
            var e = [];
            v(d, function(b) {
              e.push(B().then(function() {
                return b(a.origin, a.data.data);
              }));
            });
            ub(e).then(function(d) {
              var e = [];
              v(d, function(a) {
                e.push({
                  fulfilled: a.Cb,
                  value: a.value,
                  reason: a.reason ? a.reason.message : void 0
                });
              });
              v(e, function(a) {
                for (var b in a) "undefined" === typeof a[b] && delete a[b];
              });
              a.ports[0].postMessage({
                status: "done",
                eventId: c,
                eventType: b,
                response: e
              });
            });
          }
        };
        Ti.prototype.subscribe = function(a, b) {
          Ya(this.a) && this.b.addEventListener("message", this.c);
          "undefined" === typeof this.a[a] && (this.a[a] = []);
          this.a[a].push(b);
        };
        Ti.prototype.unsubscribe = function(a, b) {
          "undefined" !== typeof this.a[a] && b ? (w(this.a[a], function(a) {
            return a == b;
          }), 0 == this.a[a].length && delete this.a[a]) : b || delete this.a[a];
          Ya(this.a) && this.b.removeEventListener("message", this.c);
        };
        function Wi() {
          this.a = navigator && navigator.serviceWorker && navigator.serviceWorker.controller || null;
        }
        Wi.prototype.postMessage = function(a, b) {
          this.a.postMessage(a, b);
        };
        function Xi() {
          this.f = new Wi();
          this.a = "undefined" !== typeof MessageChannel ? new MessageChannel() : null;
          this.c = !1;
          this.b = [];
        }
        function Yi(a, b) {
          var c, d = b || {}, e, f, h;
          return new A(function(b, p) {
            a.a ? (c = Math.floor(Math.random() * Math.pow(10, 20)).toString(), a.start(), f = setTimeout(function() {
              p(Error("unsupported_event"));
            }, 20), e = function(a) {
              a.data.eventId === c && ("ack" === a.data.status ? (clearTimeout(f), h = setTimeout(function() {
                p(Error("timeout"));
              }, 500)) : "done" === a.data.status ? (clearTimeout(h), "undefined" !== typeof a.data.response ? b(a.data.response) : p(Error("unknown_error"))) : (clearTimeout(f), 
              clearTimeout(h), p(Error("invalid_response"))));
            }, a.b.push(e), a.a.port1.addEventListener("message", e), a.f.postMessage({
              eventType: "keyChanged",
              eventId: c,
              data: d
            }, [ a.a.port2 ])) : p(Error("connection_unavailable"));
          }).then(function(b) {
            Zi(a, e);
            return b;
          }).s(function(b) {
            Zi(a, e);
            throw b;
          });
        }
        function Zi(a, b) {
          a.a && (w(a.b, function(a) {
            return a == b;
          }), a.a.port1.removeEventListener("message", b));
        }
        Xi.prototype.close = function() {
          if (this.a) {
            for (;0 < this.b.length; ) {
              var a = this.b.pop();
              this.a.port1.removeEventListener("message", a);
            }
            this.a.port1.close();
            this.a = null;
            this.c = !1;
          }
        };
        Xi.prototype.start = function() {
          this.a && !this.c && (this.a.port1.start(), this.c = !0);
        };
        function $i() {
          if (!aj()) throw new L("web-storage-unsupported");
          this.f = {};
          this.a = [];
          this.b = 0;
          this.g = k.indexedDB;
          this.type = "indexedDB";
          this.i = null;
          var a = this;
          le() && self && (this.i = Vi(), this.i.subscribe("keyChanged", function(b, c) {
            return a.Pb().then(function(b) {
              0 < b.length && v(a.a, function(a) {
                a(b);
              });
              return {
                keyProcessed: Fa(b, c.key)
              };
            });
          }));
        }
        var bj;
        function cj(a) {
          return new A(function(b, c) {
            var d = a.g.deleteDatabase("firebaseLocalStorageDb");
            d.onsuccess = function() {
              b();
            };
            d.onerror = function(a) {
              c(Error(a.target.error));
            };
          });
        }
        function dj(a) {
          return new A(function(b, c) {
            var d = a.g.open("firebaseLocalStorageDb", 1);
            d.onerror = function(a) {
              try {
                a.preventDefault();
              } catch (f) {}
              c(Error(a.target.error));
            };
            d.onupgradeneeded = function(a) {
              a = a.target.result;
              try {
                a.createObjectStore("firebaseLocalStorage", {
                  keyPath: "fbase_key"
                });
              } catch (f) {
                c(f);
              }
            };
            d.onsuccess = function(d) {
              d = d.target.result;
              d.objectStoreNames.contains("firebaseLocalStorage") ? b(d) : cj(a).then(function() {
                return dj(a);
              }).then(function(a) {
                b(a);
              }).s(function(a) {
                c(a);
              });
            };
          });
        }
        function ej(a) {
          a.h || (a.h = dj(a));
          return a.h;
        }
        function aj() {
          try {
            return !!k.indexedDB;
          } catch (a) {
            return !1;
          }
        }
        function fj(a) {
          return a.objectStore("firebaseLocalStorage");
        }
        function gj(a, b) {
          return a.transaction([ "firebaseLocalStorage" ], b ? "readwrite" : "readonly");
        }
        function hj(a) {
          return new A(function(b, c) {
            a.onsuccess = function(a) {
              a && a.target ? b(a.target.result) : b();
            };
            a.onerror = function(a) {
              c(Error(a.target.errorCode));
            };
          });
        }
        g = $i.prototype;
        g.set = function(a, b) {
          var c = !1, d, e = this;
          return ej(this).then(function(b) {
            d = b;
            b = fj(gj(d, !0));
            return hj(b.get(a));
          }).then(function(f) {
            var h = fj(gj(d, !0));
            if (f) return f.value = b, hj(h.put(f));
            e.b++;
            c = !0;
            f = {};
            f.fbase_key = a;
            f.value = b;
            return hj(h.add(f));
          }).then(function() {
            e.f[a] = b;
            return ij(a);
          }).ia(function() {
            c && e.b--;
          });
        };
        function ij(a) {
          return navigator && navigator.serviceWorker && navigator.serviceWorker.controller ? Yi(new Xi(), {
            key: a
          }).then(function() {}).s(function() {}) : B();
        }
        g.get = function(a) {
          return ej(this).then(function(b) {
            return hj(fj(gj(b, !1)).get(a));
          }).then(function(a) {
            return a && a.value;
          });
        };
        g.P = function(a) {
          var b = !1, c = this;
          return ej(this).then(function(d) {
            b = !0;
            c.b++;
            return hj(fj(gj(d, !0))["delete"](a));
          }).then(function() {
            delete c.f[a];
            return ij(a);
          }).ia(function() {
            b && c.b--;
          });
        };
        g.Pb = function() {
          var a = this;
          return ej(this).then(function(a) {
            var b = fj(gj(a, !1));
            return b.getAll ? hj(b.getAll()) : new A(function(a, c) {
              var d = [], e = b.openCursor();
              e.onsuccess = function(b) {
                (b = b.target.result) ? (d.push(b.value), b["continue"]()) : a(d);
              };
              e.onerror = function(a) {
                c(Error(a.target.errorCode));
              };
            });
          }).then(function(b) {
            var c = {}, d = [];
            if (0 == a.b) {
              for (d = 0; d < b.length; d++) c[b[d].fbase_key] = b[d].value;
              d = Xd(a.f, c);
              a.f = c;
            }
            return d;
          });
        };
        g.Y = function(a) {
          0 == this.a.length && jj(this);
          this.a.push(a);
        };
        g.ca = function(a) {
          w(this.a, function(b) {
            return b == a;
          });
          0 == this.a.length && this.c && this.c.cancel("STOP_EVENT");
        };
        function jj(a) {
          function b() {
            a.c = Gc(800).then(r(a.Pb, a)).then(function(b) {
              0 < b.length && v(a.a, function(a) {
                a(b);
              });
            }).then(b).s(function(a) {
              "STOP_EVENT" != a.message && b();
            });
            return a.c;
          }
          a.c && a.c.cancel("STOP_EVENT");
          b();
        }
        function kj(a) {
          var b = this, c = null;
          this.a = [];
          this.type = "indexedDB";
          this.c = a;
          this.b = B().then(function() {
            if (aj()) {
              var a = se(), e = "__sak" + a;
              bj || (bj = new $i());
              c = bj;
              return c.set(e, a).then(function() {
                return c.get(e);
              }).then(function(b) {
                if (b !== a) throw Error("indexedDB not supported!");
                return c.P(e);
              }).then(function() {
                return c;
              }).s(function() {
                return b.c;
              });
            }
            return b.c;
          }).then(function(a) {
            b.type = a.type;
            a.Y(function(a) {
              v(b.a, function(b) {
                b(a);
              });
            });
            return a;
          });
        }
        g = kj.prototype;
        g.get = function(a) {
          return this.b.then(function(b) {
            return b.get(a);
          });
        };
        g.set = function(a, b) {
          return this.b.then(function(c) {
            return c.set(a, b);
          });
        };
        g.P = function(a) {
          return this.b.then(function(b) {
            return b.P(a);
          });
        };
        g.Y = function(a) {
          this.a.push(a);
        };
        g.ca = function(a) {
          w(this.a, function(b) {
            return b == a;
          });
        };
        function lj() {
          this.a = {};
          this.type = "inMemory";
        }
        g = lj.prototype;
        g.get = function(a) {
          return B(this.a[a]);
        };
        g.set = function(a, b) {
          this.a[a] = b;
          return B();
        };
        g.P = function(a) {
          delete this.a[a];
          return B();
        };
        g.Y = function() {};
        g.ca = function() {};
        function mj() {
          if (!nj()) {
            if ("Node" == me()) throw new L("internal-error", "The LocalStorage compatibility library was not found.");
            throw new L("web-storage-unsupported");
          }
          this.a = oj() || firebase.INTERNAL.node.localStorage;
          this.type = "localStorage";
        }
        function oj() {
          try {
            var a = k.localStorage, b = se();
            a && (a.setItem(b, "1"), a.removeItem(b));
            return a;
          } catch (c) {
            return null;
          }
        }
        function nj() {
          var a = "Node" == me();
          a = oj() || a && firebase.INTERNAL.node && firebase.INTERNAL.node.localStorage;
          if (!a) return !1;
          try {
            return a.setItem("__sak", "1"), a.removeItem("__sak"), !0;
          } catch (b) {
            return !1;
          }
        }
        g = mj.prototype;
        g.get = function(a) {
          var b = this;
          return B().then(function() {
            var c = b.a.getItem(a);
            return ye(c);
          });
        };
        g.set = function(a, b) {
          var c = this;
          return B().then(function() {
            var d = we(b);
            null === d ? c.P(a) : c.a.setItem(a, d);
          });
        };
        g.P = function(a) {
          var b = this;
          return B().then(function() {
            b.a.removeItem(a);
          });
        };
        g.Y = function(a) {
          k.window && pc(k.window, "storage", a);
        };
        g.ca = function(a) {
          k.window && E(k.window, "storage", a);
        };
        function pj() {
          this.type = "nullStorage";
        }
        g = pj.prototype;
        g.get = function() {
          return B(null);
        };
        g.set = function() {
          return B();
        };
        g.P = function() {
          return B();
        };
        g.Y = function() {};
        g.ca = function() {};
        function qj() {
          if (!rj()) {
            if ("Node" == me()) throw new L("internal-error", "The SessionStorage compatibility library was not found.");
            throw new L("web-storage-unsupported");
          }
          this.a = sj() || firebase.INTERNAL.node.sessionStorage;
          this.type = "sessionStorage";
        }
        function sj() {
          try {
            var a = k.sessionStorage, b = se();
            a && (a.setItem(b, "1"), a.removeItem(b));
            return a;
          } catch (c) {
            return null;
          }
        }
        function rj() {
          var a = "Node" == me();
          a = sj() || a && firebase.INTERNAL.node && firebase.INTERNAL.node.sessionStorage;
          if (!a) return !1;
          try {
            return a.setItem("__sak", "1"), a.removeItem("__sak"), !0;
          } catch (b) {
            return !1;
          }
        }
        g = qj.prototype;
        g.get = function(a) {
          var b = this;
          return B().then(function() {
            var c = b.a.getItem(a);
            return ye(c);
          });
        };
        g.set = function(a, b) {
          var c = this;
          return B().then(function() {
            var d = we(b);
            null === d ? c.P(a) : c.a.setItem(a, d);
          });
        };
        g.P = function(a) {
          var b = this;
          return B().then(function() {
            b.a.removeItem(a);
          });
        };
        g.Y = function() {};
        g.ca = function() {};
        function tj() {
          var a = {};
          a.Browser = uj;
          a.Node = vj;
          a.ReactNative = wj;
          a.Worker = xj;
          this.a = a[me()];
        }
        var yj, uj = {
          A: mj,
          Qa: qj
        }, vj = {
          A: mj,
          Qa: qj
        }, wj = {
          A: Si,
          Qa: pj
        }, xj = {
          A: mj,
          Qa: pj
        };
        var zj = {
          Zc: "local",
          NONE: "none",
          ad: "session"
        };
        function Aj(a) {
          var b = new L("invalid-persistence-type"), c = new L("unsupported-persistence-type");
          a: {
            for (d in zj) if (zj[d] == a) {
              var d = !0;
              break a;
            }
            d = !1;
          }
          if (!d || "string" !== typeof a) throw b;
          switch (me()) {
           case "ReactNative":
            if ("session" === a) throw c;
            break;

           case "Node":
            if ("none" !== a) throw c;
            break;

           default:
            if (!re() && "none" !== a) throw c;
          }
        }
        function Bj() {
          var a = !(ze(H()) || !ke()), b = ve(), c = re();
          this.o = a;
          this.h = b;
          this.m = c;
          this.a = {};
          yj || (yj = new tj());
          a = yj;
          try {
            this.g = !Ud() && Fe() || !k.indexedDB ? new a.a.A() : new kj(le() ? new lj() : new a.a.A());
          } catch (d) {
            this.g = new lj(), this.h = !0;
          }
          try {
            this.i = new a.a.Qa();
          } catch (d) {
            this.i = new lj();
          }
          this.l = new lj();
          this.f = r(this.Ob, this);
          this.b = {};
        }
        var Cj;
        function Dj() {
          Cj || (Cj = new Bj());
          return Cj;
        }
        function Ej(a, b) {
          switch (b) {
           case "session":
            return a.i;

           case "none":
            return a.l;

           default:
            return a.g;
          }
        }
        function Fj(a, b) {
          return "firebase:" + a.name + (b ? ":" + b : "");
        }
        function Gj(a, b, c) {
          var d = Fj(b, c), e = Ej(a, b.A);
          return a.get(b, c).then(function(f) {
            var h = null;
            try {
              h = ye(k.localStorage.getItem(d));
            } catch (m) {}
            if (h && !f) return k.localStorage.removeItem(d), a.set(b, h, c);
            h && f && "localStorage" != e.type && k.localStorage.removeItem(d);
          });
        }
        g = Bj.prototype;
        g.get = function(a, b) {
          return Ej(this, a.A).get(Fj(a, b));
        };
        function Hj(a, b, c) {
          c = Fj(b, c);
          "local" == b.A && (a.b[c] = null);
          return Ej(a, b.A).P(c);
        }
        g.set = function(a, b, c) {
          var d = Fj(a, c), e = this, f = Ej(this, a.A);
          return f.set(d, b).then(function() {
            return f.get(d);
          }).then(function(b) {
            "local" == a.A && (e.b[d] = b);
          });
        };
        g.addListener = function(a, b, c) {
          a = Fj(a, b);
          this.m && (this.b[a] = k.localStorage.getItem(a));
          Ya(this.a) && (Ej(this, "local").Y(this.f), this.h || (Ud() || !Fe()) && k.indexedDB || !this.m || Ij(this));
          this.a[a] || (this.a[a] = []);
          this.a[a].push(c);
        };
        g.removeListener = function(a, b, c) {
          a = Fj(a, b);
          this.a[a] && (w(this.a[a], function(a) {
            return a == c;
          }), 0 == this.a[a].length && delete this.a[a]);
          Ya(this.a) && (Ej(this, "local").ca(this.f), Jj(this));
        };
        function Ij(a) {
          Jj(a);
          a.c = setInterval(function() {
            for (var b in a.a) {
              var c = k.localStorage.getItem(b), d = a.b[b];
              c != d && (a.b[b] = c, c = new dc({
                type: "storage",
                key: b,
                target: window,
                oldValue: d,
                newValue: c,
                a: !0
              }), a.Ob(c));
            }
          }, 1e3);
        }
        function Jj(a) {
          a.c && (clearInterval(a.c), a.c = null);
        }
        g.Ob = function(a) {
          if (a && a.f) {
            var b = a.a.key;
            if (null == b) for (var c in this.a) {
              var d = this.b[c];
              "undefined" === typeof d && (d = null);
              var e = k.localStorage.getItem(c);
              e !== d && (this.b[c] = e, this.Wa(c));
            } else if (0 == b.indexOf("firebase:") && this.a[b]) {
              "undefined" !== typeof a.a.a ? Ej(this, "local").ca(this.f) : Jj(this);
              if (this.o) if (c = k.localStorage.getItem(b), d = a.a.newValue, d !== c) null !== d ? k.localStorage.setItem(b, d) : k.localStorage.removeItem(b); else if (this.b[b] === d && "undefined" === typeof a.a.a) return;
              var f = this;
              c = function() {
                "undefined" === typeof a.a.a && f.b[b] === k.localStorage.getItem(b) || (f.b[b] = k.localStorage.getItem(b), 
                f.Wa(b));
              };
              Nb && Yb && 10 == Yb && k.localStorage.getItem(b) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
            }
          } else v(a, r(this.Wa, this));
        };
        g.Wa = function(a) {
          this.a[a] && v(this.a[a], function(a) {
            a();
          });
        };
        function Kj(a) {
          this.a = a;
          this.b = Dj();
        }
        var Lj = {
          name: "authEvent",
          A: "local"
        };
        function Mj(a) {
          return a.b.get(Lj, a.a).then(function(a) {
            return ng(a);
          });
        }
        function Nj() {
          this.a = Dj();
        }
        function Oj() {
          this.b = -1;
        }
        function Pj(a, b) {
          this.b = -1;
          this.b = Qj;
          this.f = k.Uint8Array ? new Uint8Array(this.b) : Array(this.b);
          this.g = this.c = 0;
          this.a = [];
          this.i = a;
          this.h = b;
          this.m = k.Int32Array ? new Int32Array(64) : Array(64);
          void 0 !== Rj || (Rj = k.Int32Array ? new Int32Array(Sj) : Sj);
          this.reset();
        }
        var Rj;
        t(Pj, Oj);
        for (var Qj = 64, Tj = Qj - 1, Uj = [], Vj = 0; Vj < Tj; Vj++) Uj[Vj] = 0;
        var Wj = Ha(128, Uj);
        Pj.prototype.reset = function() {
          this.g = this.c = 0;
          this.a = k.Int32Array ? new Int32Array(this.h) : Ia(this.h);
        };
        function Xj(a) {
          for (var b = a.f, c = a.m, d = 0, e = 0; e < b.length; ) c[d++] = b[e] << 24 | b[e + 1] << 16 | b[e + 2] << 8 | b[e + 3], 
          e = 4 * d;
          for (b = 16; 64 > b; b++) {
            e = 0 | c[b - 15];
            d = 0 | c[b - 2];
            var f = (0 | c[b - 16]) + ((e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3) | 0, h = (0 | c[b - 7]) + ((d >>> 17 | d << 15) ^ (d >>> 19 | d << 13) ^ d >>> 10) | 0;
            c[b] = f + h | 0;
          }
          d = 0 | a.a[0];
          e = 0 | a.a[1];
          var m = 0 | a.a[2], p = 0 | a.a[3], z = 0 | a.a[4], qc = 0 | a.a[5], Qc = 0 | a.a[6];
          f = 0 | a.a[7];
          for (b = 0; 64 > b; b++) {
            var Zl = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & e ^ d & m ^ e & m) | 0;
            h = z & qc ^ ~z & Qc;
            f = f + ((z >>> 6 | z << 26) ^ (z >>> 11 | z << 21) ^ (z >>> 25 | z << 7)) | 0;
            h = h + (0 | Rj[b]) | 0;
            h = f + (h + (0 | c[b]) | 0) | 0;
            f = Qc;
            Qc = qc;
            qc = z;
            z = p + h | 0;
            p = m;
            m = e;
            e = d;
            d = h + Zl | 0;
          }
          a.a[0] = a.a[0] + d | 0;
          a.a[1] = a.a[1] + e | 0;
          a.a[2] = a.a[2] + m | 0;
          a.a[3] = a.a[3] + p | 0;
          a.a[4] = a.a[4] + z | 0;
          a.a[5] = a.a[5] + qc | 0;
          a.a[6] = a.a[6] + Qc | 0;
          a.a[7] = a.a[7] + f | 0;
        }
        function Yj(a, b, c) {
          void 0 === c && (c = b.length);
          var d = 0, e = a.c;
          if (l(b)) for (;d < c; ) a.f[e++] = b.charCodeAt(d++), e == a.b && (Xj(a), e = 0); else {
            if (!ha(b)) throw Error("message must be string or array");
            for (;d < c; ) {
              var f = b[d++];
              if (!("number" == typeof f && 0 <= f && 255 >= f && f == (0 | f))) throw Error("message must be a byte array");
              a.f[e++] = f;
              e == a.b && (Xj(a), e = 0);
            }
          }
          a.c = e;
          a.g += c;
        }
        var Sj = [ 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 ];
        function Zj() {
          Pj.call(this, 8, ak);
        }
        t(Zj, Pj);
        var ak = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];
        function bk(a, b, c, d, e) {
          this.l = a;
          this.i = b;
          this.m = c;
          this.o = d || null;
          this.u = e || null;
          this.h = b + ":" + c;
          this.v = new Nj();
          this.g = new Kj(this.h);
          this.f = null;
          this.b = [];
          this.a = this.c = null;
        }
        function ck(a) {
          return new L("invalid-cordova-configuration", a);
        }
        g = bk.prototype;
        g.ga = function() {
          return this.za ? this.za : this.za = he().then(function() {
            if ("function" !== typeof I("universalLinks.subscribe", k)) throw ck("cordova-universal-links-plugin is not installed");
            if ("undefined" === typeof I("BuildInfo.packageName", k)) throw ck("cordova-plugin-buildinfo is not installed");
            if ("function" !== typeof I("cordova.plugins.browsertab.openUrl", k)) throw ck("cordova-plugin-browsertab is not installed");
            if ("function" !== typeof I("cordova.InAppBrowser.open", k)) throw ck("cordova-plugin-inappbrowser is not installed");
          }, function() {
            throw new L("cordova-not-ready");
          });
        };
        function dk() {
          for (var a = 20, b = []; 0 < a; ) b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62 * Math.random()))), 
          a--;
          return b.join("");
        }
        function ek(a) {
          var b = new Zj();
          Yj(b, a);
          a = [];
          var c = 8 * b.g;
          56 > b.c ? Yj(b, Wj, 56 - b.c) : Yj(b, Wj, b.b - (b.c - 56));
          for (var d = 63; 56 <= d; d--) b.f[d] = 255 & c, c /= 256;
          Xj(b);
          for (d = c = 0; d < b.i; d++) for (var e = 24; 0 <= e; e -= 8) a[c++] = b.a[d] >> e & 255;
          return kf(a);
        }
        g.Ea = function(a, b) {
          b(new L("operation-not-supported-in-this-environment"));
          return B();
        };
        g.Bb = function() {
          return C(new L("operation-not-supported-in-this-environment"));
        };
        g.Qb = function() {
          return !1;
        };
        g.Lb = function() {
          return !0;
        };
        g.Gb = function() {
          return !0;
        };
        g.Ca = function(a, b, c) {
          if (this.c) return C(new L("redirect-operation-pending"));
          var d = this, e = k.document, f = null, h = null, m = null, p = null;
          return this.c = B().then(function() {
            lg(b);
            return fk(d);
          }).then(function() {
            return gk(d, a, b, c);
          }).then(function() {
            return new A(function(a, b) {
              h = function() {
                var b = I("cordova.plugins.browsertab.close", k);
                a();
                "function" === typeof b && b();
                d.a && "function" === typeof d.a.close && (d.a.close(), d.a = null);
                return !1;
              };
              d.va(h);
              m = function() {
                f || (f = Gc(2e3).then(function() {
                  b(new L("redirect-cancelled-by-user"));
                }));
              };
              p = function() {
                Ce() && m();
              };
              e.addEventListener("resume", m, !1);
              H().toLowerCase().match(/android/) || e.addEventListener("visibilitychange", p, !1);
            }).s(function(a) {
              return hk(d).then(function() {
                throw a;
              });
            });
          }).ia(function() {
            m && e.removeEventListener("resume", m, !1);
            p && e.removeEventListener("visibilitychange", p, !1);
            f && f.cancel();
            h && d.Ka(h);
            d.c = null;
          });
        };
        function gk(a, b, c, d) {
          var e = dk(), f = new mg(b, d, null, e, new L("no-auth-event")), h = I("BuildInfo.packageName", k);
          if ("string" !== typeof h) throw new L("invalid-cordova-configuration");
          var m = I("BuildInfo.displayName", k), p = {};
          if (H().toLowerCase().match(/iphone|ipad|ipod/)) p.ibi = h; else {
            if (!H().toLowerCase().match(/android/)) return C(new L("operation-not-supported-in-this-environment"));
            p.apn = h;
          }
          m && (p.appDisplayName = m);
          e = ek(e);
          p.sessionId = e;
          var z = Ri(a.l, a.i, a.m, b, c, null, d, a.o, p, a.u);
          return a.ga().then(function() {
            var b = a.h;
            return a.v.a.set(Lj, f.D(), b);
          }).then(function() {
            var b = I("cordova.plugins.browsertab.isAvailable", k);
            if ("function" !== typeof b) throw new L("invalid-cordova-configuration");
            var c = null;
            b(function(b) {
              if (b) {
                c = I("cordova.plugins.browsertab.openUrl", k);
                if ("function" !== typeof c) throw new L("invalid-cordova-configuration");
                c(z);
              } else {
                c = I("cordova.InAppBrowser.open", k);
                if ("function" !== typeof c) throw new L("invalid-cordova-configuration");
                b = H();
                b = !(!b.match(/(iPad|iPhone|iPod).*OS 7_\d/i) && !b.match(/(iPad|iPhone|iPod).*OS 8_\d/i));
                a.a = c(z, b ? "_blank" : "_system", "location=yes");
              }
            });
          });
        }
        function ik(a, b) {
          for (var c = 0; c < a.b.length; c++) try {
            a.b[c](b);
          } catch (d) {}
        }
        function fk(a) {
          a.f || (a.f = a.ga().then(function() {
            return new A(function(b) {
              function c(d) {
                b(d);
                a.Ka(c);
                return !1;
              }
              a.va(c);
              jk(a);
            });
          }));
          return a.f;
        }
        function hk(a) {
          var b = null;
          return Mj(a.g).then(function(c) {
            b = c;
            c = a.g;
            return Hj(c.b, Lj, c.a);
          }).then(function() {
            return b;
          });
        }
        function jk(a) {
          function b(b) {
            d = !0;
            e && e.cancel();
            hk(a).then(function(d) {
              var e = c;
              if (d && b && b.url) {
                var f = null;
                e = Hf(b.url);
                -1 != e.indexOf("/__/auth/callback") && (f = dd(e), f = ye(cd(f, "firebaseError") || null), 
                f = (f = "object" === typeof f ? Ze(f) : null) ? new mg(d.b, d.c, null, null, f) : new mg(d.b, d.c, e, d.g));
                e = f || c;
              }
              ik(a, e);
            });
          }
          var c = new mg("unknown", null, null, null, new L("no-auth-event")), d = !1, e = Gc(500).then(function() {
            return hk(a).then(function() {
              d || ik(a, c);
            });
          }), f = k.handleOpenURL;
          k.handleOpenURL = function(a) {
            0 == a.toLowerCase().indexOf(I("BuildInfo.packageName", k).toLowerCase() + "://") && b({
              url: a
            });
            if ("function" === typeof f) try {
              f(a);
            } catch (m) {
              console.error(m);
            }
          };
          pg || (pg = new og());
          pg.subscribe(b);
        }
        g.va = function(a) {
          this.b.push(a);
          fk(this).s(function(b) {
            "auth/invalid-cordova-configuration" === b.code && (b = new mg("unknown", null, null, null, new L("no-auth-event")), 
            a(b));
          });
        };
        g.Ka = function(a) {
          w(this.b, function(b) {
            return b == a;
          });
        };
        function kk(a) {
          this.a = a;
          this.b = Dj();
        }
        var lk = {
          name: "pendingRedirect",
          A: "session"
        };
        function mk(a) {
          return a.b.set(lk, "pending", a.a);
        }
        function nk(a) {
          return Hj(a.b, lk, a.a);
        }
        function ok(a) {
          return a.b.get(lk, a.a).then(function(a) {
            return "pending" == a;
          });
        }
        function pk(a, b, c) {
          this.u = a;
          this.m = b;
          this.l = c;
          this.h = [];
          this.f = !1;
          this.i = r(this.ab, this);
          this.b = new qk();
          this.o = new rk();
          this.g = new kk(this.m + ":" + this.l);
          this.c = {};
          this.c.unknown = this.b;
          this.c.signInViaRedirect = this.b;
          this.c.linkViaRedirect = this.b;
          this.c.reauthViaRedirect = this.b;
          this.c.signInViaPopup = this.o;
          this.c.linkViaPopup = this.o;
          this.c.reauthViaPopup = this.o;
          this.a = sk(this.u, this.m, this.l, yi);
        }
        function sk(a, b, c, d) {
          var e = firebase.SDK_VERSION || null;
          return ie() ? new bk(a, b, c, e, d) : new Li(a, b, c, e, d);
        }
        g = pk.prototype;
        g.reset = function() {
          this.f = !1;
          this.a.Ka(this.i);
          this.a = sk(this.u, this.m, this.l);
        };
        g.Xa = function() {
          this.b.Xa();
        };
        function tk(a) {
          a.f || (a.f = !0, a.a.va(a.i));
          var b = a.a;
          return a.a.ga().s(function(c) {
            a.a == b && a.reset();
            throw c;
          });
        }
        function uk(a) {
          a.a.Lb() && tk(a).s(function(b) {
            var c = new mg("unknown", null, null, null, new L("operation-not-supported-in-this-environment"));
            vk(b) && a.ab(c);
          });
          a.a.Gb() || wk(a.b);
        }
        g.subscribe = function(a) {
          Fa(this.h, a) || this.h.push(a);
          if (!this.f) {
            var b = this;
            ok(this.g).then(function(a) {
              a ? nk(b.g).then(function() {
                tk(b).s(function(a) {
                  var c = new mg("unknown", null, null, null, new L("operation-not-supported-in-this-environment"));
                  vk(a) && b.ab(c);
                });
              }) : uk(b);
            }).s(function() {
              uk(b);
            });
          }
        };
        g.unsubscribe = function(a) {
          w(this.h, function(b) {
            return b == a;
          });
        };
        g.ab = function(a) {
          if (!a) throw new L("invalid-auth-event");
          for (var b = !1, c = 0; c < this.h.length; c++) {
            var d = this.h[c];
            if (d.ub(a.b, a.c)) {
              (b = this.c[a.b]) && b.h(a, d);
              b = !0;
              break;
            }
          }
          wk(this.b);
          return b;
        };
        var xk = new Be(2e3, 1e4), yk = new Be(3e4, 6e4);
        pk.prototype.fa = function() {
          return this.b.fa();
        };
        function zk(a, b, c, d, e, f) {
          return a.a.Bb(b, c, d, function() {
            a.f || (a.f = !0, a.a.va(a.i));
          }, function() {
            a.reset();
          }, e, f);
        }
        function vk(a) {
          return !(!a || "auth/cordova-not-ready" != a.code);
        }
        pk.prototype.Ca = function(a, b, c) {
          var d = this, e;
          return mk(this.g).then(function() {
            return d.a.Ca(a, b, c).s(function(a) {
              if (vk(a)) throw new L("operation-not-supported-in-this-environment");
              e = a;
              return nk(d.g).then(function() {
                throw e;
              });
            }).then(function() {
              return d.a.Qb() ? new A(function() {}) : nk(d.g).then(function() {
                return d.fa();
              }).then(function() {}).s(function() {});
            });
          });
        };
        pk.prototype.Ea = function(a, b, c, d) {
          return this.a.Ea(c, function(c) {
            a.ha(b, null, c, d);
          }, xk.get());
        };
        var Ak = {};
        function Bk(a, b, c) {
          var d = b + ":" + c;
          Ak[d] || (Ak[d] = new pk(a, b, c));
          return Ak[d];
        }
        function qk() {
          this.b = null;
          this.f = [];
          this.c = [];
          this.a = null;
          this.i = this.g = !1;
        }
        qk.prototype.reset = function() {
          this.b = null;
          this.a && (this.a.cancel(), this.a = null);
        };
        qk.prototype.h = function(a, b) {
          if (a) {
            this.reset();
            this.g = !0;
            var c = a.b, d = a.c, e = a.a && "auth/web-storage-unsupported" == a.a.code, f = a.a && "auth/operation-not-supported-in-this-environment" == a.a.code;
            this.i = !(!e && !f);
            "unknown" != c || e || f ? a.a ? (Ck(this, !0, null, a.a), B()) : b.wa(c, d) ? Dk(this, a, b) : C(new L("invalid-auth-event")) : (Ck(this, !1, null, null), 
            B());
          } else C(new L("invalid-auth-event"));
        };
        function wk(a) {
          a.g || (a.g = !0, Ck(a, !1, null, null));
        }
        qk.prototype.Xa = function() {
          this.g && !this.i && Ck(this, !1, null, null);
        };
        function Dk(a, b, c) {
          c = c.wa(b.b, b.c);
          var d = b.f, e = b.g, f = !!b.b.match(/Redirect$/);
          c(d, e).then(function(b) {
            Ck(a, f, b, null);
          }).s(function(b) {
            Ck(a, f, null, b);
          });
        }
        function Ek(a, b) {
          a.b = function() {
            return C(b);
          };
          if (a.c.length) for (var c = 0; c < a.c.length; c++) a.c[c](b);
        }
        function Fk(a, b) {
          a.b = function() {
            return B(b);
          };
          if (a.f.length) for (var c = 0; c < a.f.length; c++) a.f[c](b);
        }
        function Ck(a, b, c, d) {
          b ? d ? Ek(a, d) : Fk(a, c) : Fk(a, {
            user: null
          });
          a.f = [];
          a.c = [];
        }
        qk.prototype.fa = function() {
          var a = this;
          return new A(function(b, c) {
            a.b ? a.b().then(b, c) : (a.f.push(b), a.c.push(c), Gk(a));
          });
        };
        function Gk(a) {
          var b = new L("timeout");
          a.a && a.a.cancel();
          a.a = Gc(yk.get()).then(function() {
            a.b || (a.g = !0, Ck(a, !0, null, b));
          });
        }
        function rk() {}
        rk.prototype.h = function(a, b) {
          if (a) {
            var c = a.b, d = a.c;
            a.a ? (b.ha(a.b, null, a.a, a.c), B()) : b.wa(c, d) ? Hk(a, b) : C(new L("invalid-auth-event"));
          } else C(new L("invalid-auth-event"));
        };
        function Hk(a, b) {
          var c = a.c, d = a.b;
          b.wa(d, c)(a.f, a.g).then(function(a) {
            b.ha(d, a, null, c);
          }).s(function(a) {
            b.ha(d, null, a, c);
          });
        }
        function Ik() {
          this.rb = !1;
          Object.defineProperty(this, "appVerificationDisabled", {
            get: function() {
              return this.rb;
            },
            set: function(a) {
              this.rb = a;
            },
            enumerable: !1
          });
        }
        function Jk(a, b) {
          this.a = b;
          J(this, "verificationId", a);
        }
        Jk.prototype.confirm = function(a) {
          a = jg(this.verificationId, a);
          return this.a(a);
        };
        function Kk(a, b, c, d) {
          return new hg(a).Ta(b, c).then(function(a) {
            return new Jk(a, d);
          });
        }
        function Lk(a) {
          var b = sf(a);
          if (!(b && b.exp && b.auth_time && b.iat)) throw new L("internal-error", "An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.");
          K(this, {
            token: a,
            expirationTime: Ee(1e3 * b.exp),
            authTime: Ee(1e3 * b.auth_time),
            issuedAtTime: Ee(1e3 * b.iat),
            signInProvider: b.firebase && b.firebase.sign_in_provider ? b.firebase.sign_in_provider : null,
            claims: b
          });
        }
        function Mk(a, b, c) {
          this.h = a;
          this.i = b;
          this.g = c;
          this.c = 3e4;
          this.f = 96e4;
          this.b = null;
          this.a = this.c;
          if (this.f < this.c) throw Error("Proactive refresh lower bound greater than upper bound!");
        }
        Mk.prototype.start = function() {
          this.a = this.c;
          Nk(this, !0);
        };
        function Ok(a, b) {
          if (b) return a.a = a.c, a.g();
          b = a.a;
          a.a *= 2;
          a.a > a.f && (a.a = a.f);
          return b;
        }
        function Nk(a, b) {
          a.stop();
          a.b = Gc(Ok(a, b)).then(function() {
            return De();
          }).then(function() {
            return a.h();
          }).then(function() {
            Nk(a, !0);
          }).s(function(b) {
            a.i(b) && Nk(a, !1);
          });
        }
        Mk.prototype.stop = function() {
          this.b && (this.b.cancel(), this.b = null);
        };
        function Pk(a) {
          this.f = a;
          this.b = this.a = null;
          this.c = 0;
        }
        Pk.prototype.D = function() {
          return {
            apiKey: this.f.b,
            refreshToken: this.a,
            accessToken: this.b,
            expirationTime: this.c
          };
        };
        function Qk(a, b) {
          var c = b[M], d = b.refreshToken;
          b = Rk(b.expiresIn);
          a.b = c;
          a.c = b;
          a.a = d;
        }
        function Sk(a, b) {
          a.b = b.b;
          a.a = b.a;
          a.c = b.c;
        }
        function Rk(a) {
          return na() + 1e3 * parseInt(a, 10);
        }
        function Tk(a, b) {
          return Mh(a.f, b).then(function(b) {
            a.b = b.access_token;
            a.c = Rk(b.expires_in);
            a.a = b.refresh_token;
            return {
              accessToken: a.b,
              expirationTime: a.c,
              refreshToken: a.a
            };
          }).s(function(b) {
            "auth/user-token-expired" == b.code && (a.a = null);
            throw b;
          });
        }
        Pk.prototype.getToken = function(a) {
          a = !!a;
          return this.b && !this.a ? C(new L("user-token-expired")) : a || !this.b || na() > this.c - 3e4 ? this.a ? Tk(this, {
            grant_type: "refresh_token",
            refresh_token: this.a
          }) : B(null) : B({
            accessToken: this.b,
            expirationTime: this.c,
            refreshToken: this.a
          });
        };
        function Uk(a, b) {
          this.a = a || null;
          this.b = b || null;
          K(this, {
            lastSignInTime: Ee(b || null),
            creationTime: Ee(a || null)
          });
        }
        function Vk(a) {
          return new Uk(a.a, a.b);
        }
        Uk.prototype.D = function() {
          return {
            lastLoginAt: this.b,
            createdAt: this.a
          };
        };
        function Wk(a, b, c, d, e, f) {
          K(this, {
            uid: a,
            displayName: d || null,
            photoURL: e || null,
            email: c || null,
            phoneNumber: f || null,
            providerId: b
          });
        }
        function Xk(a, b) {
          D.call(this, a);
          for (var c in b) this[c] = b[c];
        }
        t(Xk, D);
        function Q(a, b, c) {
          this.G = [];
          this.l = a.apiKey;
          this.o = a.appName;
          this.u = a.authDomain || null;
          a = firebase.SDK_VERSION ? qe(firebase.SDK_VERSION) : null;
          this.b = new Ah(this.l, xi(yi), a);
          this.h = new Pk(this.b);
          Yk(this, b[M]);
          Qk(this.h, b);
          J(this, "refreshToken", this.h.a);
          Zk(this, c || {});
          F.call(this);
          this.I = !1;
          this.u && te() && (this.a = Bk(this.u, this.l, this.o));
          this.N = [];
          this.i = null;
          this.w = $k(this);
          this.V = r(this.Ha, this);
          var d = this;
          this.ka = null;
          this.sa = function(a) {
            d.oa(a.g);
          };
          this.X = null;
          this.O = [];
          this.ra = function(a) {
            al(d, a.c);
          };
          this.W = null;
        }
        t(Q, F);
        Q.prototype.oa = function(a) {
          this.ka = a;
          Gh(this.b, a);
        };
        Q.prototype.ea = function() {
          return this.ka;
        };
        function bl(a, b) {
          a.X && E(a.X, "languageCodeChanged", a.sa);
          (a.X = b) && pc(b, "languageCodeChanged", a.sa);
        }
        function al(a, b) {
          a.O = b;
          Hh(a.b, firebase.SDK_VERSION ? qe(firebase.SDK_VERSION, a.O) : null);
        }
        Q.prototype.xa = function() {
          return Ia(this.O);
        };
        function cl(a, b) {
          a.W && E(a.W, "frameworkChanged", a.ra);
          (a.W = b) && pc(b, "frameworkChanged", a.ra);
        }
        Q.prototype.Ha = function() {
          this.w.b && (this.w.stop(), this.w.start());
        };
        function dl(a) {
          try {
            return firebase.app(a.o).auth();
          } catch (b) {
            throw new L("internal-error", "No firebase.auth.Auth instance is available for the Firebase App '" + a.o + "'!");
          }
        }
        function $k(a) {
          return new Mk(function() {
            return a.F(!0);
          }, function(a) {
            return !(!a || "auth/network-request-failed" != a.code);
          }, function() {
            var b = a.h.c - na() - 3e5;
            return 0 < b ? b : 0;
          });
        }
        function el(a) {
          a.C || a.w.b || (a.w.start(), E(a, "tokenChanged", a.V), pc(a, "tokenChanged", a.V));
        }
        function fl(a) {
          E(a, "tokenChanged", a.V);
          a.w.stop();
        }
        function Yk(a, b) {
          a.qa = b;
          J(a, "_lat", b);
        }
        function gl(a, b) {
          w(a.N, function(a) {
            return a == b;
          });
        }
        function hl(a) {
          for (var b = [], c = 0; c < a.N.length; c++) b.push(a.N[c](a));
          return ub(b).then(function() {
            return a;
          });
        }
        function il(a) {
          a.a && !a.I && (a.I = !0, a.a.subscribe(a));
        }
        function Zk(a, b) {
          K(a, {
            uid: b.uid,
            displayName: b.displayName || null,
            photoURL: b.photoURL || null,
            email: b.email || null,
            emailVerified: b.emailVerified || !1,
            phoneNumber: b.phoneNumber || null,
            isAnonymous: b.isAnonymous || !1,
            metadata: new Uk(b.createdAt, b.lastLoginAt),
            providerData: []
          });
        }
        J(Q.prototype, "providerId", "firebase");
        function jl() {}
        function kl(a) {
          return B().then(function() {
            if (a.C) throw new L("app-deleted");
          });
        }
        function ll(a) {
          return Ba(a.providerData, function(a) {
            return a.providerId;
          });
        }
        function ml(a, b) {
          b && (nl(a, b.providerId), a.providerData.push(b));
        }
        function nl(a, b) {
          w(a.providerData, function(a) {
            return a.providerId == b;
          });
        }
        function ol(a, b, c) {
          ("uid" != b || c) && a.hasOwnProperty(b) && J(a, b, c);
        }
        function pl(a, b) {
          a != b && (K(a, {
            uid: b.uid,
            displayName: b.displayName,
            photoURL: b.photoURL,
            email: b.email,
            emailVerified: b.emailVerified,
            phoneNumber: b.phoneNumber,
            isAnonymous: b.isAnonymous,
            providerData: []
          }), b.metadata ? J(a, "metadata", Vk(b.metadata)) : J(a, "metadata", new Uk()), 
          v(b.providerData, function(b) {
            ml(a, b);
          }), Sk(a.h, b.h), J(a, "refreshToken", a.h.a));
        }
        g = Q.prototype;
        g.reload = function() {
          var a = this;
          return R(this, kl(this).then(function() {
            return ql(a).then(function() {
              return hl(a);
            }).then(jl);
          }));
        };
        function ql(a) {
          return a.F().then(function(b) {
            var c = a.isAnonymous;
            return rl(a, b).then(function() {
              c || ol(a, "isAnonymous", !1);
              return b;
            });
          });
        }
        g.dc = function(a) {
          return this.F(a).then(function(a) {
            return new Lk(a);
          });
        };
        g.F = function(a) {
          var b = this;
          return R(this, kl(this).then(function() {
            return b.h.getToken(a);
          }).then(function(a) {
            if (!a) throw new L("internal-error");
            a.accessToken != b.qa && (Yk(b, a.accessToken), b.dispatchEvent(new Xk("tokenChanged")));
            ol(b, "refreshToken", a.refreshToken);
            return a.accessToken;
          }));
        };
        function sl(a, b) {
          b[M] && a.qa != b[M] && (Qk(a.h, b), a.dispatchEvent(new Xk("tokenChanged")), Yk(a, b[M]), 
          ol(a, "refreshToken", a.h.a));
        }
        function rl(a, b) {
          return P(a.b, ti, {
            idToken: b
          }).then(r(a.xc, a));
        }
        g.xc = function(a) {
          a = a.users;
          if (!a || !a.length) throw new L("internal-error");
          a = a[0];
          Zk(this, {
            uid: a.localId,
            displayName: a.displayName,
            photoURL: a.photoUrl,
            email: a.email,
            emailVerified: !!a.emailVerified,
            phoneNumber: a.phoneNumber,
            lastLoginAt: a.lastLoginAt,
            createdAt: a.createdAt
          });
          for (var b = tl(a), c = 0; c < b.length; c++) ml(this, b[c]);
          ol(this, "isAnonymous", !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
        };
        function tl(a) {
          return (a = a.providerUserInfo) && a.length ? Ba(a, function(a) {
            return new Wk(a.rawId, a.providerId, a.email, a.displayName, a.photoUrl, a.phoneNumber);
          }) : [];
        }
        g.fb = function(a) {
          var b = this, c = null;
          return R(this, a.f(this.b, this.uid).then(function(a) {
            sl(b, a);
            c = ul(b, a, "reauthenticate");
            b.i = null;
            return b.reload();
          }).then(function() {
            return c;
          }), !0);
        };
        g.yc = function(a) {
          He("firebase.User.prototype.reauthenticateWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential instead.");
          return this.fb(a).then(function() {});
        };
        function vl(a, b) {
          return ql(a).then(function() {
            if (Fa(ll(a), b)) return hl(a).then(function() {
              throw new L("provider-already-linked");
            });
          });
        }
        g.cb = function(a) {
          var b = this, c = null;
          return R(this, vl(this, a.providerId).then(function() {
            return b.F();
          }).then(function(c) {
            return a.c(b.b, c);
          }).then(function(a) {
            c = ul(b, a, "link");
            return wl(b, a);
          }).then(function() {
            return c;
          }));
        };
        g.pc = function(a) {
          He("firebase.User.prototype.linkWithCredential is deprecated. Please use firebase.User.prototype.linkAndRetrieveDataWithCredential instead.");
          return this.cb(a).then(function(a) {
            return a.user;
          });
        };
        g.qc = function(a, b) {
          var c = this;
          return R(this, vl(this, "phone").then(function() {
            return Kk(dl(c), a, b, r(c.cb, c));
          }));
        };
        g.zc = function(a, b) {
          var c = this;
          return R(this, B().then(function() {
            return Kk(dl(c), a, b, r(c.fb, c));
          }), !0);
        };
        function ul(a, b, c) {
          var d = kg(b);
          b = xf(b);
          return Ke({
            user: a,
            credential: d,
            additionalUserInfo: b,
            operationType: c
          });
        }
        function wl(a, b) {
          sl(a, b);
          return a.reload().then(function() {
            return a;
          });
        }
        g.ob = function(a) {
          var b = this;
          return R(this, this.F().then(function(c) {
            return b.b.ob(c, a);
          }).then(function(a) {
            sl(b, a);
            return b.reload();
          }));
        };
        g.Rc = function(a) {
          var b = this;
          return R(this, this.F().then(function(c) {
            return a.c(b.b, c);
          }).then(function(a) {
            sl(b, a);
            return b.reload();
          }));
        };
        g.pb = function(a) {
          var b = this;
          return R(this, this.F().then(function(c) {
            return b.b.pb(c, a);
          }).then(function(a) {
            sl(b, a);
            return b.reload();
          }));
        };
        g.qb = function(a) {
          if (void 0 === a.displayName && void 0 === a.photoURL) return kl(this);
          var b = this;
          return R(this, this.F().then(function(c) {
            return b.b.qb(c, {
              displayName: a.displayName,
              photoUrl: a.photoURL
            });
          }).then(function(a) {
            sl(b, a);
            ol(b, "displayName", a.displayName || null);
            ol(b, "photoURL", a.photoUrl || null);
            v(b.providerData, function(a) {
              "password" === a.providerId && (J(a, "displayName", b.displayName), J(a, "photoURL", b.photoURL));
            });
            return hl(b);
          }).then(jl));
        };
        g.Pc = function(a) {
          var b = this;
          return R(this, ql(this).then(function(c) {
            return Fa(ll(b), a) ? fi(b.b, c, [ a ]).then(function(a) {
              var c = {};
              v(a.providerUserInfo || [], function(a) {
                c[a.providerId] = !0;
              });
              v(ll(b), function(a) {
                c[a] || nl(b, a);
              });
              c[hg.PROVIDER_ID] || J(b, "phoneNumber", null);
              return hl(b);
            }) : hl(b).then(function() {
              throw new L("no-such-provider");
            });
          }));
        };
        g.delete = function() {
          var a = this;
          return R(this, this.F().then(function(b) {
            return P(a.b, si, {
              idToken: b
            });
          }).then(function() {
            a.dispatchEvent(new Xk("userDeleted"));
          })).then(function() {
            for (var b = 0; b < a.G.length; b++) a.G[b].cancel("app-deleted");
            bl(a, null);
            cl(a, null);
            a.G = [];
            a.C = !0;
            fl(a);
            J(a, "refreshToken", null);
            a.a && a.a.unsubscribe(a);
          });
        };
        g.ub = function(a, b) {
          return !!("linkViaPopup" == a && (this.g || null) == b && this.f || "reauthViaPopup" == a && (this.g || null) == b && this.f || "linkViaRedirect" == a && (this.aa || null) == b || "reauthViaRedirect" == a && (this.aa || null) == b);
        };
        g.ha = function(a, b, c, d) {
          "linkViaPopup" != a && "reauthViaPopup" != a || d != (this.g || null) || (c && this.v ? this.v(c) : b && !c && this.f && this.f(b), 
          this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.v);
        };
        g.wa = function(a, b) {
          return "linkViaPopup" == a && b == (this.g || null) ? r(this.zb, this) : "reauthViaPopup" == a && b == (this.g || null) ? r(this.Ab, this) : "linkViaRedirect" == a && (this.aa || null) == b ? r(this.zb, this) : "reauthViaRedirect" == a && (this.aa || null) == b ? r(this.Ab, this) : null;
        };
        g.rc = function(a) {
          var b = this;
          return xl(this, "linkViaPopup", a, function() {
            return vl(b, a.providerId).then(function() {
              return hl(b);
            });
          }, !1);
        };
        g.Ac = function(a) {
          return xl(this, "reauthViaPopup", a, function() {
            return B();
          }, !0);
        };
        function xl(a, b, c, d, e) {
          if (!te()) return C(new L("operation-not-supported-in-this-environment"));
          if (a.i && !e) return C(a.i);
          var f = wf(c.providerId), h = se(a.uid + ":::"), m = null;
          (!ve() || ke()) && a.u && c.isOAuthProvider && (m = Ri(a.u, a.l, a.o, b, c, null, h, firebase.SDK_VERSION || null));
          var p = ce(m, f && f.Ba, f && f.Aa);
          d = d().then(function() {
            yl(a);
            if (!e) return a.F().then(function() {});
          }).then(function() {
            return zk(a.a, p, b, c, h, !!m);
          }).then(function() {
            return new A(function(c, d) {
              a.ha(b, null, new L("cancelled-popup-request"), a.g || null);
              a.f = c;
              a.v = d;
              a.g = h;
              a.c = a.a.Ea(a, b, p, h);
            });
          }).then(function(a) {
            p && be(p);
            return a ? Ke(a) : null;
          }).s(function(a) {
            p && be(p);
            throw a;
          });
          return R(a, d, e);
        }
        g.sc = function(a) {
          var b = this;
          return zl(this, "linkViaRedirect", a, function() {
            return vl(b, a.providerId);
          }, !1);
        };
        g.Bc = function(a) {
          return zl(this, "reauthViaRedirect", a, function() {
            return B();
          }, !0);
        };
        function zl(a, b, c, d, e) {
          if (!te()) return C(new L("operation-not-supported-in-this-environment"));
          if (a.i && !e) return C(a.i);
          var f = null, h = se(a.uid + ":::");
          d = d().then(function() {
            yl(a);
            if (!e) return a.F().then(function() {});
          }).then(function() {
            a.aa = h;
            return hl(a);
          }).then(function(b) {
            a.ba && (b = a.ba, b = b.b.set(Al, a.D(), b.a));
            return b;
          }).then(function() {
            return a.a.Ca(b, c, h);
          }).s(function(b) {
            f = b;
            if (a.ba) return Bl(a.ba);
            throw f;
          }).then(function() {
            if (f) throw f;
          });
          return R(a, d, e);
        }
        function yl(a) {
          if (!a.a || !a.I) {
            if (a.a && !a.I) throw new L("internal-error");
            throw new L("auth-domain-config-required");
          }
        }
        g.zb = function(a, b) {
          var c = this;
          this.c && (this.c.cancel(), this.c = null);
          var d = null, e = this.F().then(function(d) {
            return Mf(c.b, {
              requestUri: a,
              sessionId: b,
              idToken: d
            });
          }).then(function(a) {
            d = ul(c, a, "link");
            return wl(c, a);
          }).then(function() {
            return d;
          });
          return R(this, e);
        };
        g.Ab = function(a, b) {
          var c = this;
          this.c && (this.c.cancel(), this.c = null);
          var d = null, e = B().then(function() {
            return If(Nf(c.b, {
              requestUri: a,
              sessionId: b
            }), c.uid);
          }).then(function(a) {
            d = ul(c, a, "reauthenticate");
            sl(c, a);
            c.i = null;
            return c.reload();
          }).then(function() {
            return d;
          });
          return R(this, e, !0);
        };
        g.ib = function(a) {
          var b = this, c = null;
          return R(this, this.F().then(function(b) {
            c = b;
            return "undefined" === typeof a || Ya(a) ? {} : jf(new $e(a));
          }).then(function(a) {
            return b.b.ib(c, a);
          }).then(function(a) {
            if (b.email != a) return b.reload();
          }).then(function() {}));
        };
        function R(a, b, c) {
          var d = Cl(a, b, c);
          a.G.push(d);
          d.ia(function() {
            Ga(a.G, d);
          });
          return d;
        }
        function Cl(a, b, c) {
          return a.i && !c ? (b.cancel(), C(a.i)) : b.s(function(b) {
            !b || "auth/user-disabled" != b.code && "auth/user-token-expired" != b.code || (a.i || a.dispatchEvent(new Xk("userInvalidated")), 
            a.i = b);
            throw b;
          });
        }
        g.toJSON = function() {
          return this.D();
        };
        g.D = function() {
          var a = {
            uid: this.uid,
            displayName: this.displayName,
            photoURL: this.photoURL,
            email: this.email,
            emailVerified: this.emailVerified,
            phoneNumber: this.phoneNumber,
            isAnonymous: this.isAnonymous,
            providerData: [],
            apiKey: this.l,
            appName: this.o,
            authDomain: this.u,
            stsTokenManager: this.h.D(),
            redirectEventId: this.aa || null
          };
          this.metadata && ab(a, this.metadata.D());
          v(this.providerData, function(b) {
            a.providerData.push(Le(b));
          });
          return a;
        };
        function Dl(a) {
          if (!a.apiKey) return null;
          var b = {
            apiKey: a.apiKey,
            authDomain: a.authDomain,
            appName: a.appName
          }, c = {};
          if (!(a.stsTokenManager && a.stsTokenManager.accessToken && a.stsTokenManager.expirationTime)) return null;
          c[M] = a.stsTokenManager.accessToken, c.refreshToken = a.stsTokenManager.refreshToken || null, 
          c.expiresIn = (a.stsTokenManager.expirationTime - na()) / 1e3;
          var d = new Q(b, c, a);
          a.providerData && v(a.providerData, function(a) {
            a && ml(d, Ke(a));
          });
          a.redirectEventId && (d.aa = a.redirectEventId);
          return d;
        }
        function El(a, b, c, d) {
          var e = new Q(a, b);
          c && (e.ba = c);
          d && al(e, d);
          return e.reload().then(function() {
            return e;
          });
        }
        function Fl(a, b, c, d) {
          b = b || {
            apiKey: a.l,
            authDomain: a.u,
            appName: a.o
          };
          var e = a.h, f = {};
          f[M] = e.b;
          f.refreshToken = e.a;
          f.expiresIn = (e.c - na()) / 1e3;
          b = new Q(b, f);
          c && (b.ba = c);
          d && al(b, d);
          pl(b, a);
          return b;
        }
        function Gl(a) {
          this.a = a;
          this.b = Dj();
        }
        var Al = {
          name: "redirectUser",
          A: "session"
        };
        function Bl(a) {
          return Hj(a.b, Al, a.a);
        }
        function Hl(a, b) {
          return a.b.get(Al, a.a).then(function(a) {
            a && b && (a.authDomain = b);
            return Dl(a || {});
          });
        }
        function Il(a) {
          this.a = a;
          this.b = Dj();
          this.c = null;
          this.f = Jl(this);
          this.b.addListener(Kl("local"), this.a, r(this.g, this));
        }
        Il.prototype.g = function() {
          var a = this, b = Kl("local");
          Ll(this, function() {
            return B().then(function() {
              return a.c && "local" != a.c.A ? a.b.get(b, a.a) : null;
            }).then(function(c) {
              if (c) return Ml(a, "local").then(function() {
                a.c = b;
              });
            });
          });
        };
        function Ml(a, b) {
          var c = [], d;
          for (d in zj) zj[d] !== b && c.push(Hj(a.b, Kl(zj[d]), a.a));
          c.push(Hj(a.b, Nl, a.a));
          return tb(c);
        }
        function Jl(a) {
          var b = Kl("local"), c = Kl("session"), d = Kl("none");
          return Gj(a.b, b, a.a).then(function() {
            return a.b.get(c, a.a);
          }).then(function(e) {
            return e ? c : a.b.get(d, a.a).then(function(c) {
              return c ? d : a.b.get(b, a.a).then(function(c) {
                return c ? b : a.b.get(Nl, a.a).then(function(a) {
                  return a ? Kl(a) : b;
                });
              });
            });
          }).then(function(b) {
            a.c = b;
            return Ml(a, b.A);
          }).s(function() {
            a.c || (a.c = b);
          });
        }
        var Nl = {
          name: "persistence",
          A: "session"
        };
        function Kl(a) {
          return {
            name: "authUser",
            A: a
          };
        }
        Il.prototype.lb = function(a) {
          var b = null, c = this;
          Aj(a);
          return Ll(this, function() {
            return a != c.c.A ? c.b.get(c.c, c.a).then(function(d) {
              b = d;
              return Ml(c, a);
            }).then(function() {
              c.c = Kl(a);
              if (b) return c.b.set(c.c, b, c.a);
            }) : B();
          });
        };
        function Ol(a) {
          return Ll(a, function() {
            return a.b.set(Nl, a.c.A, a.a);
          });
        }
        function Pl(a, b) {
          return Ll(a, function() {
            return a.b.set(a.c, b.D(), a.a);
          });
        }
        function Ql(a) {
          return Ll(a, function() {
            return Hj(a.b, a.c, a.a);
          });
        }
        function Rl(a, b) {
          return Ll(a, function() {
            return a.b.get(a.c, a.a).then(function(a) {
              a && b && (a.authDomain = b);
              return Dl(a || {});
            });
          });
        }
        function Ll(a, b) {
          a.f = a.f.then(b, b);
          return a.f;
        }
        function Sl(a) {
          this.l = !1;
          J(this, "settings", new Ik());
          J(this, "app", a);
          if (!S(this).options || !S(this).options.apiKey) throw new L("invalid-api-key");
          a = firebase.SDK_VERSION ? qe(firebase.SDK_VERSION) : null, this.b = new Ah(S(this).options && S(this).options.apiKey, xi(yi), a);
          this.N = [];
          this.o = [];
          this.I = [];
          this.Tb = firebase.INTERNAL.createSubscribe(r(this.mc, this));
          this.O = void 0;
          this.Ub = firebase.INTERNAL.createSubscribe(r(this.nc, this));
          Tl(this, null);
          this.h = new Il(S(this).options.apiKey + ":" + S(this).name);
          this.w = new Gl(S(this).options.apiKey + ":" + S(this).name);
          this.V = T(this, Ul(this));
          this.i = T(this, Vl(this));
          this.X = !1;
          this.ka = r(this.Mc, this);
          this.Ha = r(this.Z, this);
          this.qa = r(this.bc, this);
          this.ra = r(this.jc, this);
          this.sa = r(this.kc, this);
          Wl(this);
          this.INTERNAL = {};
          this.INTERNAL["delete"] = r(this.delete, this);
          this.INTERNAL.logFramework = r(this.tc, this);
          this.u = 0;
          F.call(this);
          Xl(this);
          this.G = [];
        }
        t(Sl, F);
        function Yl(a) {
          D.call(this, "languageCodeChanged");
          this.g = a;
        }
        t(Yl, D);
        function $l(a) {
          D.call(this, "frameworkChanged");
          this.c = a;
        }
        t($l, D);
        g = Sl.prototype;
        g.lb = function(a) {
          a = this.h.lb(a);
          return T(this, a);
        };
        g.oa = function(a) {
          this.W === a || this.l || (this.W = a, Gh(this.b, this.W), this.dispatchEvent(new Yl(this.ea())));
        };
        g.ea = function() {
          return this.W;
        };
        g.Sc = function() {
          var a = k.navigator;
          this.oa(a && (a.languages && a.languages[0] || a.language || a.userLanguage) || null);
        };
        g.tc = function(a) {
          this.G.push(a);
          Hh(this.b, firebase.SDK_VERSION ? qe(firebase.SDK_VERSION, this.G) : null);
          this.dispatchEvent(new $l(this.G));
        };
        g.xa = function() {
          return Ia(this.G);
        };
        function Xl(a) {
          Object.defineProperty(a, "lc", {
            get: function() {
              return this.ea();
            },
            set: function(a) {
              this.oa(a);
            },
            enumerable: !1
          });
          a.W = null;
        }
        g.toJSON = function() {
          return {
            apiKey: S(this).options.apiKey,
            authDomain: S(this).options.authDomain,
            appName: S(this).name,
            currentUser: U(this) && U(this).D()
          };
        };
        function am(a) {
          return a.Sb || C(new L("auth-domain-config-required"));
        }
        function Wl(a) {
          var b = S(a).options.authDomain, c = S(a).options.apiKey;
          b && te() && (a.Sb = a.V.then(function() {
            if (!a.l) {
              a.a = Bk(b, c, S(a).name);
              a.a.subscribe(a);
              U(a) && il(U(a));
              if (a.C) {
                il(a.C);
                var d = a.C;
                d.oa(a.ea());
                bl(d, a);
                d = a.C;
                al(d, a.G);
                cl(d, a);
                a.C = null;
              }
              return a.a;
            }
          }));
        }
        g.ub = function(a, b) {
          switch (a) {
           case "unknown":
           case "signInViaRedirect":
            return !0;

           case "signInViaPopup":
            return this.g == b && !!this.f;

           default:
            return !1;
          }
        };
        g.ha = function(a, b, c, d) {
          "signInViaPopup" == a && this.g == d && (c && this.v ? this.v(c) : b && !c && this.f && this.f(b), 
          this.c && (this.c.cancel(), this.c = null), delete this.f, delete this.v);
        };
        g.wa = function(a, b) {
          return "signInViaRedirect" == a || "signInViaPopup" == a && this.g == b && this.f ? r(this.ac, this) : null;
        };
        g.ac = function(a, b) {
          var c = this;
          a = {
            requestUri: a,
            sessionId: b
          };
          this.c && (this.c.cancel(), this.c = null);
          var d = null, e = null, f = Kf(c.b, a).then(function(a) {
            d = kg(a);
            e = xf(a);
            return a;
          });
          a = c.V.then(function() {
            return f;
          }).then(function(a) {
            return bm(c, a);
          }).then(function() {
            return Ke({
              user: U(c),
              credential: d,
              additionalUserInfo: e,
              operationType: "signIn"
            });
          });
          return T(this, a);
        };
        g.Kc = function(a) {
          if (!te()) return C(new L("operation-not-supported-in-this-environment"));
          var b = this, c = wf(a.providerId), d = se(), e = null;
          (!ve() || ke()) && S(this).options.authDomain && a.isOAuthProvider && (e = Ri(S(this).options.authDomain, S(this).options.apiKey, S(this).name, "signInViaPopup", a, null, d, firebase.SDK_VERSION || null));
          var f = ce(e, c && c.Ba, c && c.Aa);
          c = am(this).then(function(b) {
            return zk(b, f, "signInViaPopup", a, d, !!e);
          }).then(function() {
            return new A(function(a, c) {
              b.ha("signInViaPopup", null, new L("cancelled-popup-request"), b.g);
              b.f = a;
              b.v = c;
              b.g = d;
              b.c = b.a.Ea(b, "signInViaPopup", f, d);
            });
          }).then(function(a) {
            f && be(f);
            return a ? Ke(a) : null;
          }).s(function(a) {
            f && be(f);
            throw a;
          });
          return T(this, c);
        };
        g.Lc = function(a) {
          if (!te()) return C(new L("operation-not-supported-in-this-environment"));
          var b = this, c = am(this).then(function() {
            return Ol(b.h);
          }).then(function() {
            return b.a.Ca("signInViaRedirect", a);
          });
          return T(this, c);
        };
        g.fa = function() {
          if (!te()) return C(new L("operation-not-supported-in-this-environment"));
          var a = this, b = am(this).then(function() {
            return a.a.fa();
          }).then(function(a) {
            return a ? Ke(a) : null;
          });
          return T(this, b);
        };
        g.Qc = function(a) {
          if (!a) return C(new L("null-user"));
          var b = this, c = {};
          c.apiKey = S(this).options.apiKey;
          c.authDomain = S(this).options.authDomain;
          c.appName = S(this).name;
          var d = Fl(a, c, b.w, b.xa());
          return T(this, this.i.then(function() {
            if (S(b).options.apiKey != a.l) return d.reload();
          }).then(function() {
            if (U(b) && a.uid == U(b).uid) return pl(U(b), a), b.Z(a);
            Tl(b, d);
            il(d);
            return b.Z(d);
          }).then(function() {
            cm(b);
          }));
        };
        function bm(a, b) {
          var c = {};
          c.apiKey = S(a).options.apiKey;
          c.authDomain = S(a).options.authDomain;
          c.appName = S(a).name;
          return a.V.then(function() {
            return El(c, b, a.w, a.xa());
          }).then(function(b) {
            if (U(a) && b.uid == U(a).uid) return pl(U(a), b), a.Z(b);
            Tl(a, b);
            il(b);
            return a.Z(b);
          }).then(function() {
            cm(a);
          });
        }
        function Tl(a, b) {
          U(a) && (gl(U(a), a.Ha), E(U(a), "tokenChanged", a.qa), E(U(a), "userDeleted", a.ra), 
          E(U(a), "userInvalidated", a.sa), fl(U(a)));
          b && (b.N.push(a.Ha), pc(b, "tokenChanged", a.qa), pc(b, "userDeleted", a.ra), pc(b, "userInvalidated", a.sa), 
          0 < a.u && el(b));
          J(a, "currentUser", b);
          b && (b.oa(a.ea()), bl(b, a), al(b, a.G), cl(b, a));
        }
        g.mb = function() {
          var a = this, b = this.i.then(function() {
            if (!U(a)) return B();
            Tl(a, null);
            return Ql(a.h).then(function() {
              cm(a);
            });
          });
          return T(this, b);
        };
        function dm(a) {
          var b = Hl(a.w, S(a).options.authDomain).then(function(b) {
            (a.C = b) && (b.ba = a.w);
            return Bl(a.w);
          });
          return T(a, b);
        }
        function Ul(a) {
          var b = S(a).options.authDomain, c = dm(a).then(function() {
            return Rl(a.h, b);
          }).then(function(b) {
            return b ? (b.ba = a.w, a.C && (a.C.aa || null) == (b.aa || null) ? b : b.reload().then(function() {
              return Pl(a.h, b).then(function() {
                return b;
              });
            }).s(function(c) {
              return "auth/network-request-failed" == c.code ? b : Ql(a.h);
            })) : null;
          }).then(function(b) {
            Tl(a, b || null);
          });
          return T(a, c);
        }
        function Vl(a) {
          return a.V.then(function() {
            return a.fa();
          }).s(function() {}).then(function() {
            if (!a.l) return a.ka();
          }).s(function() {}).then(function() {
            if (!a.l) {
              a.X = !0;
              var b = a.h;
              b.b.addListener(Kl("local"), b.a, a.ka);
            }
          });
        }
        g.Mc = function() {
          var a = this;
          return Rl(this.h, S(this).options.authDomain).then(function(b) {
            if (!a.l) {
              var c;
              if (c = U(a) && b) {
                c = U(a).uid;
                var d = b.uid;
                c = void 0 !== c && null !== c && "" !== c && void 0 !== d && null !== d && "" !== d && c == d;
              }
              if (c) return pl(U(a), b), U(a).F();
              (U(a) || b) && (Tl(a, b), b && (il(b), b.ba = a.w), a.a && a.a.subscribe(a), cm(a));
            }
          });
        };
        g.Z = function(a) {
          return Pl(this.h, a);
        };
        g.bc = function() {
          cm(this);
          this.Z(U(this));
        };
        g.jc = function() {
          this.mb();
        };
        g.kc = function() {
          this.mb();
        };
        function em(a, b) {
          var c = null, d = null;
          return T(a, b.then(function(b) {
            c = kg(b);
            d = xf(b);
            return bm(a, b);
          }).then(function() {
            return Ke({
              user: U(a),
              credential: c,
              additionalUserInfo: d,
              operationType: "signIn"
            });
          }));
        }
        g.mc = function(a) {
          var b = this;
          this.addAuthTokenListener(function() {
            a.next(U(b));
          });
        };
        g.nc = function(a) {
          var b = this;
          fm(this, function() {
            a.next(U(b));
          });
        };
        g.vc = function(a, b, c) {
          var d = this;
          this.X && firebase.Promise.resolve().then(function() {
            n(a) ? a(U(d)) : n(a.next) && a.next(U(d));
          });
          return this.Tb(a, b, c);
        };
        g.uc = function(a, b, c) {
          var d = this;
          this.X && firebase.Promise.resolve().then(function() {
            d.O = d.getUid();
            n(a) ? a(U(d)) : n(a.next) && a.next(U(d));
          });
          return this.Ub(a, b, c);
        };
        g.cc = function(a) {
          var b = this, c = this.i.then(function() {
            return U(b) ? U(b).F(a).then(function(a) {
              return {
                accessToken: a
              };
            }) : null;
          });
          return T(this, c);
        };
        g.Mb = function(a) {
          var b = this;
          return this.i.then(function() {
            return em(b, P(b.b, vi, {
              token: a
            }));
          }).then(function(a) {
            var c = a.user;
            ol(c, "isAnonymous", !1);
            b.Z(c);
            return a;
          });
        };
        g.Ec = function(a) {
          He("firebase.auth.Auth.prototype.signInAndRetrieveDataWithCustomToken is deprecated. Please use firebase.auth.Auth.prototype.signInWithCustomToken instead.");
          return this.Mb(a);
        };
        g.Fc = function(a, b) {
          He("firebase.auth.Auth.prototype.signInAndRetrieveDataWithEmailAndPassword is deprecated. Please use firebase.auth.Auth.prototype.signInWithEmailAndPassword instead.");
          return this.Nb(a, b);
        };
        g.Nb = function(a, b) {
          var c = this;
          return this.i.then(function() {
            return em(c, P(c.b, Zf, {
              email: a,
              password: b
            }));
          });
        };
        g.wb = function(a, b) {
          var c = this;
          return this.i.then(function() {
            return em(c, P(c.b, ri, {
              email: a,
              password: b
            }));
          });
        };
        g.Wb = function(a, b) {
          He("firebase.auth.Auth.prototype.createUserAndRetrieveDataWithEmailAndPassword is deprecated. Please use firebase.auth.Auth.prototype.createUserWithEmailAndPassword instead.");
          return this.wb(a, b);
        };
        g.Hc = function(a) {
          He("firebase.auth.Auth.prototype.signInWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential instead.");
          return this.Oa(a).then(function(a) {
            return a.user;
          });
        };
        g.Oa = function(a) {
          var b = this;
          return this.i.then(function() {
            return em(b, a.ya(b.b));
          });
        };
        g.Pa = function() {
          var a = this;
          return this.i.then(function() {
            var b = U(a);
            if (b && b.isAnonymous) {
              var c = Ke({
                providerId: null,
                isNewUser: !1
              });
              return Ke({
                user: b,
                credential: null,
                additionalUserInfo: c,
                operationType: "signIn"
              });
            }
            return em(a, a.b.Pa()).then(function(b) {
              var c = b.user;
              ol(c, "isAnonymous", !0);
              a.Z(c);
              return b;
            });
          });
        };
        g.Gc = function() {
          He("firebase.auth.Auth.prototype.signInAnonymouslyAndRetrieveData is deprecated. Please use firebase.auth.Auth.prototype.signInAnonymously instead.");
          return this.Pa();
        };
        function S(a) {
          return a.app;
        }
        function U(a) {
          return a.currentUser;
        }
        g.getUid = function() {
          return U(this) && U(this).uid || null;
        };
        function gm(a) {
          return U(a) && U(a)._lat || null;
        }
        function cm(a) {
          if (a.X) {
            for (var b = 0; b < a.o.length; b++) a.o[b] && a.o[b](gm(a));
            if (a.O !== a.getUid() && a.I.length) for (a.O = a.getUid(), b = 0; b < a.I.length; b++) a.I[b] && a.I[b](gm(a));
          }
        }
        g.Vb = function(a) {
          this.addAuthTokenListener(a);
          this.u++;
          0 < this.u && U(this) && el(U(this));
        };
        g.Cc = function(a) {
          var b = this;
          v(this.o, function(c) {
            c == a && b.u--;
          });
          0 > this.u && (this.u = 0);
          0 == this.u && U(this) && fl(U(this));
          this.removeAuthTokenListener(a);
        };
        g.addAuthTokenListener = function(a) {
          var b = this;
          this.o.push(a);
          T(this, this.i.then(function() {
            b.l || Fa(b.o, a) && a(gm(b));
          }));
        };
        g.removeAuthTokenListener = function(a) {
          w(this.o, function(b) {
            return b == a;
          });
        };
        function fm(a, b) {
          a.I.push(b);
          T(a, a.i.then(function() {
            !a.l && Fa(a.I, b) && a.O !== a.getUid() && (a.O = a.getUid(), b(gm(a)));
          }));
        }
        g.delete = function() {
          this.l = !0;
          for (var a = 0; a < this.N.length; a++) this.N[a].cancel("app-deleted");
          this.N = [];
          this.h && (a = this.h, a.b.removeListener(Kl("local"), a.a, this.ka));
          this.a && (this.a.unsubscribe(this), this.a.Xa());
          return firebase.Promise.resolve();
        };
        function T(a, b) {
          a.N.push(b);
          b.ia(function() {
            Ga(a.N, b);
          });
          return b;
        }
        g.Zb = function(a) {
          He("firebase.auth.Auth.prototype.fetchProvidersForEmail is deprecated. Please use firebase.auth.Auth.prototype.fetchSignInMethodsForEmail instead.");
          return T(this, Rh(this.b, a));
        };
        g.$b = function(a) {
          return T(this, Th(this.b, a));
        };
        g.oc = function(a) {
          return !!cg(a);
        };
        g.kb = function(a, b) {
          var c = this;
          return T(this, B().then(function() {
            var a = new $e(b);
            if (!a.c) throw new L("argument-error", hf + " must be true when sending sign in link to email");
            return jf(a);
          }).then(function(b) {
            return c.b.kb(a, b);
          }).then(function() {}));
        };
        g.Tc = function(a) {
          return this.Ja(a).then(function(a) {
            return a.data.email;
          });
        };
        g.Ya = function(a, b) {
          return T(this, this.b.Ya(a, b).then(function() {}));
        };
        g.Ja = function(a) {
          return T(this, this.b.Ja(a).then(function(a) {
            return new Oe(a);
          }));
        };
        g.Va = function(a) {
          return T(this, this.b.Va(a).then(function() {}));
        };
        g.jb = function(a, b) {
          var c = this;
          return T(this, B().then(function() {
            return "undefined" === typeof b || Ya(b) ? {} : jf(new $e(b));
          }).then(function(b) {
            return c.b.jb(a, b);
          }).then(function() {}));
        };
        g.Jc = function(a, b) {
          return T(this, Kk(this, a, b, r(this.Oa, this)));
        };
        g.Ic = function(a, b) {
          var c = this;
          return T(this, B().then(function() {
            var d = bg(a, b || Vd());
            return c.Oa(d);
          }));
        };
        function hm() {}
        hm.prototype.render = function() {};
        hm.prototype.reset = function() {};
        hm.prototype.getResponse = function() {};
        hm.prototype.execute = function() {};
        function im() {
          this.a = {};
          this.b = 1e12;
        }
        var jm = null;
        im.prototype.render = function(a, b) {
          this.a[this.b.toString()] = new km(a, b);
          return this.b++;
        };
        im.prototype.reset = function(a) {
          var b = lm(this, a);
          a = mm(a);
          b && a && (b.delete(), delete this.a[a]);
        };
        im.prototype.getResponse = function(a) {
          return (a = lm(this, a)) ? a.getResponse() : null;
        };
        im.prototype.execute = function(a) {
          (a = lm(this, a)) && a.execute();
        };
        function lm(a, b) {
          return (b = mm(b)) && a.a[b] || null;
        }
        function mm(a) {
          return (a = "undefined" === typeof a ? 1e12 : a) ? a.toString() : null;
        }
        function km(a, b) {
          this.g = !1;
          this.c = b;
          this.a = this.b = null;
          this.h = "invisible" !== this.c.size;
          this.f = Id(a);
          var c = this;
          this.i = function() {
            c.execute();
          };
          this.h ? this.execute() : pc(this.f, "click", this.i);
        }
        km.prototype.getResponse = function() {
          nm(this);
          return this.b;
        };
        km.prototype.execute = function() {
          nm(this);
          var a = this;
          this.a || (this.a = setTimeout(function() {
            a.b = oe();
            var b = a.c.callback, c = a.c["expired-callback"];
            if (b) try {
              b(a.b);
            } catch (d) {}
            a.a = setTimeout(function() {
              a.a = null;
              a.b = null;
              if (c) try {
                c();
              } catch (d) {}
              a.h && a.execute();
            }, 6e4);
          }, 500));
        };
        km.prototype.delete = function() {
          nm(this);
          this.g = !0;
          clearTimeout(this.a);
          this.a = null;
          E(this.f, "click", this.i);
        };
        function nm(a) {
          if (a.g) throw Error("reCAPTCHA mock was already deleted!");
        }
        function om() {}
        om.prototype.g = function() {
          jm || (jm = new im());
          return B(jm);
        };
        om.prototype.c = function() {};
        var pm = null;
        function qm() {
          this.b = k.grecaptcha ? Infinity : 0;
          this.f = null;
          this.a = "__rcb" + Math.floor(1e6 * Math.random()).toString();
        }
        var rm = qd("https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}"), sm = new Be(3e4, 6e4);
        qm.prototype.g = function(a) {
          var b = this;
          return new A(function(c, d) {
            var e = setTimeout(function() {
              d(new L("network-request-failed"));
            }, sm.get());
            if (!k.grecaptcha || a !== b.f && !b.b) {
              k[b.a] = function() {
                if (k.grecaptcha) {
                  b.f = a;
                  var f = k.grecaptcha.render;
                  k.grecaptcha.render = function(a, c) {
                    a = f(a, c);
                    b.b++;
                    return a;
                  };
                  clearTimeout(e);
                  c(k.grecaptcha);
                } else clearTimeout(e), d(new L("internal-error"));
                delete k[b.a];
              };
              var f = ud(rm, {
                onload: b.a,
                hl: a || ""
              });
              B(sh(f)).s(function() {
                clearTimeout(e);
                d(new L("internal-error", "Unable to load external reCAPTCHA dependencies!"));
              });
            } else clearTimeout(e), c(k.grecaptcha);
          });
        };
        qm.prototype.c = function() {
          this.b--;
        };
        var tm = null;
        function um(a, b, c, d, e, f, h) {
          J(this, "type", "recaptcha");
          this.c = this.f = null;
          this.C = !1;
          this.l = b;
          this.g = null;
          h ? (pm || (pm = new om()), h = pm) : (tm || (tm = new qm()), h = tm);
          this.o = h;
          this.a = c || {
            theme: "light",
            type: "image"
          };
          this.h = [];
          if (this.a[vm]) throw new L("argument-error", "sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");
          this.i = "invisible" === this.a[wm];
          if (!k.document) throw new L("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.");
          if (!Id(b) || !this.i && Id(b).hasChildNodes()) throw new L("argument-error", "reCAPTCHA container is either not found or already contains inner elements!");
          this.u = new Ah(a, f || null, e || null);
          this.v = d || function() {
            return null;
          };
          var m = this;
          this.m = [];
          var p = this.a[xm];
          this.a[xm] = function(a) {
            ym(m, a);
            if ("function" === typeof p) p(a); else if ("string" === typeof p) {
              var b = I(p, k);
              "function" === typeof b && b(a);
            }
          };
          var z = this.a[zm];
          this.a[zm] = function() {
            ym(m, null);
            if ("function" === typeof z) z(); else if ("string" === typeof z) {
              var a = I(z, k);
              "function" === typeof a && a();
            }
          };
        }
        var xm = "callback", zm = "expired-callback", vm = "sitekey", wm = "size";
        function ym(a, b) {
          for (var c = 0; c < a.m.length; c++) try {
            a.m[c](b);
          } catch (d) {}
        }
        function Am(a, b) {
          w(a.m, function(a) {
            return a == b;
          });
        }
        function Bm(a, b) {
          a.h.push(b);
          b.ia(function() {
            Ga(a.h, b);
          });
          return b;
        }
        g = um.prototype;
        g.za = function() {
          var a = this;
          return this.f ? this.f : this.f = Bm(this, B().then(function() {
            if (ue() && !le()) return ge();
            throw new L("operation-not-supported-in-this-environment", "RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");
          }).then(function() {
            return a.o.g(a.v());
          }).then(function(b) {
            a.g = b;
            return P(a.u, ui, {});
          }).then(function(b) {
            a.a[vm] = b.recaptchaSiteKey;
          }).s(function(b) {
            a.f = null;
            throw b;
          }));
        };
        g.render = function() {
          Cm(this);
          var a = this;
          return Bm(this, this.za().then(function() {
            if (null === a.c) {
              var b = a.l;
              if (!a.i) {
                var c = Id(b);
                b = Ld("DIV");
                c.appendChild(b);
              }
              a.c = a.g.render(b, a.a);
            }
            return a.c;
          }));
        };
        g.verify = function() {
          Cm(this);
          var a = this;
          return Bm(this, this.render().then(function(b) {
            return new A(function(c) {
              var d = a.g.getResponse(b);
              if (d) c(d); else {
                var e = function(b) {
                  b && (Am(a, e), c(b));
                };
                a.m.push(e);
                a.i && a.g.execute(a.c);
              }
            });
          }));
        };
        g.reset = function() {
          Cm(this);
          null !== this.c && this.g.reset(this.c);
        };
        function Cm(a) {
          if (a.C) throw new L("internal-error", "RecaptchaVerifier instance has been destroyed.");
        }
        g.clear = function() {
          Cm(this);
          this.C = !0;
          this.o.c();
          for (var a = 0; a < this.h.length; a++) this.h[a].cancel("RecaptchaVerifier instance has been destroyed.");
          if (!this.i) {
            a = Id(this.l);
            for (var b; b = a.firstChild; ) a.removeChild(b);
          }
        };
        function Dm(a, b, c) {
          var d = !1;
          try {
            this.b = c || firebase.app();
          } catch (h) {
            throw new L("argument-error", "No firebase.app.App instance is currently initialized.");
          }
          if (!this.b.options || !this.b.options.apiKey) throw new L("invalid-api-key");
          c = this.b.options.apiKey;
          var e = this, f = null;
          try {
            f = this.b.auth().xa();
          } catch (h) {}
          try {
            d = this.b.auth().settings.appVerificationDisabledForTesting;
          } catch (h) {}
          f = firebase.SDK_VERSION ? qe(firebase.SDK_VERSION, f) : null;
          um.call(this, c, a, b, function() {
            try {
              var a = e.b.auth().ea();
            } catch (m) {
              a = null;
            }
            return a;
          }, f, xi(yi), d);
        }
        t(Dm, um);
        function Em(a, b, c, d) {
          a: {
            c = Array.prototype.slice.call(c);
            var e = 0;
            for (var f = !1, h = 0; h < b.length; h++) if (b[h].optional) f = !0; else {
              if (f) throw new L("internal-error", "Argument validator encountered a required argument after an optional argument.");
              e++;
            }
            f = b.length;
            if (c.length < e || f < c.length) d = "Expected " + (e == f ? 1 == e ? "1 argument" : e + " arguments" : e + "-" + f + " arguments") + " but got " + c.length + "."; else {
              for (e = 0; e < c.length; e++) if (f = b[e].optional && void 0 === c[e], !b[e].M(c[e]) && !f) {
                b = b[e];
                if (0 > e || e >= Fm.length) throw new L("internal-error", "Argument validator received an unsupported number of arguments.");
                c = Fm[e];
                d = (d ? "" : c + " argument ") + (b.name ? '"' + b.name + '" ' : "") + "must be " + b.K + ".";
                break a;
              }
              d = null;
            }
          }
          if (d) throw new L("argument-error", a + " failed: " + d);
        }
        var Fm = "First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");
        function V(a, b) {
          return {
            name: a || "",
            K: "a valid string",
            optional: !!b,
            M: l
          };
        }
        function Gm(a, b) {
          return {
            name: a || "",
            K: "a boolean",
            optional: !!b,
            M: ba
          };
        }
        function W(a, b) {
          return {
            name: a || "",
            K: "a valid object",
            optional: !!b,
            M: q
          };
        }
        function Hm(a, b) {
          return {
            name: a || "",
            K: "a function",
            optional: !!b,
            M: n
          };
        }
        function Im(a, b) {
          return {
            name: a || "",
            K: "null",
            optional: !!b,
            M: ea
          };
        }
        function Jm() {
          return {
            name: "",
            K: "an HTML element",
            optional: !1,
            M: function(a) {
              return !!(a && a instanceof Element);
            }
          };
        }
        function Km() {
          return {
            name: "auth",
            K: "an instance of Firebase Auth",
            optional: !0,
            M: function(a) {
              return !!(a && a instanceof Sl);
            }
          };
        }
        function Lm() {
          return {
            name: "app",
            K: "an instance of Firebase App",
            optional: !0,
            M: function(a) {
              return !!(a && a instanceof firebase.app.App);
            }
          };
        }
        function Mm(a) {
          return {
            name: a ? a + "Credential" : "credential",
            K: a ? "a valid " + a + " credential" : "a valid credential",
            optional: !1,
            M: function(b) {
              if (!b) return !1;
              var c = !a || b.providerId === a;
              return !(!b.ya || !c);
            }
          };
        }
        function Nm() {
          return {
            name: "authProvider",
            K: "a valid Auth provider",
            optional: !1,
            M: function(a) {
              return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty("isOAuthProvider"));
            }
          };
        }
        function Om() {
          return {
            name: "applicationVerifier",
            K: "an implementation of firebase.auth.ApplicationVerifier",
            optional: !1,
            M: function(a) {
              return !!(a && l(a.type) && n(a.verify));
            }
          };
        }
        function X(a, b, c, d) {
          return {
            name: c || "",
            K: a.K + " or " + b.K,
            optional: !!d,
            M: function(c) {
              return a.M(c) || b.M(c);
            }
          };
        }
        function Y(a, b) {
          for (var c in b) {
            var d = b[c].name;
            a[d] = Pm(d, a[c], b[c].j);
          }
        }
        function Qm(a, b) {
          for (var c in b) {
            var d = b[c].name;
            if (d !== c) {
              var e = b[c].sb;
              Object.defineProperty(a, d, {
                get: function() {
                  return this[c];
                },
                set: function(a) {
                  Em(d, [ e ], [ a ], !0);
                  this[c] = a;
                },
                enumerable: !0
              });
            }
          }
        }
        function Z(a, b, c, d) {
          a[b] = Pm(b, c, d);
        }
        function Pm(a, b, c) {
          function d() {
            var a = Array.prototype.slice.call(arguments);
            Em(e, c, a);
            return b.apply(this, a);
          }
          if (!c) return b;
          var e = Rm(a), f;
          for (f in b) d[f] = b[f];
          for (f in b.prototype) d.prototype[f] = b.prototype[f];
          return d;
        }
        function Rm(a) {
          a = a.split(".");
          return a[a.length - 1];
        }
        Y(Sl.prototype, {
          Va: {
            name: "applyActionCode",
            j: [ V("code") ]
          },
          Ja: {
            name: "checkActionCode",
            j: [ V("code") ]
          },
          Ya: {
            name: "confirmPasswordReset",
            j: [ V("code"), V("newPassword") ]
          },
          wb: {
            name: "createUserWithEmailAndPassword",
            j: [ V("email"), V("password") ]
          },
          Wb: {
            name: "createUserAndRetrieveDataWithEmailAndPassword",
            j: [ V("email"), V("password") ]
          },
          Zb: {
            name: "fetchProvidersForEmail",
            j: [ V("email") ]
          },
          $b: {
            name: "fetchSignInMethodsForEmail",
            j: [ V("email") ]
          },
          fa: {
            name: "getRedirectResult",
            j: []
          },
          oc: {
            name: "isSignInWithEmailLink",
            j: [ V("emailLink") ]
          },
          uc: {
            name: "onAuthStateChanged",
            j: [ X(W(), Hm(), "nextOrObserver"), Hm("opt_error", !0), Hm("opt_completed", !0) ]
          },
          vc: {
            name: "onIdTokenChanged",
            j: [ X(W(), Hm(), "nextOrObserver"), Hm("opt_error", !0), Hm("opt_completed", !0) ]
          },
          jb: {
            name: "sendPasswordResetEmail",
            j: [ V("email"), X(W("opt_actionCodeSettings", !0), Im(null, !0), "opt_actionCodeSettings", !0) ]
          },
          kb: {
            name: "sendSignInLinkToEmail",
            j: [ V("email"), W("actionCodeSettings") ]
          },
          lb: {
            name: "setPersistence",
            j: [ V("persistence") ]
          },
          Oa: {
            name: "signInAndRetrieveDataWithCredential",
            j: [ Mm() ]
          },
          Pa: {
            name: "signInAnonymously",
            j: []
          },
          Gc: {
            name: "signInAnonymouslyAndRetrieveData",
            j: []
          },
          Hc: {
            name: "signInWithCredential",
            j: [ Mm() ]
          },
          Mb: {
            name: "signInWithCustomToken",
            j: [ V("token") ]
          },
          Ec: {
            name: "signInAndRetrieveDataWithCustomToken",
            j: [ V("token") ]
          },
          Nb: {
            name: "signInWithEmailAndPassword",
            j: [ V("email"), V("password") ]
          },
          Ic: {
            name: "signInWithEmailLink",
            j: [ V("email"), V("emailLink", !0) ]
          },
          Fc: {
            name: "signInAndRetrieveDataWithEmailAndPassword",
            j: [ V("email"), V("password") ]
          },
          Jc: {
            name: "signInWithPhoneNumber",
            j: [ V("phoneNumber"), Om() ]
          },
          Kc: {
            name: "signInWithPopup",
            j: [ Nm() ]
          },
          Lc: {
            name: "signInWithRedirect",
            j: [ Nm() ]
          },
          Qc: {
            name: "updateCurrentUser",
            j: [ X(function(a) {
              return {
                name: "user",
                K: "an instance of Firebase User",
                optional: !!a,
                M: function(a) {
                  return !!(a && a instanceof Q);
                }
              };
            }(), Im(), "user") ]
          },
          mb: {
            name: "signOut",
            j: []
          },
          toJSON: {
            name: "toJSON",
            j: [ V(null, !0) ]
          },
          Sc: {
            name: "useDeviceLanguage",
            j: []
          },
          Tc: {
            name: "verifyPasswordResetCode",
            j: [ V("code") ]
          }
        });
        Qm(Sl.prototype, {
          lc: {
            name: "languageCode",
            sb: X(V(), Im(), "languageCode")
          }
        });
        Sl.Persistence = zj;
        Sl.Persistence.LOCAL = "local";
        Sl.Persistence.SESSION = "session";
        Sl.Persistence.NONE = "none";
        Y(Q.prototype, {
          delete: {
            name: "delete",
            j: []
          },
          dc: {
            name: "getIdTokenResult",
            j: [ Gm("opt_forceRefresh", !0) ]
          },
          F: {
            name: "getIdToken",
            j: [ Gm("opt_forceRefresh", !0) ]
          },
          cb: {
            name: "linkAndRetrieveDataWithCredential",
            j: [ Mm() ]
          },
          pc: {
            name: "linkWithCredential",
            j: [ Mm() ]
          },
          qc: {
            name: "linkWithPhoneNumber",
            j: [ V("phoneNumber"), Om() ]
          },
          rc: {
            name: "linkWithPopup",
            j: [ Nm() ]
          },
          sc: {
            name: "linkWithRedirect",
            j: [ Nm() ]
          },
          fb: {
            name: "reauthenticateAndRetrieveDataWithCredential",
            j: [ Mm() ]
          },
          yc: {
            name: "reauthenticateWithCredential",
            j: [ Mm() ]
          },
          zc: {
            name: "reauthenticateWithPhoneNumber",
            j: [ V("phoneNumber"), Om() ]
          },
          Ac: {
            name: "reauthenticateWithPopup",
            j: [ Nm() ]
          },
          Bc: {
            name: "reauthenticateWithRedirect",
            j: [ Nm() ]
          },
          reload: {
            name: "reload",
            j: []
          },
          ib: {
            name: "sendEmailVerification",
            j: [ X(W("opt_actionCodeSettings", !0), Im(null, !0), "opt_actionCodeSettings", !0) ]
          },
          toJSON: {
            name: "toJSON",
            j: [ V(null, !0) ]
          },
          Pc: {
            name: "unlink",
            j: [ V("provider") ]
          },
          ob: {
            name: "updateEmail",
            j: [ V("email") ]
          },
          pb: {
            name: "updatePassword",
            j: [ V("password") ]
          },
          Rc: {
            name: "updatePhoneNumber",
            j: [ Mm("phone") ]
          },
          qb: {
            name: "updateProfile",
            j: [ W("profile") ]
          }
        });
        Y(im.prototype, {
          execute: {
            name: "execute"
          },
          render: {
            name: "render"
          },
          reset: {
            name: "reset"
          },
          getResponse: {
            name: "getResponse"
          }
        });
        Y(hm.prototype, {
          execute: {
            name: "execute"
          },
          render: {
            name: "render"
          },
          reset: {
            name: "reset"
          },
          getResponse: {
            name: "getResponse"
          }
        });
        Y(A.prototype, {
          ia: {
            name: "finally"
          },
          s: {
            name: "catch"
          },
          then: {
            name: "then"
          }
        });
        Qm(Ik.prototype, {
          appVerificationDisabled: {
            name: "appVerificationDisabledForTesting",
            sb: Gm("appVerificationDisabledForTesting")
          }
        });
        Y(Jk.prototype, {
          confirm: {
            name: "confirm",
            j: [ V("verificationCode") ]
          }
        });
        Z(O, "credential", function(a, b) {
          return new Xf(a, b);
        }, [ V("email"), V("password") ]);
        Y(Pf.prototype, {
          ta: {
            name: "addScope",
            j: [ V("scope") ]
          },
          Da: {
            name: "setCustomParameters",
            j: [ W("customOAuthParameters") ]
          }
        });
        Z(Pf, "credential", Qf, [ X(V(), W(), "token") ]);
        Z(O, "credentialWithLink", bg, [ V("email"), V("emailLink") ]);
        Y(Rf.prototype, {
          ta: {
            name: "addScope",
            j: [ V("scope") ]
          },
          Da: {
            name: "setCustomParameters",
            j: [ W("customOAuthParameters") ]
          }
        });
        Z(Rf, "credential", Sf, [ X(V(), W(), "token") ]);
        Y(Tf.prototype, {
          ta: {
            name: "addScope",
            j: [ V("scope") ]
          },
          Da: {
            name: "setCustomParameters",
            j: [ W("customOAuthParameters") ]
          }
        });
        Z(Tf, "credential", Uf, [ X(V(), X(W(), Im()), "idToken"), X(V(), Im(), "accessToken", !0) ]);
        Y(Vf.prototype, {
          Da: {
            name: "setCustomParameters",
            j: [ W("customOAuthParameters") ]
          }
        });
        Z(Vf, "credential", Wf, [ X(V(), W(), "token"), V("secret", !0) ]);
        Y(N.prototype, {
          ta: {
            name: "addScope",
            j: [ V("scope") ]
          },
          credential: {
            name: "credential",
            j: [ X(V(), Im(), "idToken", !0), X(V(), Im(), "accessToken", !0) ]
          },
          Da: {
            name: "setCustomParameters",
            j: [ W("customOAuthParameters") ]
          }
        });
        Z(hg, "credential", jg, [ V("verificationId"), V("verificationCode") ]);
        Y(hg.prototype, {
          Ta: {
            name: "verifyPhoneNumber",
            j: [ V("phoneNumber"), Om() ]
          }
        });
        Y(L.prototype, {
          toJSON: {
            name: "toJSON",
            j: [ V(null, !0) ]
          }
        });
        Y(rg.prototype, {
          toJSON: {
            name: "toJSON",
            j: [ V(null, !0) ]
          }
        });
        Y(qg.prototype, {
          toJSON: {
            name: "toJSON",
            j: [ V(null, !0) ]
          }
        });
        Y(Dm.prototype, {
          clear: {
            name: "clear",
            j: []
          },
          render: {
            name: "render",
            j: []
          },
          verify: {
            name: "verify",
            j: []
          }
        });
        (function() {
          if ("undefined" === typeof firebase || !firebase.INTERNAL || !firebase.INTERNAL.registerService) throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");
          var a = {
            Auth: Sl,
            Error: L
          };
          Z(a, "EmailAuthProvider", O, []);
          Z(a, "FacebookAuthProvider", Pf, []);
          Z(a, "GithubAuthProvider", Rf, []);
          Z(a, "GoogleAuthProvider", Tf, []);
          Z(a, "TwitterAuthProvider", Vf, []);
          Z(a, "OAuthProvider", N, [ V("providerId") ]);
          Z(a, "PhoneAuthProvider", hg, [ Km() ]);
          Z(a, "RecaptchaVerifier", Dm, [ X(V(), Jm(), "recaptchaContainer"), W("recaptchaParameters", !0), Lm() ]);
          firebase.INTERNAL.registerService("auth", function(a, c) {
            a = new Sl(a);
            c({
              INTERNAL: {
                getUid: r(a.getUid, a),
                getToken: r(a.cc, a),
                addAuthTokenListener: r(a.Vb, a),
                removeAuthTokenListener: r(a.Cc, a)
              }
            });
            return a;
          }, a, function(a, c) {
            if ("create" === a) try {
              c.auth();
            } catch (d) {}
          });
          firebase.INTERNAL.extendNamespace({
            User: Q
          });
        })();
      }).call("undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "@firebase/app": 7
  } ],
  9: [ function(require, module, exports) {
    (function(process) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _interopDefault(ex) {
        return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
      }
      var util = require("@firebase/util");
      var logger = require("@firebase/logger");
      var tslib_1 = require("tslib");
      var firebase = _interopDefault(require("@firebase/app"));
      var DOMStorageWrapper = function() {
        function DOMStorageWrapper(domStorage_) {
          this.domStorage_ = domStorage_;
          this.prefix_ = "firebase:";
        }
        DOMStorageWrapper.prototype.set = function(key, value) {
          null == value ? this.domStorage_.removeItem(this.prefixedName_(key)) : this.domStorage_.setItem(this.prefixedName_(key), util.stringify(value));
        };
        DOMStorageWrapper.prototype.get = function(key) {
          var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
          return null == storedVal ? null : util.jsonEval(storedVal);
        };
        DOMStorageWrapper.prototype.remove = function(key) {
          this.domStorage_.removeItem(this.prefixedName_(key));
        };
        DOMStorageWrapper.prototype.prefixedName_ = function(name) {
          return this.prefix_ + name;
        };
        DOMStorageWrapper.prototype.toString = function() {
          return this.domStorage_.toString();
        };
        return DOMStorageWrapper;
      }();
      var MemoryStorage = function() {
        function MemoryStorage() {
          this.cache_ = {};
          this.isInMemoryStorage = true;
        }
        MemoryStorage.prototype.set = function(key, value) {
          null == value ? delete this.cache_[key] : this.cache_[key] = value;
        };
        MemoryStorage.prototype.get = function(key) {
          if (util.contains(this.cache_, key)) return this.cache_[key];
          return null;
        };
        MemoryStorage.prototype.remove = function(key) {
          delete this.cache_[key];
        };
        return MemoryStorage;
      }();
      var createStoragefor = function(domStorageName) {
        try {
          if ("undefined" !== typeof window && "undefined" !== typeof window[domStorageName]) {
            var domStorage = window[domStorageName];
            domStorage.setItem("firebase:sentinel", "cache");
            domStorage.removeItem("firebase:sentinel");
            return new DOMStorageWrapper(domStorage);
          }
        } catch (e) {}
        return new MemoryStorage();
      };
      var PersistentStorage = createStoragefor("localStorage");
      var SessionStorage = createStoragefor("sessionStorage");
      var logClient = new logger.Logger("@firebase/database");
      var LUIDGenerator = function() {
        var id = 1;
        return function() {
          return id++;
        };
      }();
      var sha1 = function(str) {
        var utf8Bytes = util.stringToByteArray(str);
        var sha1 = new util.Sha1();
        sha1.update(utf8Bytes);
        var sha1Bytes = sha1.digest();
        return util.base64.encodeByteArray(sha1Bytes);
      };
      var buildLogMessage_ = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        var message = "";
        for (var i = 0; i < var_args.length; i++) {
          Array.isArray(var_args[i]) || var_args[i] && "object" === typeof var_args[i] && "number" === typeof var_args[i].length ? message += buildLogMessage_.apply(null, var_args[i]) : "object" === typeof var_args[i] ? message += util.stringify(var_args[i]) : message += var_args[i];
          message += " ";
        }
        return message;
      };
      var logger$1 = null;
      var firstLog_ = true;
      var enableLogging = function(logger_, persistent) {
        util.assert(!persistent || true === logger_ || false === logger_, "Can't turn on custom loggers persistently.");
        if (true === logger_) {
          logClient.logLevel = logger.LogLevel.VERBOSE;
          logger$1 = logClient.log.bind(logClient);
          persistent && SessionStorage.set("logging_enabled", true);
        } else if ("function" === typeof logger_) logger$1 = logger_; else {
          logger$1 = null;
          SessionStorage.remove("logging_enabled");
        }
      };
      var log = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        if (true === firstLog_) {
          firstLog_ = false;
          null === logger$1 && true === SessionStorage.get("logging_enabled") && enableLogging(true);
        }
        if (logger$1) {
          var message = buildLogMessage_.apply(null, var_args);
          logger$1(message);
        }
      };
      var logWrapper = function(prefix) {
        return function() {
          var var_args = [];
          for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
          log.apply(void 0, [ prefix ].concat(var_args));
        };
      };
      var error = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        var message = "FIREBASE INTERNAL ERROR: " + buildLogMessage_.apply(void 0, var_args);
        logClient.error(message);
      };
      var fatal = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        var message = "FIREBASE FATAL ERROR: " + buildLogMessage_.apply(void 0, var_args);
        logClient.error(message);
        throw new Error(message);
      };
      var warn = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        var message = "FIREBASE WARNING: " + buildLogMessage_.apply(void 0, var_args);
        logClient.warn(message);
      };
      var warnIfPageIsSecure = function() {
        "undefined" !== typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
      };
      var isInvalidJSONNumber = function(data) {
        return "number" === typeof data && (data != data || data == Number.POSITIVE_INFINITY || data == Number.NEGATIVE_INFINITY);
      };
      var executeWhenDOMReady = function(fn) {
        if (util.isNodeSdk() || "complete" === document.readyState) fn(); else {
          var called_1 = false;
          var wrappedFn_1 = function() {
            if (!document.body) {
              setTimeout(wrappedFn_1, Math.floor(10));
              return;
            }
            if (!called_1) {
              called_1 = true;
              fn();
            }
          };
          if (document.addEventListener) {
            document.addEventListener("DOMContentLoaded", wrappedFn_1, false);
            window.addEventListener("load", wrappedFn_1, false);
          } else if (document.attachEvent) {
            document.attachEvent("onreadystatechange", function() {
              "complete" === document.readyState && wrappedFn_1();
            });
            window.attachEvent("onload", wrappedFn_1);
          }
        }
      };
      var MIN_NAME = "[MIN_NAME]";
      var MAX_NAME = "[MAX_NAME]";
      var nameCompare = function(a, b) {
        if (a === b) return 0;
        if (a === MIN_NAME || b === MAX_NAME) return -1;
        if (b === MIN_NAME || a === MAX_NAME) return 1;
        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        return null !== aAsInt ? null !== bAsInt ? aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt : -1 : null !== bAsInt ? 1 : a < b ? -1 : 1;
      };
      var stringCompare = function(a, b) {
        return a === b ? 0 : a < b ? -1 : 1;
      };
      var requireKey = function(key, obj) {
        if (obj && key in obj) return obj[key];
        throw new Error("Missing required key (" + key + ") in object: " + util.stringify(obj));
      };
      var ObjectToUniqueKey = function(obj) {
        if ("object" !== typeof obj || null === obj) return util.stringify(obj);
        var keys = [];
        for (var k in obj) keys.push(k);
        keys.sort();
        var key = "{";
        for (var i = 0; i < keys.length; i++) {
          0 !== i && (key += ",");
          key += util.stringify(keys[i]);
          key += ":";
          key += ObjectToUniqueKey(obj[keys[i]]);
        }
        key += "}";
        return key;
      };
      var splitStringBySize = function(str, segsize) {
        var len = str.length;
        if (len <= segsize) return [ str ];
        var dataSegs = [];
        for (var c = 0; c < len; c += segsize) c + segsize > len ? dataSegs.push(str.substring(c, len)) : dataSegs.push(str.substring(c, c + segsize));
        return dataSegs;
      };
      var each = function(obj, fn) {
        if (Array.isArray(obj)) for (var i = 0; i < obj.length; ++i) fn(i, obj[i]); else util.forEach(obj, function(key, val) {
          return fn(val, key);
        });
      };
      var doubleToIEEE754String = function(v) {
        util.assert(!isInvalidJSONNumber(v), "Invalid JSON number");
        var ebits = 11, fbits = 52;
        var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str;
        if (0 === v) {
          e = 0;
          f = 0;
          s = 1 / v === -Infinity ? 1 : 0;
        } else {
          s = v < 0;
          v = Math.abs(v);
          if (v >= Math.pow(2, 1 - bias)) {
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
          } else {
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
          }
        }
        bits = [];
        for (i = fbits; i; i -= 1) {
          bits.push(f % 2 ? 1 : 0);
          f = Math.floor(f / 2);
        }
        for (i = ebits; i; i -= 1) {
          bits.push(e % 2 ? 1 : 0);
          e = Math.floor(e / 2);
        }
        bits.push(s ? 1 : 0);
        bits.reverse();
        str = bits.join("");
        var hexByteString = "";
        for (i = 0; i < 64; i += 8) {
          var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
          1 === hexByte.length && (hexByte = "0" + hexByte);
          hexByteString += hexByte;
        }
        return hexByteString.toLowerCase();
      };
      var isChromeExtensionContentScript = function() {
        return !!("object" === typeof window && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
      };
      var isWindowsStoreApp = function() {
        return "object" === typeof Windows && "object" === typeof Windows.UI;
      };
      var errorForServerCode = function(code, query) {
        var reason = "Unknown Error";
        "too_big" === code ? reason = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" == code ? reason = "Client doesn't have permission to access the desired data." : "unavailable" == code && (reason = "The service is unavailable");
        var error = new Error(code + " at " + query.path.toString() + ": " + reason);
        error.code = code.toUpperCase();
        return error;
      };
      var INTEGER_REGEXP_ = new RegExp("^-?\\d{1,10}$");
      var tryParseInt = function(str) {
        if (INTEGER_REGEXP_.test(str)) {
          var intVal = Number(str);
          if (intVal >= -2147483648 && intVal <= 2147483647) return intVal;
        }
        return null;
      };
      var exceptionGuard = function(fn) {
        try {
          fn();
        } catch (e) {
          setTimeout(function() {
            var stack = e.stack || "";
            warn("Exception was thrown by user callback.", stack);
            throw e;
          }, Math.floor(0));
        }
      };
      var beingCrawled = function() {
        var userAgent = "object" === typeof window && window["navigator"] && window["navigator"]["userAgent"] || "";
        return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
      };
      var setTimeoutNonBlocking = function(fn, time) {
        var timeout = setTimeout(fn, time);
        "object" === typeof timeout && timeout["unref"] && timeout["unref"]();
        return timeout;
      };
      var Path = function() {
        function Path(pathOrString, pieceNum) {
          if (void 0 === pieceNum) {
            this.pieces_ = pathOrString.split("/");
            var copyTo = 0;
            for (var i = 0; i < this.pieces_.length; i++) if (this.pieces_[i].length > 0) {
              this.pieces_[copyTo] = this.pieces_[i];
              copyTo++;
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
          } else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
          }
        }
        Object.defineProperty(Path, "Empty", {
          get: function() {
            return new Path("");
          },
          enumerable: true,
          configurable: true
        });
        Path.prototype.getFront = function() {
          if (this.pieceNum_ >= this.pieces_.length) return null;
          return this.pieces_[this.pieceNum_];
        };
        Path.prototype.getLength = function() {
          return this.pieces_.length - this.pieceNum_;
        };
        Path.prototype.popFront = function() {
          var pieceNum = this.pieceNum_;
          pieceNum < this.pieces_.length && pieceNum++;
          return new Path(this.pieces_, pieceNum);
        };
        Path.prototype.getBack = function() {
          if (this.pieceNum_ < this.pieces_.length) return this.pieces_[this.pieces_.length - 1];
          return null;
        };
        Path.prototype.toString = function() {
          var pathString = "";
          for (var i = this.pieceNum_; i < this.pieces_.length; i++) "" !== this.pieces_[i] && (pathString += "/" + this.pieces_[i]);
          return pathString || "/";
        };
        Path.prototype.toUrlEncodedString = function() {
          var pathString = "";
          for (var i = this.pieceNum_; i < this.pieces_.length; i++) "" !== this.pieces_[i] && (pathString += "/" + encodeURIComponent(String(this.pieces_[i])));
          return pathString || "/";
        };
        Path.prototype.slice = function(begin) {
          void 0 === begin && (begin = 0);
          return this.pieces_.slice(this.pieceNum_ + begin);
        };
        Path.prototype.parent = function() {
          if (this.pieceNum_ >= this.pieces_.length) return null;
          var pieces = [];
          for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++) pieces.push(this.pieces_[i]);
          return new Path(pieces, 0);
        };
        Path.prototype.child = function(childPathObj) {
          var pieces = [];
          for (var i = this.pieceNum_; i < this.pieces_.length; i++) pieces.push(this.pieces_[i]);
          if (childPathObj instanceof Path) for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) pieces.push(childPathObj.pieces_[i]); else {
            var childPieces = childPathObj.split("/");
            for (var i = 0; i < childPieces.length; i++) childPieces[i].length > 0 && pieces.push(childPieces[i]);
          }
          return new Path(pieces, 0);
        };
        Path.prototype.isEmpty = function() {
          return this.pieceNum_ >= this.pieces_.length;
        };
        Path.relativePath = function(outerPath, innerPath) {
          var outer = outerPath.getFront(), inner = innerPath.getFront();
          if (null === outer) return innerPath;
          if (outer === inner) return Path.relativePath(outerPath.popFront(), innerPath.popFront());
          throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
        };
        Path.comparePaths = function(left, right) {
          var leftKeys = left.slice();
          var rightKeys = right.slice();
          for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
            var cmp = nameCompare(leftKeys[i], rightKeys[i]);
            if (0 !== cmp) return cmp;
          }
          if (leftKeys.length === rightKeys.length) return 0;
          return leftKeys.length < rightKeys.length ? -1 : 1;
        };
        Path.prototype.equals = function(other) {
          if (this.getLength() !== other.getLength()) return false;
          for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, 
          j++) if (this.pieces_[i] !== other.pieces_[j]) return false;
          return true;
        };
        Path.prototype.contains = function(other) {
          var i = this.pieceNum_;
          var j = other.pieceNum_;
          if (this.getLength() > other.getLength()) return false;
          while (i < this.pieces_.length) {
            if (this.pieces_[i] !== other.pieces_[j]) return false;
            ++i;
            ++j;
          }
          return true;
        };
        return Path;
      }();
      var ValidationPath = function() {
        function ValidationPath(path, errorPrefix_) {
          this.errorPrefix_ = errorPrefix_;
          this.parts_ = path.slice();
          this.byteLength_ = Math.max(1, this.parts_.length);
          for (var i = 0; i < this.parts_.length; i++) this.byteLength_ += util.stringLength(this.parts_[i]);
          this.checkValid_();
        }
        Object.defineProperty(ValidationPath, "MAX_PATH_DEPTH", {
          get: function() {
            return 32;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ValidationPath, "MAX_PATH_LENGTH_BYTES", {
          get: function() {
            return 768;
          },
          enumerable: true,
          configurable: true
        });
        ValidationPath.prototype.push = function(child) {
          this.parts_.length > 0 && (this.byteLength_ += 1);
          this.parts_.push(child);
          this.byteLength_ += util.stringLength(child);
          this.checkValid_();
        };
        ValidationPath.prototype.pop = function() {
          var last = this.parts_.pop();
          this.byteLength_ -= util.stringLength(last);
          this.parts_.length > 0 && (this.byteLength_ -= 1);
        };
        ValidationPath.prototype.checkValid_ = function() {
          if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) throw new Error(this.errorPrefix_ + "has a key path longer than " + ValidationPath.MAX_PATH_LENGTH_BYTES + " bytes (" + this.byteLength_ + ").");
          if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) throw new Error(this.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + ValidationPath.MAX_PATH_DEPTH + ") or object contains a cycle " + this.toErrorString());
        };
        ValidationPath.prototype.toErrorString = function() {
          if (0 == this.parts_.length) return "";
          return "in property '" + this.parts_.join(".") + "'";
        };
        return ValidationPath;
      }();
      var PROTOCOL_VERSION = "5";
      var VERSION_PARAM = "v";
      var TRANSPORT_SESSION_PARAM = "s";
      var REFERER_PARAM = "r";
      var FORGE_REF = "f";
      var FORGE_DOMAIN = "firebaseio.com";
      var LAST_SESSION_PARAM = "ls";
      var WEBSOCKET = "websocket";
      var LONG_POLLING = "long_polling";
      var RepoInfo = function() {
        function RepoInfo(host, secure, namespace, webSocketOnly, persistenceKey) {
          void 0 === persistenceKey && (persistenceKey = "");
          this.secure = secure;
          this.namespace = namespace;
          this.webSocketOnly = webSocketOnly;
          this.persistenceKey = persistenceKey;
          this.host = host.toLowerCase();
          this.domain = this.host.substr(this.host.indexOf(".") + 1);
          this.internalHost = PersistentStorage.get("host:" + host) || this.host;
        }
        RepoInfo.prototype.needsQueryParam = function() {
          return this.host !== this.internalHost || this.isCustomHost();
        };
        RepoInfo.prototype.isCacheableHost = function() {
          return "s-" === this.internalHost.substr(0, 2);
        };
        RepoInfo.prototype.isDemoHost = function() {
          return "firebaseio-demo.com" === this.domain;
        };
        RepoInfo.prototype.isCustomHost = function() {
          return "firebaseio.com" !== this.domain && "firebaseio-demo.com" !== this.domain;
        };
        RepoInfo.prototype.updateHost = function(newHost) {
          if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            this.isCacheableHost() && PersistentStorage.set("host:" + this.host, this.internalHost);
          }
        };
        RepoInfo.prototype.connectionURL = function(type, params) {
          util.assert("string" === typeof type, "typeof type must == string");
          util.assert("object" === typeof params, "typeof params must == object");
          var connURL;
          if (type === WEBSOCKET) connURL = (this.secure ? "wss://" : "ws://") + this.internalHost + "/.ws?"; else {
            if (type !== LONG_POLLING) throw new Error("Unknown connection type: " + type);
            connURL = (this.secure ? "https://" : "http://") + this.internalHost + "/.lp?";
          }
          this.needsQueryParam() && (params["ns"] = this.namespace);
          var pairs = [];
          util.forEach(params, function(key, value) {
            pairs.push(key + "=" + value);
          });
          return connURL + pairs.join("&");
        };
        RepoInfo.prototype.toString = function() {
          var str = this.toURLString();
          this.persistenceKey && (str += "<" + this.persistenceKey + ">");
          return str;
        };
        RepoInfo.prototype.toURLString = function() {
          return (this.secure ? "https://" : "http://") + this.host;
        };
        return RepoInfo;
      }();
      function decodePath(pathString) {
        var pathStringDecoded = "";
        var pieces = pathString.split("/");
        for (var i = 0; i < pieces.length; i++) if (pieces[i].length > 0) {
          var piece = pieces[i];
          try {
            piece = decodeURIComponent(piece.replace(/\+/g, " "));
          } catch (e) {}
          pathStringDecoded += "/" + piece;
        }
        return pathStringDecoded;
      }
      function decodeQuery(queryString) {
        var results = {};
        "?" === queryString.charAt(0) && (queryString = queryString.substring(1));
        for (var _i = 0, _a = queryString.split("&"); _i < _a.length; _i++) {
          var segment = _a[_i];
          if (0 === segment.length) continue;
          var kv = segment.split("=");
          2 === kv.length ? results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]) : warn("Invalid query segment '" + segment + "' in query '" + queryString + "'");
        }
        return results;
      }
      var parseRepoInfo = function(dataURL) {
        var parsedUrl = parseURL(dataURL), namespace = parsedUrl.subdomain;
        "firebase" === parsedUrl.domain && fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
        namespace && "undefined" != namespace || "localhost" === parsedUrl.domain || fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
        parsedUrl.secure || warnIfPageIsSecure();
        var webSocketOnly = "ws" === parsedUrl.scheme || "wss" === parsedUrl.scheme;
        return {
          repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),
          path: new Path(parsedUrl.pathString)
        };
      };
      var parseURL = function(dataURL) {
        var host = "", domain = "", subdomain = "", pathString = "";
        var secure = true, scheme = "https", port = 443;
        if ("string" === typeof dataURL) {
          var colonInd = dataURL.indexOf("//");
          if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
          }
          var slashInd = dataURL.indexOf("/");
          -1 === slashInd && (slashInd = dataURL.length);
          var questionMarkInd = dataURL.indexOf("?");
          -1 === questionMarkInd && (questionMarkInd = dataURL.length);
          host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
          slashInd < questionMarkInd && (pathString = decodePath(dataURL.substring(slashInd, questionMarkInd)));
          var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
          colonInd = host.indexOf(":");
          if (colonInd >= 0) {
            secure = "https" === scheme || "wss" === scheme;
            port = parseInt(host.substring(colonInd + 1), 10);
          } else colonInd = dataURL.length;
          var parts = host.split(".");
          if (3 === parts.length) {
            domain = parts[1];
            subdomain = parts[0].toLowerCase();
          } else 2 === parts.length ? domain = parts[0] : "localhost" === parts[0].slice(0, colonInd).toLowerCase() && (domain = "localhost");
          "" === subdomain && "ns" in queryParams && (subdomain = queryParams["ns"]);
        }
        return {
          host: host,
          port: port,
          domain: domain,
          subdomain: subdomain,
          secure: secure,
          scheme: scheme,
          pathString: pathString
        };
      };
      var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
      var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
      var MAX_LEAF_SIZE_ = 10485760;
      var isValidKey = function(key) {
        return "string" === typeof key && 0 !== key.length && !INVALID_KEY_REGEX_.test(key);
      };
      var isValidPathString = function(pathString) {
        return "string" === typeof pathString && 0 !== pathString.length && !INVALID_PATH_REGEX_.test(pathString);
      };
      var isValidRootPathString = function(pathString) {
        pathString && (pathString = pathString.replace(/^\/*\.info(\/|$)/, "/"));
        return isValidPathString(pathString);
      };
      var isValidPriority = function(priority) {
        return null === priority || "string" === typeof priority || "number" === typeof priority && !isInvalidJSONNumber(priority) || priority && "object" === typeof priority && util.contains(priority, ".sv");
      };
      var validateFirebaseDataArg = function(fnName, argumentNumber, data, path, optional) {
        if (optional && void 0 === data) return;
        validateFirebaseData(util.errorPrefix(fnName, argumentNumber, optional), data, path);
      };
      var validateFirebaseData = function(errorPrefix, data, path_) {
        var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
        if (void 0 === data) throw new Error(errorPrefix + "contains undefined " + path.toErrorString());
        if ("function" === typeof data) throw new Error(errorPrefix + "contains a function " + path.toErrorString() + " with contents = " + data.toString());
        if (isInvalidJSONNumber(data)) throw new Error(errorPrefix + "contains " + data.toString() + " " + path.toErrorString());
        if ("string" === typeof data && data.length > MAX_LEAF_SIZE_ / 3 && util.stringLength(data) > MAX_LEAF_SIZE_) throw new Error(errorPrefix + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + path.toErrorString() + " ('" + data.substring(0, 50) + "...')");
        if (data && "object" === typeof data) {
          var hasDotValue_1 = false, hasActualChild_1 = false;
          util.forEach(data, function(key, value) {
            if (".value" === key) hasDotValue_1 = true; else if (".priority" !== key && ".sv" !== key) {
              hasActualChild_1 = true;
              if (!isValidKey(key)) throw new Error(errorPrefix + " contains an invalid key (" + key + ") " + path.toErrorString() + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
            path.push(key);
            validateFirebaseData(errorPrefix, value, path);
            path.pop();
          });
          if (hasDotValue_1 && hasActualChild_1) throw new Error(errorPrefix + ' contains ".value" child ' + path.toErrorString() + " in addition to actual children.");
        }
      };
      var validateFirebaseMergePaths = function(errorPrefix, mergePaths) {
        var i, curPath;
        for (i = 0; i < mergePaths.length; i++) {
          curPath = mergePaths[i];
          var keys = curPath.slice();
          for (var j = 0; j < keys.length; j++) if (".priority" === keys[j] && j === keys.length - 1) ; else if (!isValidKey(keys[j])) throw new Error(errorPrefix + "contains an invalid key (" + keys[j] + ") in path " + curPath.toString() + '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
        }
        mergePaths.sort(Path.comparePaths);
        var prevPath = null;
        for (i = 0; i < mergePaths.length; i++) {
          curPath = mergePaths[i];
          if (null !== prevPath && prevPath.contains(curPath)) throw new Error(errorPrefix + "contains a path " + prevPath.toString() + " that is ancestor of another path " + curPath.toString());
          prevPath = curPath;
        }
      };
      var validateFirebaseMergeDataArg = function(fnName, argumentNumber, data, path, optional) {
        if (optional && void 0 === data) return;
        var errorPrefix = util.errorPrefix(fnName, argumentNumber, optional);
        if (!(data && "object" === typeof data) || Array.isArray(data)) throw new Error(errorPrefix + " must be an object containing the children to replace.");
        var mergePaths = [];
        util.forEach(data, function(key, value) {
          var curPath = new Path(key);
          validateFirebaseData(errorPrefix, value, path.child(curPath));
          if (".priority" === curPath.getBack() && !isValidPriority(value)) throw new Error(errorPrefix + "contains an invalid value for '" + curPath.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
          mergePaths.push(curPath);
        });
        validateFirebaseMergePaths(errorPrefix, mergePaths);
      };
      var validatePriority = function(fnName, argumentNumber, priority, optional) {
        if (optional && void 0 === priority) return;
        if (isInvalidJSONNumber(priority)) throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + "is " + priority.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
        if (!isValidPriority(priority)) throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + "must be a valid Firebase priority (a string, finite number, server value, or null).");
      };
      var validateEventType = function(fnName, argumentNumber, eventType, optional) {
        if (optional && void 0 === eventType) return;
        switch (eventType) {
         case "value":
         case "child_added":
         case "child_removed":
         case "child_changed":
         case "child_moved":
          break;

         default:
          throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
      };
      var validateKey = function(fnName, argumentNumber, key, optional) {
        if (optional && void 0 === key) return;
        if (!isValidKey(key)) throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid key = "' + key + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');
      };
      var validatePathString = function(fnName, argumentNumber, pathString, optional) {
        if (optional && void 0 === pathString) return;
        if (!isValidPathString(pathString)) throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid path = "' + pathString + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');
      };
      var validateRootPathString = function(fnName, argumentNumber, pathString, optional) {
        pathString && (pathString = pathString.replace(/^\/*\.info(\/|$)/, "/"));
        validatePathString(fnName, argumentNumber, pathString, optional);
      };
      var validateWritablePath = function(fnName, path) {
        if (".info" === path.getFront()) throw new Error(fnName + " failed = Can't modify data under /.info/");
      };
      var validateUrl = function(fnName, argumentNumber, parsedUrl) {
        var pathString = parsedUrl.path.toString();
        if (!("string" === typeof parsedUrl.repoInfo.host) || 0 === parsedUrl.repoInfo.host.length || !isValidKey(parsedUrl.repoInfo.namespace) && "localhost" !== parsedUrl.repoInfo.host.split(":")[0] || 0 !== pathString.length && !isValidRootPathString(pathString)) throw new Error(util.errorPrefix(fnName, argumentNumber, false) + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');
      };
      var validateBoolean = function(fnName, argumentNumber, bool, optional) {
        if (optional && void 0 === bool) return;
        if ("boolean" !== typeof bool) throw new Error(util.errorPrefix(fnName, argumentNumber, optional) + "must be a boolean.");
      };
      var OnDisconnect = function() {
        function OnDisconnect(repo_, path_) {
          this.repo_ = repo_;
          this.path_ = path_;
        }
        OnDisconnect.prototype.cancel = function(onComplete) {
          util.validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
          util.validateCallback("OnDisconnect.cancel", 1, onComplete, true);
          var deferred = new util.Deferred();
          this.repo_.onDisconnectCancel(this.path_, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        OnDisconnect.prototype.remove = function(onComplete) {
          util.validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
          validateWritablePath("OnDisconnect.remove", this.path_);
          util.validateCallback("OnDisconnect.remove", 1, onComplete, true);
          var deferred = new util.Deferred();
          this.repo_.onDisconnectSet(this.path_, null, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        OnDisconnect.prototype.set = function(value, onComplete) {
          util.validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
          validateWritablePath("OnDisconnect.set", this.path_);
          validateFirebaseDataArg("OnDisconnect.set", 1, value, this.path_, false);
          util.validateCallback("OnDisconnect.set", 2, onComplete, true);
          var deferred = new util.Deferred();
          this.repo_.onDisconnectSet(this.path_, value, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        OnDisconnect.prototype.setWithPriority = function(value, priority, onComplete) {
          util.validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
          validateWritablePath("OnDisconnect.setWithPriority", this.path_);
          validateFirebaseDataArg("OnDisconnect.setWithPriority", 1, value, this.path_, false);
          validatePriority("OnDisconnect.setWithPriority", 2, priority, false);
          util.validateCallback("OnDisconnect.setWithPriority", 3, onComplete, true);
          var deferred = new util.Deferred();
          this.repo_.onDisconnectSetWithPriority(this.path_, value, priority, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        OnDisconnect.prototype.update = function(objectToMerge, onComplete) {
          util.validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
          validateWritablePath("OnDisconnect.update", this.path_);
          if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) newObjectToMerge["" + i] = objectToMerge[i];
            objectToMerge = newObjectToMerge;
            warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
          }
          validateFirebaseMergeDataArg("OnDisconnect.update", 1, objectToMerge, this.path_, false);
          util.validateCallback("OnDisconnect.update", 2, onComplete, true);
          var deferred = new util.Deferred();
          this.repo_.onDisconnectUpdate(this.path_, objectToMerge, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        return OnDisconnect;
      }();
      var TransactionResult = function() {
        function TransactionResult(committed, snapshot) {
          this.committed = committed;
          this.snapshot = snapshot;
        }
        TransactionResult.prototype.toJSON = function() {
          util.validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
          return {
            committed: this.committed,
            snapshot: this.snapshot.toJSON()
          };
        };
        return TransactionResult;
      }();
      var nextPushId = function() {
        var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
        var lastPushTime = 0;
        var lastRandChars = [];
        return function(now) {
          var duplicateTime = now === lastPushTime;
          lastPushTime = now;
          var i;
          var timeStampChars = new Array(8);
          for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            now = Math.floor(now / 64);
          }
          util.assert(0 === now, "Cannot push at time == 0");
          var id = timeStampChars.join("");
          if (duplicateTime) {
            for (i = 11; i >= 0 && 63 === lastRandChars[i]; i--) lastRandChars[i] = 0;
            lastRandChars[i]++;
          } else for (i = 0; i < 12; i++) lastRandChars[i] = Math.floor(64 * Math.random());
          for (i = 0; i < 12; i++) id += PUSH_CHARS.charAt(lastRandChars[i]);
          util.assert(20 === id.length, "nextPushId: Length should be 20.");
          return id;
        };
      }();
      var NamedNode = function() {
        function NamedNode(name, node) {
          this.name = name;
          this.node = node;
        }
        NamedNode.Wrap = function(name, node) {
          return new NamedNode(name, node);
        };
        return NamedNode;
      }();
      var Index = function() {
        function Index() {}
        Index.prototype.getCompare = function() {
          return this.compare.bind(this);
        };
        Index.prototype.indexedValueChanged = function(oldNode, newNode) {
          var oldWrapped = new NamedNode(MIN_NAME, oldNode);
          var newWrapped = new NamedNode(MIN_NAME, newNode);
          return 0 !== this.compare(oldWrapped, newWrapped);
        };
        Index.prototype.minPost = function() {
          return NamedNode.MIN;
        };
        return Index;
      }();
      var __EMPTY_NODE;
      var KeyIndex = function(_super) {
        tslib_1.__extends(KeyIndex, _super);
        function KeyIndex() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(KeyIndex, "__EMPTY_NODE", {
          get: function() {
            return __EMPTY_NODE;
          },
          set: function(val) {
            __EMPTY_NODE = val;
          },
          enumerable: true,
          configurable: true
        });
        KeyIndex.prototype.compare = function(a, b) {
          return nameCompare(a.name, b.name);
        };
        KeyIndex.prototype.isDefinedOn = function(node) {
          throw util.assertionError("KeyIndex.isDefinedOn not expected to be called.");
        };
        KeyIndex.prototype.indexedValueChanged = function(oldNode, newNode) {
          return false;
        };
        KeyIndex.prototype.minPost = function() {
          return NamedNode.MIN;
        };
        KeyIndex.prototype.maxPost = function() {
          return new NamedNode(MAX_NAME, __EMPTY_NODE);
        };
        KeyIndex.prototype.makePost = function(indexValue, name) {
          util.assert("string" === typeof indexValue, "KeyIndex indexValue must always be a string.");
          return new NamedNode(indexValue, __EMPTY_NODE);
        };
        KeyIndex.prototype.toString = function() {
          return ".key";
        };
        return KeyIndex;
      }(Index);
      var KEY_INDEX = new KeyIndex();
      var MAX_NODE;
      function setMaxNode(val) {
        MAX_NODE = val;
      }
      var priorityHashText = function(priority) {
        return "number" === typeof priority ? "number:" + doubleToIEEE754String(priority) : "string:" + priority;
      };
      var validatePriorityNode = function(priorityNode) {
        if (priorityNode.isLeafNode()) {
          var val = priorityNode.val();
          util.assert("string" === typeof val || "number" === typeof val || "object" === typeof val && util.contains(val, ".sv"), "Priority must be a string or number.");
        } else util.assert(priorityNode === MAX_NODE || priorityNode.isEmpty(), "priority of unexpected type.");
        util.assert(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
      };
      var __childrenNodeConstructor;
      var LeafNode = function() {
        function LeafNode(value_, priorityNode_) {
          void 0 === priorityNode_ && (priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE);
          this.value_ = value_;
          this.priorityNode_ = priorityNode_;
          this.lazyHash_ = null;
          util.assert(void 0 !== this.value_ && null !== this.value_, "LeafNode shouldn't be created with null/undefined value.");
          validatePriorityNode(this.priorityNode_);
        }
        Object.defineProperty(LeafNode, "__childrenNodeConstructor", {
          get: function() {
            return __childrenNodeConstructor;
          },
          set: function(val) {
            __childrenNodeConstructor = val;
          },
          enumerable: true,
          configurable: true
        });
        LeafNode.prototype.isLeafNode = function() {
          return true;
        };
        LeafNode.prototype.getPriority = function() {
          return this.priorityNode_;
        };
        LeafNode.prototype.updatePriority = function(newPriorityNode) {
          return new LeafNode(this.value_, newPriorityNode);
        };
        LeafNode.prototype.getImmediateChild = function(childName) {
          return ".priority" === childName ? this.priorityNode_ : LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        };
        LeafNode.prototype.getChild = function(path) {
          return path.isEmpty() ? this : ".priority" === path.getFront() ? this.priorityNode_ : LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        };
        LeafNode.prototype.hasChild = function() {
          return false;
        };
        LeafNode.prototype.getPredecessorChildName = function(childName, childNode) {
          return null;
        };
        LeafNode.prototype.updateImmediateChild = function(childName, newChildNode) {
          return ".priority" === childName ? this.updatePriority(newChildNode) : newChildNode.isEmpty() && ".priority" !== childName ? this : LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        };
        LeafNode.prototype.updateChild = function(path, newChildNode) {
          var front = path.getFront();
          if (null === front) return newChildNode;
          if (newChildNode.isEmpty() && ".priority" !== front) return this;
          util.assert(".priority" !== front || 1 === path.getLength(), ".priority must be the last token in a path");
          return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));
        };
        LeafNode.prototype.isEmpty = function() {
          return false;
        };
        LeafNode.prototype.numChildren = function() {
          return 0;
        };
        LeafNode.prototype.forEachChild = function(index, action) {
          return false;
        };
        LeafNode.prototype.val = function(exportFormat) {
          return exportFormat && !this.getPriority().isEmpty() ? {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
          } : this.getValue();
        };
        LeafNode.prototype.hash = function() {
          if (null === this.lazyHash_) {
            var toHash = "";
            this.priorityNode_.isEmpty() || (toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":");
            var type = typeof this.value_;
            toHash += type + ":";
            toHash += "number" === type ? doubleToIEEE754String(this.value_) : this.value_;
            this.lazyHash_ = sha1(toHash);
          }
          return this.lazyHash_;
        };
        LeafNode.prototype.getValue = function() {
          return this.value_;
        };
        LeafNode.prototype.compareTo = function(other) {
          if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) return 1;
          if (other instanceof LeafNode.__childrenNodeConstructor) return -1;
          util.assert(other.isLeafNode(), "Unknown node type");
          return this.compareToLeafNode_(other);
        };
        LeafNode.prototype.compareToLeafNode_ = function(otherLeaf) {
          var otherLeafType = typeof otherLeaf.value_;
          var thisLeafType = typeof this.value_;
          var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
          var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
          util.assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
          util.assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
          return otherIndex === thisIndex ? "object" === thisLeafType ? 0 : this.value_ < otherLeaf.value_ ? -1 : this.value_ === otherLeaf.value_ ? 0 : 1 : thisIndex - otherIndex;
        };
        LeafNode.prototype.withIndex = function() {
          return this;
        };
        LeafNode.prototype.isIndexed = function() {
          return true;
        };
        LeafNode.prototype.equals = function(other) {
          if (other === this) return true;
          if (other.isLeafNode()) {
            var otherLeaf = other;
            return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
          }
          return false;
        };
        LeafNode.VALUE_TYPE_ORDER = [ "object", "boolean", "number", "string" ];
        return LeafNode;
      }();
      var nodeFromJSON;
      var MAX_NODE$1;
      function setNodeFromJSON(val) {
        nodeFromJSON = val;
      }
      function setMaxNode$1(val) {
        MAX_NODE$1 = val;
      }
      var PriorityIndex = function(_super) {
        tslib_1.__extends(PriorityIndex, _super);
        function PriorityIndex() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        PriorityIndex.prototype.compare = function(a, b) {
          var aPriority = a.node.getPriority();
          var bPriority = b.node.getPriority();
          var indexCmp = aPriority.compareTo(bPriority);
          return 0 === indexCmp ? nameCompare(a.name, b.name) : indexCmp;
        };
        PriorityIndex.prototype.isDefinedOn = function(node) {
          return !node.getPriority().isEmpty();
        };
        PriorityIndex.prototype.indexedValueChanged = function(oldNode, newNode) {
          return !oldNode.getPriority().equals(newNode.getPriority());
        };
        PriorityIndex.prototype.minPost = function() {
          return NamedNode.MIN;
        };
        PriorityIndex.prototype.maxPost = function() {
          return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
        };
        PriorityIndex.prototype.makePost = function(indexValue, name) {
          var priorityNode = nodeFromJSON(indexValue);
          return new NamedNode(name, new LeafNode("[PRIORITY-POST]", priorityNode));
        };
        PriorityIndex.prototype.toString = function() {
          return ".priority";
        };
        return PriorityIndex;
      }(Index);
      var PRIORITY_INDEX = new PriorityIndex();
      var SortedMapIterator = function() {
        function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {
          void 0 === resultGenerator_ && (resultGenerator_ = null);
          this.isReverse_ = isReverse_;
          this.resultGenerator_ = resultGenerator_;
          this.nodeStack_ = [];
          var cmp = 1;
          while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            isReverse_ && (cmp *= -1);
            if (cmp < 0) node = this.isReverse_ ? node.left : node.right; else {
              if (0 === cmp) {
                this.nodeStack_.push(node);
                break;
              }
              this.nodeStack_.push(node);
              node = this.isReverse_ ? node.right : node.left;
            }
          }
        }
        SortedMapIterator.prototype.getNext = function() {
          if (0 === this.nodeStack_.length) return null;
          var node = this.nodeStack_.pop();
          var result;
          result = this.resultGenerator_ ? this.resultGenerator_(node.key, node.value) : {
            key: node.key,
            value: node.value
          };
          if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
              this.nodeStack_.push(node);
              node = node.right;
            }
          } else {
            node = node.right;
            while (!node.isEmpty()) {
              this.nodeStack_.push(node);
              node = node.left;
            }
          }
          return result;
        };
        SortedMapIterator.prototype.hasNext = function() {
          return this.nodeStack_.length > 0;
        };
        SortedMapIterator.prototype.peek = function() {
          if (0 === this.nodeStack_.length) return null;
          var node = this.nodeStack_[this.nodeStack_.length - 1];
          return this.resultGenerator_ ? this.resultGenerator_(node.key, node.value) : {
            key: node.key,
            value: node.value
          };
        };
        return SortedMapIterator;
      }();
      var LLRBNode = function() {
        function LLRBNode(key, value, color, left, right) {
          this.key = key;
          this.value = value;
          this.color = null != color ? color : LLRBNode.RED;
          this.left = null != left ? left : SortedMap.EMPTY_NODE;
          this.right = null != right ? right : SortedMap.EMPTY_NODE;
        }
        LLRBNode.prototype.copy = function(key, value, color, left, right) {
          return new LLRBNode(null != key ? key : this.key, null != value ? value : this.value, null != color ? color : this.color, null != left ? left : this.left, null != right ? right : this.right);
        };
        LLRBNode.prototype.count = function() {
          return this.left.count() + 1 + this.right.count();
        };
        LLRBNode.prototype.isEmpty = function() {
          return false;
        };
        LLRBNode.prototype.inorderTraversal = function(action) {
          return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
        };
        LLRBNode.prototype.reverseTraversal = function(action) {
          return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
        };
        LLRBNode.prototype.min_ = function() {
          return this.left.isEmpty() ? this : this.left.min_();
        };
        LLRBNode.prototype.minKey = function() {
          return this.min_().key;
        };
        LLRBNode.prototype.maxKey = function() {
          return this.right.isEmpty() ? this.key : this.right.maxKey();
        };
        LLRBNode.prototype.insert = function(key, value, comparator) {
          var cmp, n;
          n = this;
          cmp = comparator(key, n.key);
          n = cmp < 0 ? n.copy(null, null, null, n.left.insert(key, value, comparator), null) : 0 === cmp ? n.copy(null, value, null, null, null) : n.copy(null, null, null, null, n.right.insert(key, value, comparator));
          return n.fixUp_();
        };
        LLRBNode.prototype.removeMin_ = function() {
          if (this.left.isEmpty()) return SortedMap.EMPTY_NODE;
          var n = this;
          n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_());
          n = n.copy(null, null, null, n.left.removeMin_(), null);
          return n.fixUp_();
        };
        LLRBNode.prototype.remove = function(key, comparator) {
          var n, smallest;
          n = this;
          if (comparator(key, n.key) < 0) {
            n.left.isEmpty() || n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_());
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
          } else {
            n.left.isRed_() && (n = n.rotateRight_());
            n.right.isEmpty() || n.right.isRed_() || n.right.left.isRed_() || (n = n.moveRedRight_());
            if (0 === comparator(key, n.key)) {
              if (n.right.isEmpty()) return SortedMap.EMPTY_NODE;
              smallest = n.right.min_();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
          }
          return n.fixUp_();
        };
        LLRBNode.prototype.isRed_ = function() {
          return this.color;
        };
        LLRBNode.prototype.fixUp_ = function() {
          var n = this;
          n.right.isRed_() && !n.left.isRed_() && (n = n.rotateLeft_());
          n.left.isRed_() && n.left.left.isRed_() && (n = n.rotateRight_());
          n.left.isRed_() && n.right.isRed_() && (n = n.colorFlip_());
          return n;
        };
        LLRBNode.prototype.moveRedLeft_ = function() {
          var n = this.colorFlip_();
          if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
          }
          return n;
        };
        LLRBNode.prototype.moveRedRight_ = function() {
          var n = this.colorFlip_();
          if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
          }
          return n;
        };
        LLRBNode.prototype.rotateLeft_ = function() {
          var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
          return this.right.copy(null, null, this.color, nl, null);
        };
        LLRBNode.prototype.rotateRight_ = function() {
          var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
          return this.left.copy(null, null, this.color, null, nr);
        };
        LLRBNode.prototype.colorFlip_ = function() {
          var left = this.left.copy(null, null, !this.left.color, null, null);
          var right = this.right.copy(null, null, !this.right.color, null, null);
          return this.copy(null, null, !this.color, left, right);
        };
        LLRBNode.prototype.checkMaxDepth_ = function() {
          var blackDepth = this.check_();
          return Math.pow(2, blackDepth) <= this.count() + 1;
        };
        LLRBNode.prototype.check_ = function() {
          var blackDepth;
          if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
          if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
          blackDepth = this.left.check_();
          if (blackDepth !== this.right.check_()) throw new Error("Black depths differ");
          return blackDepth + (this.isRed_() ? 0 : 1);
        };
        LLRBNode.RED = true;
        LLRBNode.BLACK = false;
        return LLRBNode;
      }();
      var LLRBEmptyNode = function() {
        function LLRBEmptyNode() {}
        LLRBEmptyNode.prototype.copy = function(key, value, color, left, right) {
          return this;
        };
        LLRBEmptyNode.prototype.insert = function(key, value, comparator) {
          return new LLRBNode(key, value, null);
        };
        LLRBEmptyNode.prototype.remove = function(key, comparator) {
          return this;
        };
        LLRBEmptyNode.prototype.count = function() {
          return 0;
        };
        LLRBEmptyNode.prototype.isEmpty = function() {
          return true;
        };
        LLRBEmptyNode.prototype.inorderTraversal = function(action) {
          return false;
        };
        LLRBEmptyNode.prototype.reverseTraversal = function(action) {
          return false;
        };
        LLRBEmptyNode.prototype.minKey = function() {
          return null;
        };
        LLRBEmptyNode.prototype.maxKey = function() {
          return null;
        };
        LLRBEmptyNode.prototype.check_ = function() {
          return 0;
        };
        LLRBEmptyNode.prototype.isRed_ = function() {
          return false;
        };
        return LLRBEmptyNode;
      }();
      var SortedMap = function() {
        function SortedMap(comparator_, root_) {
          void 0 === root_ && (root_ = SortedMap.EMPTY_NODE);
          this.comparator_ = comparator_;
          this.root_ = root_;
        }
        SortedMap.prototype.insert = function(key, value) {
          return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
        };
        SortedMap.prototype.remove = function(key) {
          return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
        };
        SortedMap.prototype.get = function(key) {
          var cmp;
          var node = this.root_;
          while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (0 === cmp) return node.value;
            cmp < 0 ? node = node.left : cmp > 0 && (node = node.right);
          }
          return null;
        };
        SortedMap.prototype.getPredecessorKey = function(key) {
          var cmp, node = this.root_, rightParent = null;
          while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (0 === cmp) {
              if (node.left.isEmpty()) return rightParent ? rightParent.key : null;
              node = node.left;
              while (!node.right.isEmpty()) node = node.right;
              return node.key;
            }
            if (cmp < 0) node = node.left; else if (cmp > 0) {
              rightParent = node;
              node = node.right;
            }
          }
          throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
        };
        SortedMap.prototype.isEmpty = function() {
          return this.root_.isEmpty();
        };
        SortedMap.prototype.count = function() {
          return this.root_.count();
        };
        SortedMap.prototype.minKey = function() {
          return this.root_.minKey();
        };
        SortedMap.prototype.maxKey = function() {
          return this.root_.maxKey();
        };
        SortedMap.prototype.inorderTraversal = function(action) {
          return this.root_.inorderTraversal(action);
        };
        SortedMap.prototype.reverseTraversal = function(action) {
          return this.root_.reverseTraversal(action);
        };
        SortedMap.prototype.getIterator = function(resultGenerator) {
          return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
        };
        SortedMap.prototype.getIteratorFrom = function(key, resultGenerator) {
          return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
        };
        SortedMap.prototype.getReverseIteratorFrom = function(key, resultGenerator) {
          return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
        };
        SortedMap.prototype.getReverseIterator = function(resultGenerator) {
          return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
        };
        SortedMap.EMPTY_NODE = new LLRBEmptyNode();
        return SortedMap;
      }();
      var LOG_2 = Math.log(2);
      var Base12Num = function() {
        function Base12Num(length) {
          var logBase2 = function(num) {
            return parseInt(Math.log(num) / LOG_2, 10);
          };
          var bitMask = function(bits) {
            return parseInt(Array(bits + 1).join("1"), 2);
          };
          this.count = logBase2(length + 1);
          this.current_ = this.count - 1;
          var mask = bitMask(this.count);
          this.bits_ = length + 1 & mask;
        }
        Base12Num.prototype.nextBitIsOne = function() {
          var result = !(this.bits_ & 1 << this.current_);
          this.current_--;
          return result;
        };
        return Base12Num;
      }();
      var buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
        childList.sort(cmp);
        var buildBalancedTree = function(low, high) {
          var length = high - low;
          var namedNode;
          var key;
          if (0 == length) return null;
          if (1 == length) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
          }
          var middle = parseInt(length / 2, 10) + low;
          var left = buildBalancedTree(low, middle);
          var right = buildBalancedTree(middle + 1, high);
          namedNode = childList[middle];
          key = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        };
        var buildFrom12Array = function(base12) {
          var node = null;
          var root = null;
          var index = childList.length;
          var buildPennant = function(chunkSize, color) {
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
          };
          var attachPennant = function(pennant) {
            if (node) {
              node.left = pennant;
              node = pennant;
            } else {
              root = pennant;
              node = pennant;
            }
          };
          for (var i = 0; i < base12.count; ++i) {
            var isOne = base12.nextBitIsOne();
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) buildPennant(chunkSize, LLRBNode.BLACK); else {
              buildPennant(chunkSize, LLRBNode.BLACK);
              buildPennant(chunkSize, LLRBNode.RED);
            }
          }
          return root;
        };
        var base12 = new Base12Num(childList.length);
        var root = buildFrom12Array(base12);
        return new SortedMap(mapSortFn || cmp, root);
      };
      var _defaultIndexMap;
      var fallbackObject = {};
      var IndexMap = function() {
        function IndexMap(indexes_, indexSet_) {
          this.indexes_ = indexes_;
          this.indexSet_ = indexSet_;
        }
        Object.defineProperty(IndexMap, "Default", {
          get: function() {
            util.assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
            _defaultIndexMap = _defaultIndexMap || new IndexMap({
              ".priority": fallbackObject
            }, {
              ".priority": PRIORITY_INDEX
            });
            return _defaultIndexMap;
          },
          enumerable: true,
          configurable: true
        });
        IndexMap.prototype.get = function(indexKey) {
          var sortedMap = util.safeGet(this.indexes_, indexKey);
          if (!sortedMap) throw new Error("No index defined for " + indexKey);
          return sortedMap === fallbackObject ? null : sortedMap;
        };
        IndexMap.prototype.hasIndex = function(indexDefinition) {
          return util.contains(this.indexSet_, indexDefinition.toString());
        };
        IndexMap.prototype.addIndex = function(indexDefinition, existingChildren) {
          util.assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
          var childList = [];
          var sawIndexedValue = false;
          var iter = existingChildren.getIterator(NamedNode.Wrap);
          var next = iter.getNext();
          while (next) {
            sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
          }
          var newIndex;
          newIndex = sawIndexedValue ? buildChildSet(childList, indexDefinition.getCompare()) : fallbackObject;
          var indexName = indexDefinition.toString();
          var newIndexSet = util.clone(this.indexSet_);
          newIndexSet[indexName] = indexDefinition;
          var newIndexes = util.clone(this.indexes_);
          newIndexes[indexName] = newIndex;
          return new IndexMap(newIndexes, newIndexSet);
        };
        IndexMap.prototype.addToIndexes = function(namedNode, existingChildren) {
          var _this = this;
          var newIndexes = util.map(this.indexes_, function(indexedChildren, indexName) {
            var index = util.safeGet(_this.indexSet_, indexName);
            util.assert(index, "Missing index implementation for " + indexName);
            if (indexedChildren === fallbackObject) {
              if (index.isDefinedOn(namedNode.node)) {
                var childList = [];
                var iter = existingChildren.getIterator(NamedNode.Wrap);
                var next = iter.getNext();
                while (next) {
                  next.name != namedNode.name && childList.push(next);
                  next = iter.getNext();
                }
                childList.push(namedNode);
                return buildChildSet(childList, index.getCompare());
              }
              return fallbackObject;
            }
            var existingSnap = existingChildren.get(namedNode.name);
            var newChildren = indexedChildren;
            existingSnap && (newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap)));
            return newChildren.insert(namedNode, namedNode.node);
          });
          return new IndexMap(newIndexes, this.indexSet_);
        };
        IndexMap.prototype.removeFromIndexes = function(namedNode, existingChildren) {
          var newIndexes = util.map(this.indexes_, function(indexedChildren) {
            if (indexedChildren === fallbackObject) return indexedChildren;
            var existingSnap = existingChildren.get(namedNode.name);
            return existingSnap ? indexedChildren.remove(new NamedNode(namedNode.name, existingSnap)) : indexedChildren;
          });
          return new IndexMap(newIndexes, this.indexSet_);
        };
        return IndexMap;
      }();
      function NAME_ONLY_COMPARATOR(left, right) {
        return nameCompare(left.name, right.name);
      }
      function NAME_COMPARATOR(left, right) {
        return nameCompare(left, right);
      }
      var EMPTY_NODE;
      var ChildrenNode = function() {
        function ChildrenNode(children_, priorityNode_, indexMap_) {
          this.children_ = children_;
          this.priorityNode_ = priorityNode_;
          this.indexMap_ = indexMap_;
          this.lazyHash_ = null;
          this.priorityNode_ && validatePriorityNode(this.priorityNode_);
          this.children_.isEmpty() && util.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
        }
        Object.defineProperty(ChildrenNode, "EMPTY_NODE", {
          get: function() {
            return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
          },
          enumerable: true,
          configurable: true
        });
        ChildrenNode.prototype.isLeafNode = function() {
          return false;
        };
        ChildrenNode.prototype.getPriority = function() {
          return this.priorityNode_ || EMPTY_NODE;
        };
        ChildrenNode.prototype.updatePriority = function(newPriorityNode) {
          return this.children_.isEmpty() ? this : new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        };
        ChildrenNode.prototype.getImmediateChild = function(childName) {
          if (".priority" === childName) return this.getPriority();
          var child = this.children_.get(childName);
          return null === child ? EMPTY_NODE : child;
        };
        ChildrenNode.prototype.getChild = function(path) {
          var front = path.getFront();
          if (null === front) return this;
          return this.getImmediateChild(front).getChild(path.popFront());
        };
        ChildrenNode.prototype.hasChild = function(childName) {
          return null !== this.children_.get(childName);
        };
        ChildrenNode.prototype.updateImmediateChild = function(childName, newChildNode) {
          util.assert(newChildNode, "We should always be passing snapshot nodes");
          if (".priority" === childName) return this.updatePriority(newChildNode);
          var namedNode = new NamedNode(childName, newChildNode);
          var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;
          if (newChildNode.isEmpty()) {
            newChildren = this.children_.remove(childName);
            newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
          } else {
            newChildren = this.children_.insert(childName, newChildNode);
            newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
          }
          newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
          return new ChildrenNode(newChildren, newPriority, newIndexMap);
        };
        ChildrenNode.prototype.updateChild = function(path, newChildNode) {
          var front = path.getFront();
          if (null === front) return newChildNode;
          util.assert(".priority" !== path.getFront() || 1 === path.getLength(), ".priority must be the last token in a path");
          var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);
          return this.updateImmediateChild(front, newImmediateChild);
        };
        ChildrenNode.prototype.isEmpty = function() {
          return this.children_.isEmpty();
        };
        ChildrenNode.prototype.numChildren = function() {
          return this.children_.count();
        };
        ChildrenNode.prototype.val = function(exportFormat) {
          if (this.isEmpty()) return null;
          var obj = {};
          var numKeys = 0, maxKey = 0, allIntegerKeys = true;
          this.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key) ? maxKey = Math.max(maxKey, Number(key)) : allIntegerKeys = false;
          });
          if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            var array = [];
            for (var key in obj) array[key] = obj[key];
            return array;
          }
          exportFormat && !this.getPriority().isEmpty() && (obj[".priority"] = this.getPriority().val());
          return obj;
        };
        ChildrenNode.prototype.hash = function() {
          if (null === this.lazyHash_) {
            var toHash_1 = "";
            this.getPriority().isEmpty() || (toHash_1 += "priority:" + priorityHashText(this.getPriority().val()) + ":");
            this.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              var childHash = childNode.hash();
              "" !== childHash && (toHash_1 += ":" + key + ":" + childHash);
            });
            this.lazyHash_ = "" === toHash_1 ? "" : sha1(toHash_1);
          }
          return this.lazyHash_;
        };
        ChildrenNode.prototype.getPredecessorChildName = function(childName, childNode, index) {
          var idx = this.resolveIndex_(index);
          if (idx) {
            var predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
          }
          return this.children_.getPredecessorKey(childName);
        };
        ChildrenNode.prototype.getFirstChildName = function(indexDefinition) {
          var idx = this.resolveIndex_(indexDefinition);
          if (idx) {
            var minKey = idx.minKey();
            return minKey && minKey.name;
          }
          return this.children_.minKey();
        };
        ChildrenNode.prototype.getFirstChild = function(indexDefinition) {
          var minKey = this.getFirstChildName(indexDefinition);
          return minKey ? new NamedNode(minKey, this.children_.get(minKey)) : null;
        };
        ChildrenNode.prototype.getLastChildName = function(indexDefinition) {
          var idx = this.resolveIndex_(indexDefinition);
          if (idx) {
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
          }
          return this.children_.maxKey();
        };
        ChildrenNode.prototype.getLastChild = function(indexDefinition) {
          var maxKey = this.getLastChildName(indexDefinition);
          return maxKey ? new NamedNode(maxKey, this.children_.get(maxKey)) : null;
        };
        ChildrenNode.prototype.forEachChild = function(index, action) {
          var idx = this.resolveIndex_(index);
          return idx ? idx.inorderTraversal(function(wrappedNode) {
            return action(wrappedNode.name, wrappedNode.node);
          }) : this.children_.inorderTraversal(action);
        };
        ChildrenNode.prototype.getIterator = function(indexDefinition) {
          return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
        };
        ChildrenNode.prototype.getIteratorFrom = function(startPost, indexDefinition) {
          var idx = this.resolveIndex_(indexDefinition);
          if (idx) return idx.getIteratorFrom(startPost, function(key) {
            return key;
          });
          var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
          var next = iterator.peek();
          while (null != next && indexDefinition.compare(next, startPost) < 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        };
        ChildrenNode.prototype.getReverseIterator = function(indexDefinition) {
          return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
        };
        ChildrenNode.prototype.getReverseIteratorFrom = function(endPost, indexDefinition) {
          var idx = this.resolveIndex_(indexDefinition);
          if (idx) return idx.getReverseIteratorFrom(endPost, function(key) {
            return key;
          });
          var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
          var next = iterator.peek();
          while (null != next && indexDefinition.compare(next, endPost) > 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        };
        ChildrenNode.prototype.compareTo = function(other) {
          return this.isEmpty() ? other.isEmpty() ? 0 : -1 : other.isLeafNode() || other.isEmpty() ? 1 : other === MAX_NODE$2 ? -1 : 0;
        };
        ChildrenNode.prototype.withIndex = function(indexDefinition) {
          if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) return this;
          var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
          return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        };
        ChildrenNode.prototype.isIndexed = function(index) {
          return index === KEY_INDEX || this.indexMap_.hasIndex(index);
        };
        ChildrenNode.prototype.equals = function(other) {
          if (other === this) return true;
          if (other.isLeafNode()) return false;
          var otherChildrenNode = other;
          if (this.getPriority().equals(otherChildrenNode.getPriority())) {
            if (this.children_.count() === otherChildrenNode.children_.count()) {
              var thisIter = this.getIterator(PRIORITY_INDEX);
              var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
              var thisCurrent = thisIter.getNext();
              var otherCurrent = otherIter.getNext();
              while (thisCurrent && otherCurrent) {
                if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) return false;
                thisCurrent = thisIter.getNext();
                otherCurrent = otherIter.getNext();
              }
              return null === thisCurrent && null === otherCurrent;
            }
            return false;
          }
          return false;
        };
        ChildrenNode.prototype.resolveIndex_ = function(indexDefinition) {
          return indexDefinition === KEY_INDEX ? null : this.indexMap_.get(indexDefinition.toString());
        };
        ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
        return ChildrenNode;
      }();
      var MaxNode = function(_super) {
        tslib_1.__extends(MaxNode, _super);
        function MaxNode() {
          return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;
        }
        MaxNode.prototype.compareTo = function(other) {
          return other === this ? 0 : 1;
        };
        MaxNode.prototype.equals = function(other) {
          return other === this;
        };
        MaxNode.prototype.getPriority = function() {
          return this;
        };
        MaxNode.prototype.getImmediateChild = function(childName) {
          return ChildrenNode.EMPTY_NODE;
        };
        MaxNode.prototype.isEmpty = function() {
          return false;
        };
        return MaxNode;
      }(ChildrenNode);
      var MAX_NODE$2 = new MaxNode();
      Object.defineProperties(NamedNode, {
        MIN: {
          value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
        },
        MAX: {
          value: new NamedNode(MAX_NAME, MAX_NODE$2)
        }
      });
      KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
      LeafNode.__childrenNodeConstructor = ChildrenNode;
      setMaxNode(MAX_NODE$2);
      setMaxNode$1(MAX_NODE$2);
      var USE_HINZE = true;
      function nodeFromJSON$1(json, priority) {
        void 0 === priority && (priority = null);
        if (null === json) return ChildrenNode.EMPTY_NODE;
        "object" === typeof json && ".priority" in json && (priority = json[".priority"]);
        util.assert(null === priority || "string" === typeof priority || "number" === typeof priority || "object" === typeof priority && ".sv" in priority, "Invalid priority type found: " + typeof priority);
        "object" === typeof json && ".value" in json && null !== json[".value"] && (json = json[".value"]);
        if ("object" !== typeof json || ".sv" in json) {
          var jsonLeaf = json;
          return new LeafNode(jsonLeaf, nodeFromJSON$1(priority));
        }
        if (json instanceof Array || !USE_HINZE) {
          var node_1 = ChildrenNode.EMPTY_NODE;
          var jsonObj_1 = json;
          util.forEach(jsonObj_1, function(key, childData) {
            if (util.contains(jsonObj_1, key) && "." !== key.substring(0, 1)) {
              var childNode = nodeFromJSON$1(childData);
              !childNode.isLeafNode() && childNode.isEmpty() || (node_1 = node_1.updateImmediateChild(key, childNode));
            }
          });
          return node_1.updatePriority(nodeFromJSON$1(priority));
        }
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj_1 = json;
        util.forEach(hinzeJsonObj_1, function(key, child) {
          if ("string" !== typeof key || "." !== key.substring(0, 1)) {
            var childNode = nodeFromJSON$1(hinzeJsonObj_1[key]);
            if (!childNode.isEmpty()) {
              childrenHavePriority_1 = childrenHavePriority_1 || !childNode.getPriority().isEmpty();
              children_1.push(new NamedNode(key, childNode));
            }
          }
        });
        if (0 == children_1.length) return ChildrenNode.EMPTY_NODE;
        var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function(namedNode) {
          return namedNode.name;
        }, NAME_COMPARATOR);
        if (childrenHavePriority_1) {
          var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());
          return new ChildrenNode(childSet, nodeFromJSON$1(priority), new IndexMap({
            ".priority": sortedChildSet
          }, {
            ".priority": PRIORITY_INDEX
          }));
        }
        return new ChildrenNode(childSet, nodeFromJSON$1(priority), IndexMap.Default);
      }
      setNodeFromJSON(nodeFromJSON$1);
      var ValueIndex = function(_super) {
        tslib_1.__extends(ValueIndex, _super);
        function ValueIndex() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ValueIndex.prototype.compare = function(a, b) {
          var indexCmp = a.node.compareTo(b.node);
          return 0 === indexCmp ? nameCompare(a.name, b.name) : indexCmp;
        };
        ValueIndex.prototype.isDefinedOn = function(node) {
          return true;
        };
        ValueIndex.prototype.indexedValueChanged = function(oldNode, newNode) {
          return !oldNode.equals(newNode);
        };
        ValueIndex.prototype.minPost = function() {
          return NamedNode.MIN;
        };
        ValueIndex.prototype.maxPost = function() {
          return NamedNode.MAX;
        };
        ValueIndex.prototype.makePost = function(indexValue, name) {
          var valueNode = nodeFromJSON$1(indexValue);
          return new NamedNode(name, valueNode);
        };
        ValueIndex.prototype.toString = function() {
          return ".value";
        };
        return ValueIndex;
      }(Index);
      var VALUE_INDEX = new ValueIndex();
      var PathIndex = function(_super) {
        tslib_1.__extends(PathIndex, _super);
        function PathIndex(indexPath_) {
          var _this = _super.call(this) || this;
          _this.indexPath_ = indexPath_;
          util.assert(!indexPath_.isEmpty() && ".priority" !== indexPath_.getFront(), "Can't create PathIndex with empty path or .priority key");
          return _this;
        }
        PathIndex.prototype.extractChild = function(snap) {
          return snap.getChild(this.indexPath_);
        };
        PathIndex.prototype.isDefinedOn = function(node) {
          return !node.getChild(this.indexPath_).isEmpty();
        };
        PathIndex.prototype.compare = function(a, b) {
          var aChild = this.extractChild(a.node);
          var bChild = this.extractChild(b.node);
          var indexCmp = aChild.compareTo(bChild);
          return 0 === indexCmp ? nameCompare(a.name, b.name) : indexCmp;
        };
        PathIndex.prototype.makePost = function(indexValue, name) {
          var valueNode = nodeFromJSON$1(indexValue);
          var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
          return new NamedNode(name, node);
        };
        PathIndex.prototype.maxPost = function() {
          var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE$2);
          return new NamedNode(MAX_NAME, node);
        };
        PathIndex.prototype.toString = function() {
          return this.indexPath_.slice().join("/");
        };
        return PathIndex;
      }(Index);
      var DataSnapshot = function() {
        function DataSnapshot(node_, ref_, index_) {
          this.node_ = node_;
          this.ref_ = ref_;
          this.index_ = index_;
        }
        DataSnapshot.prototype.val = function() {
          util.validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
          return this.node_.val();
        };
        DataSnapshot.prototype.exportVal = function() {
          util.validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
          return this.node_.val(true);
        };
        DataSnapshot.prototype.toJSON = function() {
          util.validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
          return this.exportVal();
        };
        DataSnapshot.prototype.exists = function() {
          util.validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
          return !this.node_.isEmpty();
        };
        DataSnapshot.prototype.child = function(childPathString) {
          util.validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
          childPathString = String(childPathString);
          validatePathString("DataSnapshot.child", 1, childPathString, false);
          var childPath = new Path(childPathString);
          var childRef = this.ref_.child(childPath);
          return new DataSnapshot(this.node_.getChild(childPath), childRef, PRIORITY_INDEX);
        };
        DataSnapshot.prototype.hasChild = function(childPathString) {
          util.validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
          validatePathString("DataSnapshot.hasChild", 1, childPathString, false);
          var childPath = new Path(childPathString);
          return !this.node_.getChild(childPath).isEmpty();
        };
        DataSnapshot.prototype.getPriority = function() {
          util.validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
          return this.node_.getPriority().val();
        };
        DataSnapshot.prototype.forEach = function(action) {
          var _this = this;
          util.validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
          util.validateCallback("DataSnapshot.forEach", 1, action, false);
          if (this.node_.isLeafNode()) return false;
          var childrenNode = this.node_;
          return !!childrenNode.forEachChild(this.index_, function(key, node) {
            return action(new DataSnapshot(node, _this.ref_.child(key), PRIORITY_INDEX));
          });
        };
        DataSnapshot.prototype.hasChildren = function() {
          util.validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
          return !this.node_.isLeafNode() && !this.node_.isEmpty();
        };
        Object.defineProperty(DataSnapshot.prototype, "key", {
          get: function() {
            return this.ref_.getKey();
          },
          enumerable: true,
          configurable: true
        });
        DataSnapshot.prototype.numChildren = function() {
          util.validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
          return this.node_.numChildren();
        };
        DataSnapshot.prototype.getRef = function() {
          util.validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
          return this.ref_;
        };
        Object.defineProperty(DataSnapshot.prototype, "ref", {
          get: function() {
            return this.getRef();
          },
          enumerable: true,
          configurable: true
        });
        return DataSnapshot;
      }();
      var DataEvent = function() {
        function DataEvent(eventType, eventRegistration, snapshot, prevName) {
          this.eventType = eventType;
          this.eventRegistration = eventRegistration;
          this.snapshot = snapshot;
          this.prevName = prevName;
        }
        DataEvent.prototype.getPath = function() {
          var ref = this.snapshot.getRef();
          return "value" === this.eventType ? ref.path : ref.getParent().path;
        };
        DataEvent.prototype.getEventType = function() {
          return this.eventType;
        };
        DataEvent.prototype.getEventRunner = function() {
          return this.eventRegistration.getEventRunner(this);
        };
        DataEvent.prototype.toString = function() {
          return this.getPath().toString() + ":" + this.eventType + ":" + util.stringify(this.snapshot.exportVal());
        };
        return DataEvent;
      }();
      var CancelEvent = function() {
        function CancelEvent(eventRegistration, error, path) {
          this.eventRegistration = eventRegistration;
          this.error = error;
          this.path = path;
        }
        CancelEvent.prototype.getPath = function() {
          return this.path;
        };
        CancelEvent.prototype.getEventType = function() {
          return "cancel";
        };
        CancelEvent.prototype.getEventRunner = function() {
          return this.eventRegistration.getEventRunner(this);
        };
        CancelEvent.prototype.toString = function() {
          return this.path.toString() + ":cancel";
        };
        return CancelEvent;
      }();
      var ValueEventRegistration = function() {
        function ValueEventRegistration(callback_, cancelCallback_, context_) {
          this.callback_ = callback_;
          this.cancelCallback_ = cancelCallback_;
          this.context_ = context_;
        }
        ValueEventRegistration.prototype.respondsTo = function(eventType) {
          return "value" === eventType;
        };
        ValueEventRegistration.prototype.createEvent = function(change, query) {
          var index = query.getQueryParams().getIndex();
          return new DataEvent("value", this, new DataSnapshot(change.snapshotNode, query.getRef(), index));
        };
        ValueEventRegistration.prototype.getEventRunner = function(eventData) {
          var ctx = this.context_;
          if ("cancel" === eventData.getEventType()) {
            util.assert(this.cancelCallback_, "Raising a cancel event on a listener with no cancel callback");
            var cancelCB_1 = this.cancelCallback_;
            return function() {
              cancelCB_1.call(ctx, eventData.error);
            };
          }
          var cb_1 = this.callback_;
          return function() {
            cb_1.call(ctx, eventData.snapshot);
          };
        };
        ValueEventRegistration.prototype.createCancelEvent = function(error, path) {
          return this.cancelCallback_ ? new CancelEvent(this, error, path) : null;
        };
        ValueEventRegistration.prototype.matches = function(other) {
          return other instanceof ValueEventRegistration && (!other.callback_ || !this.callback_ || other.callback_ === this.callback_ && other.context_ === this.context_);
        };
        ValueEventRegistration.prototype.hasAnyCallback = function() {
          return null !== this.callback_;
        };
        return ValueEventRegistration;
      }();
      var ChildEventRegistration = function() {
        function ChildEventRegistration(callbacks_, cancelCallback_, context_) {
          this.callbacks_ = callbacks_;
          this.cancelCallback_ = cancelCallback_;
          this.context_ = context_;
        }
        ChildEventRegistration.prototype.respondsTo = function(eventType) {
          var eventToCheck = "children_added" === eventType ? "child_added" : eventType;
          eventToCheck = "children_removed" === eventToCheck ? "child_removed" : eventToCheck;
          return util.contains(this.callbacks_, eventToCheck);
        };
        ChildEventRegistration.prototype.createCancelEvent = function(error, path) {
          return this.cancelCallback_ ? new CancelEvent(this, error, path) : null;
        };
        ChildEventRegistration.prototype.createEvent = function(change, query) {
          util.assert(null != change.childName, "Child events should have a childName.");
          var ref = query.getRef().child(change.childName);
          var index = query.getQueryParams().getIndex();
          return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, ref, index), change.prevName);
        };
        ChildEventRegistration.prototype.getEventRunner = function(eventData) {
          var ctx = this.context_;
          if ("cancel" === eventData.getEventType()) {
            util.assert(this.cancelCallback_, "Raising a cancel event on a listener with no cancel callback");
            var cancelCB_2 = this.cancelCallback_;
            return function() {
              cancelCB_2.call(ctx, eventData.error);
            };
          }
          var cb_2 = this.callbacks_[eventData.eventType];
          return function() {
            cb_2.call(ctx, eventData.snapshot, eventData.prevName);
          };
        };
        ChildEventRegistration.prototype.matches = function(other) {
          if (other instanceof ChildEventRegistration) {
            if (!this.callbacks_ || !other.callbacks_) return true;
            if (this.context_ === other.context_) {
              var otherCount = util.getCount(other.callbacks_);
              var thisCount = util.getCount(this.callbacks_);
              if (otherCount === thisCount) {
                if (1 === otherCount) {
                  var otherKey = util.getAnyKey(other.callbacks_);
                  var thisKey = util.getAnyKey(this.callbacks_);
                  return thisKey === otherKey && (!other.callbacks_[otherKey] || !this.callbacks_[thisKey] || other.callbacks_[otherKey] === this.callbacks_[thisKey]);
                }
                return util.every(this.callbacks_, function(eventType, cb) {
                  return other.callbacks_[eventType] === cb;
                });
              }
            }
          }
          return false;
        };
        ChildEventRegistration.prototype.hasAnyCallback = function() {
          return null !== this.callbacks_;
        };
        return ChildEventRegistration;
      }();
      var __referenceConstructor;
      var Query = function() {
        function Query(repo, path, queryParams_, orderByCalled_) {
          this.repo = repo;
          this.path = path;
          this.queryParams_ = queryParams_;
          this.orderByCalled_ = orderByCalled_;
        }
        Object.defineProperty(Query, "__referenceConstructor", {
          get: function() {
            util.assert(__referenceConstructor, "Reference.ts has not been loaded");
            return __referenceConstructor;
          },
          set: function(val) {
            __referenceConstructor = val;
          },
          enumerable: true,
          configurable: true
        });
        Query.validateQueryEndpoints_ = function(params) {
          var startNode = null;
          var endNode = null;
          params.hasStart() && (startNode = params.getIndexStartValue());
          params.hasEnd() && (endNode = params.getIndexEndValue());
          if (params.getIndex() === KEY_INDEX) {
            var tooManyArgsError = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().";
            var wrongArgTypeError = "Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.";
            if (params.hasStart()) {
              var startName = params.getIndexStartName();
              if (startName != MIN_NAME) throw new Error(tooManyArgsError);
              if ("string" !== typeof startNode) throw new Error(wrongArgTypeError);
            }
            if (params.hasEnd()) {
              var endName = params.getIndexEndName();
              if (endName != MAX_NAME) throw new Error(tooManyArgsError);
              if ("string" !== typeof endNode) throw new Error(wrongArgTypeError);
            }
          } else if (params.getIndex() === PRIORITY_INDEX) {
            if (null != startNode && !isValidPriority(startNode) || null != endNode && !isValidPriority(endNode)) throw new Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");
          } else {
            util.assert(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, "unknown index type.");
            if (null != startNode && "object" === typeof startNode || null != endNode && "object" === typeof endNode) throw new Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
          }
        };
        Query.validateLimit_ = function(params) {
          if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
        };
        Query.prototype.validateNoPreviousOrderByCall_ = function(fnName) {
          if (true === this.orderByCalled_) throw new Error(fnName + ": You can't combine multiple orderBy calls.");
        };
        Query.prototype.getQueryParams = function() {
          return this.queryParams_;
        };
        Query.prototype.getRef = function() {
          util.validateArgCount("Query.ref", 0, 0, arguments.length);
          return new Query.__referenceConstructor(this.repo, this.path);
        };
        Query.prototype.on = function(eventType, callback, cancelCallbackOrContext, context) {
          util.validateArgCount("Query.on", 2, 4, arguments.length);
          validateEventType("Query.on", 1, eventType, false);
          util.validateCallback("Query.on", 2, callback, false);
          var ret = Query.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
          if ("value" === eventType) this.onValueEvent(callback, ret.cancel, ret.context); else {
            var callbacks = {};
            callbacks[eventType] = callback;
            this.onChildEvent(callbacks, ret.cancel, ret.context);
          }
          return callback;
        };
        Query.prototype.onValueEvent = function(callback, cancelCallback, context) {
          var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);
          this.repo.addEventCallbackForQuery(this, container);
        };
        Query.prototype.onChildEvent = function(callbacks, cancelCallback, context) {
          var container = new ChildEventRegistration(callbacks, cancelCallback, context);
          this.repo.addEventCallbackForQuery(this, container);
        };
        Query.prototype.off = function(eventType, callback, context) {
          util.validateArgCount("Query.off", 0, 3, arguments.length);
          validateEventType("Query.off", 1, eventType, true);
          util.validateCallback("Query.off", 2, callback, true);
          util.validateContextObject("Query.off", 3, context, true);
          var container = null;
          var callbacks = null;
          if ("value" === eventType) {
            var valueCallback = callback || null;
            container = new ValueEventRegistration(valueCallback, null, context || null);
          } else if (eventType) {
            if (callback) {
              callbacks = {};
              callbacks[eventType] = callback;
            }
            container = new ChildEventRegistration(callbacks, null, context || null);
          }
          this.repo.removeEventCallbackForQuery(this, container);
        };
        Query.prototype.once = function(eventType, userCallback, cancelOrContext, context) {
          var _this = this;
          util.validateArgCount("Query.once", 1, 4, arguments.length);
          validateEventType("Query.once", 1, eventType, false);
          util.validateCallback("Query.once", 2, userCallback, true);
          var ret = Query.getCancelAndContextArgs_("Query.once", cancelOrContext, context);
          var firstCall = true;
          var deferred = new util.Deferred();
          deferred.promise.catch(function() {});
          var onceCallback = function(snapshot) {
            if (firstCall) {
              firstCall = false;
              _this.off(eventType, onceCallback);
              userCallback && userCallback.bind(ret.context)(snapshot);
              deferred.resolve(snapshot);
            }
          };
          this.on(eventType, onceCallback, function(err) {
            _this.off(eventType, onceCallback);
            ret.cancel && ret.cancel.bind(ret.context)(err);
            deferred.reject(err);
          });
          return deferred.promise;
        };
        Query.prototype.limitToFirst = function(limit) {
          util.validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
          if ("number" !== typeof limit || Math.floor(limit) !== limit || limit <= 0) throw new Error("Query.limitToFirst: First argument must be a positive integer.");
          if (this.queryParams_.hasLimit()) throw new Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
          return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);
        };
        Query.prototype.limitToLast = function(limit) {
          util.validateArgCount("Query.limitToLast", 1, 1, arguments.length);
          if ("number" !== typeof limit || Math.floor(limit) !== limit || limit <= 0) throw new Error("Query.limitToLast: First argument must be a positive integer.");
          if (this.queryParams_.hasLimit()) throw new Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");
          return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);
        };
        Query.prototype.orderByChild = function(path) {
          util.validateArgCount("Query.orderByChild", 1, 1, arguments.length);
          if ("$key" === path) throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
          if ("$priority" === path) throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
          if ("$value" === path) throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
          validatePathString("Query.orderByChild", 1, path, false);
          this.validateNoPreviousOrderByCall_("Query.orderByChild");
          var parsedPath = new Path(path);
          if (parsedPath.isEmpty()) throw new Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
          var index = new PathIndex(parsedPath);
          var newParams = this.queryParams_.orderBy(index);
          Query.validateQueryEndpoints_(newParams);
          return new Query(this.repo, this.path, newParams, true);
        };
        Query.prototype.orderByKey = function() {
          util.validateArgCount("Query.orderByKey", 0, 0, arguments.length);
          this.validateNoPreviousOrderByCall_("Query.orderByKey");
          var newParams = this.queryParams_.orderBy(KEY_INDEX);
          Query.validateQueryEndpoints_(newParams);
          return new Query(this.repo, this.path, newParams, true);
        };
        Query.prototype.orderByPriority = function() {
          util.validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
          this.validateNoPreviousOrderByCall_("Query.orderByPriority");
          var newParams = this.queryParams_.orderBy(PRIORITY_INDEX);
          Query.validateQueryEndpoints_(newParams);
          return new Query(this.repo, this.path, newParams, true);
        };
        Query.prototype.orderByValue = function() {
          util.validateArgCount("Query.orderByValue", 0, 0, arguments.length);
          this.validateNoPreviousOrderByCall_("Query.orderByValue");
          var newParams = this.queryParams_.orderBy(VALUE_INDEX);
          Query.validateQueryEndpoints_(newParams);
          return new Query(this.repo, this.path, newParams, true);
        };
        Query.prototype.startAt = function(value, name) {
          void 0 === value && (value = null);
          util.validateArgCount("Query.startAt", 0, 2, arguments.length);
          validateFirebaseDataArg("Query.startAt", 1, value, this.path, true);
          validateKey("Query.startAt", 2, name, true);
          var newParams = this.queryParams_.startAt(value, name);
          Query.validateLimit_(newParams);
          Query.validateQueryEndpoints_(newParams);
          if (this.queryParams_.hasStart()) throw new Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");
          if (void 0 === value) {
            value = null;
            name = null;
          }
          return new Query(this.repo, this.path, newParams, this.orderByCalled_);
        };
        Query.prototype.endAt = function(value, name) {
          void 0 === value && (value = null);
          util.validateArgCount("Query.endAt", 0, 2, arguments.length);
          validateFirebaseDataArg("Query.endAt", 1, value, this.path, true);
          validateKey("Query.endAt", 2, name, true);
          var newParams = this.queryParams_.endAt(value, name);
          Query.validateLimit_(newParams);
          Query.validateQueryEndpoints_(newParams);
          if (this.queryParams_.hasEnd()) throw new Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");
          return new Query(this.repo, this.path, newParams, this.orderByCalled_);
        };
        Query.prototype.equalTo = function(value, name) {
          util.validateArgCount("Query.equalTo", 1, 2, arguments.length);
          validateFirebaseDataArg("Query.equalTo", 1, value, this.path, false);
          validateKey("Query.equalTo", 2, name, true);
          if (this.queryParams_.hasStart()) throw new Error("Query.equalTo: Starting point was already set (by another call to startAt or equalTo).");
          if (this.queryParams_.hasEnd()) throw new Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");
          return this.startAt(value, name).endAt(value, name);
        };
        Query.prototype.toString = function() {
          util.validateArgCount("Query.toString", 0, 0, arguments.length);
          return this.repo.toString() + this.path.toUrlEncodedString();
        };
        Query.prototype.toJSON = function() {
          util.validateArgCount("Query.toJSON", 0, 1, arguments.length);
          return this.toString();
        };
        Query.prototype.queryObject = function() {
          return this.queryParams_.getQueryObject();
        };
        Query.prototype.queryIdentifier = function() {
          var obj = this.queryObject();
          var id = ObjectToUniqueKey(obj);
          return "{}" === id ? "default" : id;
        };
        Query.prototype.isEqual = function(other) {
          util.validateArgCount("Query.isEqual", 1, 1, arguments.length);
          if (!(other instanceof Query)) {
            var error$$1 = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
            throw new Error(error$$1);
          }
          var sameRepo = this.repo === other.repo;
          var samePath = this.path.equals(other.path);
          var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
          return sameRepo && samePath && sameQueryIdentifier;
        };
        Query.getCancelAndContextArgs_ = function(fnName, cancelOrContext, context) {
          var ret = {
            cancel: null,
            context: null
          };
          if (cancelOrContext && context) {
            ret.cancel = cancelOrContext;
            util.validateCallback(fnName, 3, ret.cancel, true);
            ret.context = context;
            util.validateContextObject(fnName, 4, ret.context, true);
          } else if (cancelOrContext) if ("object" === typeof cancelOrContext && null !== cancelOrContext) ret.context = cancelOrContext; else {
            if ("function" !== typeof cancelOrContext) throw new Error(util.errorPrefix(fnName, 3, true) + " must either be a cancel callback or a context object.");
            ret.cancel = cancelOrContext;
          }
          return ret;
        };
        Object.defineProperty(Query.prototype, "ref", {
          get: function() {
            return this.getRef();
          },
          enumerable: true,
          configurable: true
        });
        return Query;
      }();
      var CountedSet = function() {
        function CountedSet() {
          this.set = {};
        }
        CountedSet.prototype.add = function(item, val) {
          this.set[item] = null === val || val;
        };
        CountedSet.prototype.contains = function(key) {
          return util.contains(this.set, key);
        };
        CountedSet.prototype.get = function(item) {
          return this.contains(item) ? this.set[item] : void 0;
        };
        CountedSet.prototype.remove = function(item) {
          delete this.set[item];
        };
        CountedSet.prototype.clear = function() {
          this.set = {};
        };
        CountedSet.prototype.isEmpty = function() {
          return util.isEmpty(this.set);
        };
        CountedSet.prototype.count = function() {
          return util.getCount(this.set);
        };
        CountedSet.prototype.each = function(fn) {
          util.forEach(this.set, function(k, v) {
            return fn(k, v);
          });
        };
        CountedSet.prototype.keys = function() {
          var keys = [];
          util.forEach(this.set, function(k) {
            keys.push(k);
          });
          return keys;
        };
        return CountedSet;
      }();
      var SparseSnapshotTree = function() {
        function SparseSnapshotTree() {
          this.value_ = null;
          this.children_ = null;
        }
        SparseSnapshotTree.prototype.find = function(path) {
          if (null != this.value_) return this.value_.getChild(path);
          if (path.isEmpty() || null == this.children_) return null;
          var childKey = path.getFront();
          path = path.popFront();
          if (this.children_.contains(childKey)) {
            var childTree = this.children_.get(childKey);
            return childTree.find(path);
          }
          return null;
        };
        SparseSnapshotTree.prototype.remember = function(path, data) {
          if (path.isEmpty()) {
            this.value_ = data;
            this.children_ = null;
          } else if (null !== this.value_) this.value_ = this.value_.updateChild(path, data); else {
            null == this.children_ && (this.children_ = new CountedSet());
            var childKey = path.getFront();
            this.children_.contains(childKey) || this.children_.add(childKey, new SparseSnapshotTree());
            var child = this.children_.get(childKey);
            path = path.popFront();
            child.remember(path, data);
          }
        };
        SparseSnapshotTree.prototype.forget = function(path) {
          if (path.isEmpty()) {
            this.value_ = null;
            this.children_ = null;
            return true;
          }
          if (null !== this.value_) {
            if (this.value_.isLeafNode()) return false;
            var value = this.value_;
            this.value_ = null;
            var self_1 = this;
            value.forEachChild(PRIORITY_INDEX, function(key, tree) {
              self_1.remember(new Path(key), tree);
            });
            return this.forget(path);
          }
          if (null !== this.children_) {
            var childKey = path.getFront();
            path = path.popFront();
            if (this.children_.contains(childKey)) {
              var safeToRemove = this.children_.get(childKey).forget(path);
              safeToRemove && this.children_.remove(childKey);
            }
            if (this.children_.isEmpty()) {
              this.children_ = null;
              return true;
            }
            return false;
          }
          return true;
        };
        SparseSnapshotTree.prototype.forEachTree = function(prefixPath, func) {
          null !== this.value_ ? func(prefixPath, this.value_) : this.forEachChild(function(key, tree) {
            var path = new Path(prefixPath.toString() + "/" + key);
            tree.forEachTree(path, func);
          });
        };
        SparseSnapshotTree.prototype.forEachChild = function(func) {
          null !== this.children_ && this.children_.each(function(key, tree) {
            func(key, tree);
          });
        };
        return SparseSnapshotTree;
      }();
      var generateWithValues = function(values) {
        values = values || {};
        values["timestamp"] = values["timestamp"] || new Date().getTime();
        return values;
      };
      var resolveDeferredValue = function(value, serverValues) {
        if (value && "object" === typeof value) {
          util.assert(".sv" in value, "Unexpected leaf node or priority contents");
          return serverValues[value[".sv"]];
        }
        return value;
      };
      var resolveDeferredValueTree = function(tree, serverValues) {
        var resolvedTree = new SparseSnapshotTree();
        tree.forEachTree(new Path(""), function(path, node) {
          resolvedTree.remember(path, resolveDeferredValueSnapshot(node, serverValues));
        });
        return resolvedTree;
      };
      var resolveDeferredValueSnapshot = function(node, serverValues) {
        var rawPri = node.getPriority().val();
        var priority = resolveDeferredValue(rawPri, serverValues);
        var newNode;
        if (node.isLeafNode()) {
          var leafNode = node;
          var value = resolveDeferredValue(leafNode.getValue(), serverValues);
          return value !== leafNode.getValue() || priority !== leafNode.getPriority().val() ? new LeafNode(value, nodeFromJSON$1(priority)) : node;
        }
        var childrenNode = node;
        newNode = childrenNode;
        priority !== childrenNode.getPriority().val() && (newNode = newNode.updatePriority(new LeafNode(priority)));
        childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
          var newChildNode = resolveDeferredValueSnapshot(childNode, serverValues);
          newChildNode !== childNode && (newNode = newNode.updateImmediateChild(childName, newChildNode));
        });
        return newNode;
      };
      var OperationType;
      (function(OperationType) {
        OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
        OperationType[OperationType["MERGE"] = 1] = "MERGE";
        OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
        OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
      })(OperationType || (OperationType = {}));
      var OperationSource = function() {
        function OperationSource(fromUser, fromServer, queryId, tagged) {
          this.fromUser = fromUser;
          this.fromServer = fromServer;
          this.queryId = queryId;
          this.tagged = tagged;
          util.assert(!tagged || fromServer, "Tagged queries must be from server.");
        }
        OperationSource.User = new OperationSource(true, false, null, false);
        OperationSource.Server = new OperationSource(false, true, null, false);
        OperationSource.forServerTaggedQuery = function(queryId) {
          return new OperationSource(false, true, queryId, true);
        };
        return OperationSource;
      }();
      var AckUserWrite = function() {
        function AckUserWrite(path, affectedTree, revert) {
          this.path = path;
          this.affectedTree = affectedTree;
          this.revert = revert;
          this.type = OperationType.ACK_USER_WRITE;
          this.source = OperationSource.User;
        }
        AckUserWrite.prototype.operationForChild = function(childName) {
          if (this.path.isEmpty()) {
            if (null != this.affectedTree.value) {
              util.assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
              return this;
            }
            var childTree = this.affectedTree.subtree(new Path(childName));
            return new AckUserWrite(Path.Empty, childTree, this.revert);
          }
          util.assert(this.path.getFront() === childName, "operationForChild called for unrelated child.");
          return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);
        };
        return AckUserWrite;
      }();
      var emptyChildrenSingleton;
      var EmptyChildren = function() {
        emptyChildrenSingleton || (emptyChildrenSingleton = new SortedMap(stringCompare));
        return emptyChildrenSingleton;
      };
      var ImmutableTree = function() {
        function ImmutableTree(value, children) {
          void 0 === children && (children = EmptyChildren());
          this.value = value;
          this.children = children;
        }
        ImmutableTree.fromObject = function(obj) {
          var tree = ImmutableTree.Empty;
          util.forEach(obj, function(childPath, childSnap) {
            tree = tree.set(new Path(childPath), childSnap);
          });
          return tree;
        };
        ImmutableTree.prototype.isEmpty = function() {
          return null === this.value && this.children.isEmpty();
        };
        ImmutableTree.prototype.findRootMostMatchingPathAndValue = function(relativePath, predicate) {
          if (null != this.value && predicate(this.value)) return {
            path: Path.Empty,
            value: this.value
          };
          if (relativePath.isEmpty()) return null;
          var front = relativePath.getFront();
          var child = this.children.get(front);
          if (null !== child) {
            var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);
            if (null != childExistingPathAndValue) {
              var fullPath = new Path(front).child(childExistingPathAndValue.path);
              return {
                path: fullPath,
                value: childExistingPathAndValue.value
              };
            }
            return null;
          }
          return null;
        };
        ImmutableTree.prototype.findRootMostValueAndPath = function(relativePath) {
          return this.findRootMostMatchingPathAndValue(relativePath, function() {
            return true;
          });
        };
        ImmutableTree.prototype.subtree = function(relativePath) {
          if (relativePath.isEmpty()) return this;
          var front = relativePath.getFront();
          var childTree = this.children.get(front);
          return null !== childTree ? childTree.subtree(relativePath.popFront()) : ImmutableTree.Empty;
        };
        ImmutableTree.prototype.set = function(relativePath, toSet) {
          if (relativePath.isEmpty()) return new ImmutableTree(toSet, this.children);
          var front = relativePath.getFront();
          var child = this.children.get(front) || ImmutableTree.Empty;
          var newChild = child.set(relativePath.popFront(), toSet);
          var newChildren = this.children.insert(front, newChild);
          return new ImmutableTree(this.value, newChildren);
        };
        ImmutableTree.prototype.remove = function(relativePath) {
          if (relativePath.isEmpty()) return this.children.isEmpty() ? ImmutableTree.Empty : new ImmutableTree(null, this.children);
          var front = relativePath.getFront();
          var child = this.children.get(front);
          if (child) {
            var newChild = child.remove(relativePath.popFront());
            var newChildren = void 0;
            newChildren = newChild.isEmpty() ? this.children.remove(front) : this.children.insert(front, newChild);
            return null === this.value && newChildren.isEmpty() ? ImmutableTree.Empty : new ImmutableTree(this.value, newChildren);
          }
          return this;
        };
        ImmutableTree.prototype.get = function(relativePath) {
          if (relativePath.isEmpty()) return this.value;
          var front = relativePath.getFront();
          var child = this.children.get(front);
          return child ? child.get(relativePath.popFront()) : null;
        };
        ImmutableTree.prototype.setTree = function(relativePath, newTree) {
          if (relativePath.isEmpty()) return newTree;
          var front = relativePath.getFront();
          var child = this.children.get(front) || ImmutableTree.Empty;
          var newChild = child.setTree(relativePath.popFront(), newTree);
          var newChildren = void 0;
          newChildren = newChild.isEmpty() ? this.children.remove(front) : this.children.insert(front, newChild);
          return new ImmutableTree(this.value, newChildren);
        };
        ImmutableTree.prototype.fold = function(fn) {
          return this.fold_(Path.Empty, fn);
        };
        ImmutableTree.prototype.fold_ = function(pathSoFar, fn) {
          var accum = {};
          this.children.inorderTraversal(function(childKey, childTree) {
            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);
          });
          return fn(pathSoFar, this.value, accum);
        };
        ImmutableTree.prototype.findOnPath = function(path, f) {
          return this.findOnPath_(path, Path.Empty, f);
        };
        ImmutableTree.prototype.findOnPath_ = function(pathToFollow, pathSoFar, f) {
          var result = !!this.value && f(pathSoFar, this.value);
          if (result) return result;
          if (pathToFollow.isEmpty()) return null;
          var front = pathToFollow.getFront();
          var nextChild = this.children.get(front);
          return nextChild ? nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f) : null;
        };
        ImmutableTree.prototype.foreachOnPath = function(path, f) {
          return this.foreachOnPath_(path, Path.Empty, f);
        };
        ImmutableTree.prototype.foreachOnPath_ = function(pathToFollow, currentRelativePath, f) {
          if (pathToFollow.isEmpty()) return this;
          this.value && f(currentRelativePath, this.value);
          var front = pathToFollow.getFront();
          var nextChild = this.children.get(front);
          return nextChild ? nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f) : ImmutableTree.Empty;
        };
        ImmutableTree.prototype.foreach = function(f) {
          this.foreach_(Path.Empty, f);
        };
        ImmutableTree.prototype.foreach_ = function(currentRelativePath, f) {
          this.children.inorderTraversal(function(childName, childTree) {
            childTree.foreach_(currentRelativePath.child(childName), f);
          });
          this.value && f(currentRelativePath, this.value);
        };
        ImmutableTree.prototype.foreachChild = function(f) {
          this.children.inorderTraversal(function(childName, childTree) {
            childTree.value && f(childName, childTree.value);
          });
        };
        ImmutableTree.Empty = new ImmutableTree(null);
        return ImmutableTree;
      }();
      var ListenComplete = function() {
        function ListenComplete(source, path) {
          this.source = source;
          this.path = path;
          this.type = OperationType.LISTEN_COMPLETE;
        }
        ListenComplete.prototype.operationForChild = function(childName) {
          return this.path.isEmpty() ? new ListenComplete(this.source, Path.Empty) : new ListenComplete(this.source, this.path.popFront());
        };
        return ListenComplete;
      }();
      var Overwrite = function() {
        function Overwrite(source, path, snap) {
          this.source = source;
          this.path = path;
          this.snap = snap;
          this.type = OperationType.OVERWRITE;
        }
        Overwrite.prototype.operationForChild = function(childName) {
          return this.path.isEmpty() ? new Overwrite(this.source, Path.Empty, this.snap.getImmediateChild(childName)) : new Overwrite(this.source, this.path.popFront(), this.snap);
        };
        return Overwrite;
      }();
      var Merge = function() {
        function Merge(source, path, children) {
          this.source = source;
          this.path = path;
          this.children = children;
          this.type = OperationType.MERGE;
        }
        Merge.prototype.operationForChild = function(childName) {
          if (this.path.isEmpty()) {
            var childTree = this.children.subtree(new Path(childName));
            return childTree.isEmpty() ? null : childTree.value ? new Overwrite(this.source, Path.Empty, childTree.value) : new Merge(this.source, Path.Empty, childTree);
          }
          util.assert(this.path.getFront() === childName, "Can't get a merge for a child not on the path of the operation");
          return new Merge(this.source, this.path.popFront(), this.children);
        };
        Merge.prototype.toString = function() {
          return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
        };
        return Merge;
      }();
      var CacheNode = function() {
        function CacheNode(node_, fullyInitialized_, filtered_) {
          this.node_ = node_;
          this.fullyInitialized_ = fullyInitialized_;
          this.filtered_ = filtered_;
        }
        CacheNode.prototype.isFullyInitialized = function() {
          return this.fullyInitialized_;
        };
        CacheNode.prototype.isFiltered = function() {
          return this.filtered_;
        };
        CacheNode.prototype.isCompleteForPath = function(path) {
          if (path.isEmpty()) return this.isFullyInitialized() && !this.filtered_;
          var childKey = path.getFront();
          return this.isCompleteForChild(childKey);
        };
        CacheNode.prototype.isCompleteForChild = function(key) {
          return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
        };
        CacheNode.prototype.getNode = function() {
          return this.node_;
        };
        return CacheNode;
      }();
      var ViewCache = function() {
        function ViewCache(eventCache_, serverCache_) {
          this.eventCache_ = eventCache_;
          this.serverCache_ = serverCache_;
        }
        ViewCache.prototype.updateEventSnap = function(eventSnap, complete, filtered) {
          return new ViewCache(new CacheNode(eventSnap, complete, filtered), this.serverCache_);
        };
        ViewCache.prototype.updateServerSnap = function(serverSnap, complete, filtered) {
          return new ViewCache(this.eventCache_, new CacheNode(serverSnap, complete, filtered));
        };
        ViewCache.prototype.getEventCache = function() {
          return this.eventCache_;
        };
        ViewCache.prototype.getCompleteEventSnap = function() {
          return this.eventCache_.isFullyInitialized() ? this.eventCache_.getNode() : null;
        };
        ViewCache.prototype.getServerCache = function() {
          return this.serverCache_;
        };
        ViewCache.prototype.getCompleteServerSnap = function() {
          return this.serverCache_.isFullyInitialized() ? this.serverCache_.getNode() : null;
        };
        ViewCache.Empty = new ViewCache(new CacheNode(ChildrenNode.EMPTY_NODE, false, false), new CacheNode(ChildrenNode.EMPTY_NODE, false, false));
        return ViewCache;
      }();
      var Change = function() {
        function Change(type, snapshotNode, childName, oldSnap, prevName) {
          this.type = type;
          this.snapshotNode = snapshotNode;
          this.childName = childName;
          this.oldSnap = oldSnap;
          this.prevName = prevName;
        }
        Change.valueChange = function(snapshot) {
          return new Change(Change.VALUE, snapshot);
        };
        Change.childAddedChange = function(childKey, snapshot) {
          return new Change(Change.CHILD_ADDED, snapshot, childKey);
        };
        Change.childRemovedChange = function(childKey, snapshot) {
          return new Change(Change.CHILD_REMOVED, snapshot, childKey);
        };
        Change.childChangedChange = function(childKey, newSnapshot, oldSnapshot) {
          return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);
        };
        Change.childMovedChange = function(childKey, snapshot) {
          return new Change(Change.CHILD_MOVED, snapshot, childKey);
        };
        Change.CHILD_ADDED = "child_added";
        Change.CHILD_REMOVED = "child_removed";
        Change.CHILD_CHANGED = "child_changed";
        Change.CHILD_MOVED = "child_moved";
        Change.VALUE = "value";
        return Change;
      }();
      var IndexedFilter = function() {
        function IndexedFilter(index_) {
          this.index_ = index_;
        }
        IndexedFilter.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
          util.assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
          var oldChild = snap.getImmediateChild(key);
          if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath)) && oldChild.isEmpty() == newChild.isEmpty()) return snap;
          null != optChangeAccumulator && (newChild.isEmpty() ? snap.hasChild(key) ? optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, oldChild)) : util.assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : oldChild.isEmpty() ? optChangeAccumulator.trackChildChange(Change.childAddedChange(key, newChild)) : optChangeAccumulator.trackChildChange(Change.childChangedChange(key, newChild, oldChild)));
          return snap.isLeafNode() && newChild.isEmpty() ? snap : snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        };
        IndexedFilter.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
          if (null != optChangeAccumulator) {
            oldSnap.isLeafNode() || oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              newSnap.hasChild(key) || optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, childNode));
            });
            newSnap.isLeafNode() || newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              if (oldSnap.hasChild(key)) {
                var oldChild = oldSnap.getImmediateChild(key);
                oldChild.equals(childNode) || optChangeAccumulator.trackChildChange(Change.childChangedChange(key, childNode, oldChild));
              } else optChangeAccumulator.trackChildChange(Change.childAddedChange(key, childNode));
            });
          }
          return newSnap.withIndex(this.index_);
        };
        IndexedFilter.prototype.updatePriority = function(oldSnap, newPriority) {
          return oldSnap.isEmpty() ? ChildrenNode.EMPTY_NODE : oldSnap.updatePriority(newPriority);
        };
        IndexedFilter.prototype.filtersNodes = function() {
          return false;
        };
        IndexedFilter.prototype.getIndexedFilter = function() {
          return this;
        };
        IndexedFilter.prototype.getIndex = function() {
          return this.index_;
        };
        return IndexedFilter;
      }();
      var ChildChangeAccumulator = function() {
        function ChildChangeAccumulator() {
          this.changeMap_ = {};
        }
        ChildChangeAccumulator.prototype.trackChildChange = function(change) {
          var type = change.type;
          var childKey = change.childName;
          util.assert(type == Change.CHILD_ADDED || type == Change.CHILD_CHANGED || type == Change.CHILD_REMOVED, "Only child changes supported for tracking");
          util.assert(".priority" !== childKey, "Only non-priority child changes can be tracked.");
          var oldChange = util.safeGet(this.changeMap_, childKey);
          if (oldChange) {
            var oldType = oldChange.type;
            if (type == Change.CHILD_ADDED && oldType == Change.CHILD_REMOVED) this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode); else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_ADDED) delete this.changeMap_[childKey]; else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_CHANGED) this.changeMap_[childKey] = Change.childRemovedChange(childKey, oldChange.oldSnap); else if (type == Change.CHILD_CHANGED && oldType == Change.CHILD_ADDED) this.changeMap_[childKey] = Change.childAddedChange(childKey, change.snapshotNode); else {
              if (type != Change.CHILD_CHANGED || oldType != Change.CHILD_CHANGED) throw util.assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
              this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            }
          } else this.changeMap_[childKey] = change;
        };
        ChildChangeAccumulator.prototype.getChanges = function() {
          return util.getValues(this.changeMap_);
        };
        return ChildChangeAccumulator;
      }();
      var NoCompleteChildSource_ = function() {
        function NoCompleteChildSource_() {}
        NoCompleteChildSource_.prototype.getCompleteChild = function(childKey) {
          return null;
        };
        NoCompleteChildSource_.prototype.getChildAfterChild = function(index, child, reverse) {
          return null;
        };
        return NoCompleteChildSource_;
      }();
      var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
      var WriteTreeCompleteChildSource = function() {
        function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {
          void 0 === optCompleteServerCache_ && (optCompleteServerCache_ = null);
          this.writes_ = writes_;
          this.viewCache_ = viewCache_;
          this.optCompleteServerCache_ = optCompleteServerCache_;
        }
        WriteTreeCompleteChildSource.prototype.getCompleteChild = function(childKey) {
          var node = this.viewCache_.getEventCache();
          if (node.isCompleteForChild(childKey)) return node.getNode().getImmediateChild(childKey);
          var serverNode = null != this.optCompleteServerCache_ ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.getServerCache();
          return this.writes_.calcCompleteChild(childKey, serverNode);
        };
        WriteTreeCompleteChildSource.prototype.getChildAfterChild = function(index, child, reverse) {
          var completeServerData = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : this.viewCache_.getCompleteServerSnap();
          var nodes = this.writes_.calcIndexedSlice(completeServerData, child, 1, reverse, index);
          return 0 === nodes.length ? null : nodes[0];
        };
        return WriteTreeCompleteChildSource;
      }();
      var ProcessorResult = function() {
        function ProcessorResult(viewCache, changes) {
          this.viewCache = viewCache;
          this.changes = changes;
        }
        return ProcessorResult;
      }();
      var ViewProcessor = function() {
        function ViewProcessor(filter_) {
          this.filter_ = filter_;
        }
        ViewProcessor.prototype.assertIndexed = function(viewCache) {
          util.assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), "Event snap not indexed");
          util.assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), "Server snap not indexed");
        };
        ViewProcessor.prototype.applyOperation = function(oldViewCache, operation, writesCache, completeCache) {
          var accumulator = new ChildChangeAccumulator();
          var newViewCache, filterServerNode;
          if (operation.type === OperationType.OVERWRITE) {
            var overwrite = operation;
            if (overwrite.source.fromUser) newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator); else {
              util.assert(overwrite.source.fromServer, "Unknown source.");
              filterServerNode = overwrite.source.tagged || oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty();
              newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
            }
          } else if (operation.type === OperationType.MERGE) {
            var merge = operation;
            if (merge.source.fromUser) newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator); else {
              util.assert(merge.source.fromServer, "Unknown source.");
              filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();
              newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
            }
          } else if (operation.type === OperationType.ACK_USER_WRITE) {
            var ackUserWrite = operation;
            newViewCache = ackUserWrite.revert ? this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator) : this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
          } else {
            if (operation.type !== OperationType.LISTEN_COMPLETE) throw util.assertionError("Unknown operation type: " + operation.type);
            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);
          }
          var changes = accumulator.getChanges();
          ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);
          return new ProcessorResult(newViewCache, changes);
        };
        ViewProcessor.maybeAddValueEvent_ = function(oldViewCache, newViewCache, accumulator) {
          var eventSnap = newViewCache.getEventCache();
          if (eventSnap.isFullyInitialized()) {
            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();
            (accumulator.length > 0 || !oldViewCache.getEventCache().isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) && accumulator.push(Change.valueChange(newViewCache.getCompleteEventSnap()));
          }
        };
        ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function(viewCache, changePath, writesCache, source, accumulator) {
          var oldEventSnap = viewCache.getEventCache();
          if (null != writesCache.shadowingWrite(changePath)) return viewCache;
          var newEventCache = void 0, serverNode = void 0;
          if (changePath.isEmpty()) {
            util.assert(viewCache.getServerCache().isFullyInitialized(), "If change path is empty, we must have complete server data");
            if (viewCache.getServerCache().isFiltered()) {
              var serverCache = viewCache.getCompleteServerSnap();
              var completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
              var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);
              newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);
            } else {
              var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
              newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);
            }
          } else {
            var childKey = changePath.getFront();
            if (".priority" == childKey) {
              util.assert(1 == changePath.getLength(), "Can't have a priority with additional path components");
              var oldEventNode = oldEventSnap.getNode();
              serverNode = viewCache.getServerCache().getNode();
              var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);
              newEventCache = null != updatedPriority ? this.filter_.updatePriority(oldEventNode, updatedPriority) : oldEventSnap.getNode();
            } else {
              var childChangePath = changePath.popFront();
              var newEventChild = void 0;
              if (oldEventSnap.isCompleteForChild(childKey)) {
                serverNode = viewCache.getServerCache().getNode();
                var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);
                newEventChild = null != eventChildUpdate ? oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate) : oldEventSnap.getNode().getImmediateChild(childKey);
              } else newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
              newEventCache = null != newEventChild ? this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator) : oldEventSnap.getNode();
            }
          }
          return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());
        };
        ViewProcessor.prototype.applyServerOverwrite_ = function(oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
          var oldServerSnap = oldViewCache.getServerCache();
          var newServerCache;
          var serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();
          if (changePath.isEmpty()) newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null); else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
            var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
          } else {
            var childKey = changePath.getFront();
            if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) return oldViewCache;
            var childChangePath = changePath.popFront();
            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
            var newChildNode = childNode.updateChild(childChangePath, changedSnap);
            newServerCache = ".priority" == childKey ? serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode) : serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
          }
          var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());
          var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
          return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);
        };
        ViewProcessor.prototype.applyUserOverwrite_ = function(oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
          var oldEventSnap = oldViewCache.getEventCache();
          var newViewCache, newEventCache;
          var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
          if (changePath.isEmpty()) {
            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);
            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());
          } else {
            var childKey = changePath.getFront();
            if (".priority" === childKey) {
              newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);
              newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
            } else {
              var childChangePath = changePath.popFront();
              var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
              var newChild = void 0;
              if (childChangePath.isEmpty()) newChild = changedSnap; else {
                var childNode = source.getCompleteChild(childKey);
                newChild = null != childNode ? ".priority" === childChangePath.getBack() && childNode.getChild(childChangePath.parent()).isEmpty() ? childNode : childNode.updateChild(childChangePath, changedSnap) : ChildrenNode.EMPTY_NODE;
              }
              if (oldChild.equals(newChild)) newViewCache = oldViewCache; else {
                var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());
              }
            }
          }
          return newViewCache;
        };
        ViewProcessor.cacheHasChild_ = function(viewCache, childKey) {
          return viewCache.getEventCache().isCompleteForChild(childKey);
        };
        ViewProcessor.prototype.applyUserMerge_ = function(viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
          var _this = this;
          var curViewCache = viewCache;
          changedChildren.foreach(function(relativePath, childNode) {
            var writePath = path.child(relativePath);
            ViewProcessor.cacheHasChild_(viewCache, writePath.getFront()) && (curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator));
          });
          changedChildren.foreach(function(relativePath, childNode) {
            var writePath = path.child(relativePath);
            ViewProcessor.cacheHasChild_(viewCache, writePath.getFront()) || (curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator));
          });
          return curViewCache;
        };
        ViewProcessor.prototype.applyMerge_ = function(node, merge) {
          merge.foreach(function(relativePath, childNode) {
            node = node.updateChild(relativePath, childNode);
          });
          return node;
        };
        ViewProcessor.prototype.applyServerMerge_ = function(viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
          var _this = this;
          if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) return viewCache;
          var curViewCache = viewCache;
          var viewMergeTree;
          viewMergeTree = path.isEmpty() ? changedChildren : ImmutableTree.Empty.setTree(path, changedChildren);
          var serverNode = viewCache.getServerCache().getNode();
          viewMergeTree.children.inorderTraversal(function(childKey, childTree) {
            if (serverNode.hasChild(childKey)) {
              var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);
              var newChild = _this.applyMerge_(serverChild, childTree);
              curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
          });
          viewMergeTree.children.inorderTraversal(function(childKey, childMergeTree) {
            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) && null == childMergeTree.value;
            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
              var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);
              var newChild = _this.applyMerge_(serverChild, childMergeTree);
              curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
          });
          return curViewCache;
        };
        ViewProcessor.prototype.ackUserWrite_ = function(viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
          if (null != writesCache.shadowingWrite(ackPath)) return viewCache;
          var filterServerNode = viewCache.getServerCache().isFiltered();
          var serverCache = viewCache.getServerCache();
          if (null != affectedTree.value) {
            if (ackPath.isEmpty() && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
            if (ackPath.isEmpty()) {
              var changedChildren_1 = ImmutableTree.Empty;
              serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {
                changedChildren_1 = changedChildren_1.set(new Path(name), node);
              });
              return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
            }
            return viewCache;
          }
          var changedChildren_2 = ImmutableTree.Empty;
          affectedTree.foreach(function(mergePath, value) {
            var serverCachePath = ackPath.child(mergePath);
            serverCache.isCompleteForPath(serverCachePath) && (changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath)));
          });
          return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
        };
        ViewProcessor.prototype.listenComplete_ = function(viewCache, path, writesCache, accumulator) {
          var oldServerNode = viewCache.getServerCache();
          var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());
          return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
        };
        ViewProcessor.prototype.revertUserWrite_ = function(viewCache, path, writesCache, completeServerCache, accumulator) {
          var complete;
          if (null != writesCache.shadowingWrite(path)) return viewCache;
          var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
          var oldEventCache = viewCache.getEventCache().getNode();
          var newEventCache = void 0;
          if (path.isEmpty() || ".priority" === path.getFront()) {
            var newNode = void 0;
            if (viewCache.getServerCache().isFullyInitialized()) newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap()); else {
              var serverChildren = viewCache.getServerCache().getNode();
              util.assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
              newNode = writesCache.calcCompleteEventChildren(serverChildren);
            }
            newNode = newNode;
            newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);
          } else {
            var childKey = path.getFront();
            var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
            null == newChild && viewCache.getServerCache().isCompleteForChild(childKey) && (newChild = oldEventCache.getImmediateChild(childKey));
            newEventCache = null != newChild ? this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator) : viewCache.getEventCache().getNode().hasChild(childKey) ? this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator) : oldEventCache;
            if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {
              complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
              complete.isLeafNode() && (newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator));
            }
          }
          complete = viewCache.getServerCache().isFullyInitialized() || null != writesCache.shadowingWrite(Path.Empty);
          return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());
        };
        return ViewProcessor;
      }();
      var EventGenerator = function() {
        function EventGenerator(query_) {
          this.query_ = query_;
          this.index_ = this.query_.getQueryParams().getIndex();
        }
        EventGenerator.prototype.generateEventsForChanges = function(changes, eventCache, eventRegistrations) {
          var _this = this;
          var events = [];
          var moves = [];
          changes.forEach(function(change) {
            change.type === Change.CHILD_CHANGED && _this.index_.indexedValueChanged(change.oldSnap, change.snapshotNode) && moves.push(Change.childMovedChange(change.childName, change.snapshotNode));
          });
          this.generateEventsForType_(events, Change.CHILD_REMOVED, changes, eventRegistrations, eventCache);
          this.generateEventsForType_(events, Change.CHILD_ADDED, changes, eventRegistrations, eventCache);
          this.generateEventsForType_(events, Change.CHILD_MOVED, moves, eventRegistrations, eventCache);
          this.generateEventsForType_(events, Change.CHILD_CHANGED, changes, eventRegistrations, eventCache);
          this.generateEventsForType_(events, Change.VALUE, changes, eventRegistrations, eventCache);
          return events;
        };
        EventGenerator.prototype.generateEventsForType_ = function(events, eventType, changes, registrations, eventCache) {
          var _this = this;
          var filteredChanges = changes.filter(function(change) {
            return change.type === eventType;
          });
          filteredChanges.sort(this.compareChanges_.bind(this));
          filteredChanges.forEach(function(change) {
            var materializedChange = _this.materializeSingleChange_(change, eventCache);
            registrations.forEach(function(registration) {
              registration.respondsTo(change.type) && events.push(registration.createEvent(materializedChange, _this.query_));
            });
          });
        };
        EventGenerator.prototype.materializeSingleChange_ = function(change, eventCache) {
          if ("value" === change.type || "child_removed" === change.type) return change;
          change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, this.index_);
          return change;
        };
        EventGenerator.prototype.compareChanges_ = function(a, b) {
          if (null == a.childName || null == b.childName) throw util.assertionError("Should only compare child_ events.");
          var aWrapped = new NamedNode(a.childName, a.snapshotNode);
          var bWrapped = new NamedNode(b.childName, b.snapshotNode);
          return this.index_.compare(aWrapped, bWrapped);
        };
        return EventGenerator;
      }();
      var View = function() {
        function View(query_, initialViewCache) {
          this.query_ = query_;
          this.eventRegistrations_ = [];
          var params = this.query_.getQueryParams();
          var indexFilter = new IndexedFilter(params.getIndex());
          var filter = params.getNodeFilter();
          this.processor_ = new ViewProcessor(filter);
          var initialServerCache = initialViewCache.getServerCache();
          var initialEventCache = initialViewCache.getEventCache();
          var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
          var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
          var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
          var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
          this.viewCache_ = new ViewCache(newEventCache, newServerCache);
          this.eventGenerator_ = new EventGenerator(this.query_);
        }
        View.prototype.getQuery = function() {
          return this.query_;
        };
        View.prototype.getServerCache = function() {
          return this.viewCache_.getServerCache().getNode();
        };
        View.prototype.getCompleteServerCache = function(path) {
          var cache = this.viewCache_.getCompleteServerSnap();
          if (cache && (this.query_.getQueryParams().loadsAllData() || !path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) return cache.getChild(path);
          return null;
        };
        View.prototype.isEmpty = function() {
          return 0 === this.eventRegistrations_.length;
        };
        View.prototype.addEventRegistration = function(eventRegistration) {
          this.eventRegistrations_.push(eventRegistration);
        };
        View.prototype.removeEventRegistration = function(eventRegistration, cancelError) {
          var cancelEvents = [];
          if (cancelError) {
            util.assert(null == eventRegistration, "A cancel should cancel all event registrations.");
            var path_1 = this.query_.path;
            this.eventRegistrations_.forEach(function(registration) {
              cancelError = cancelError;
              var maybeEvent = registration.createCancelEvent(cancelError, path_1);
              maybeEvent && cancelEvents.push(maybeEvent);
            });
          }
          if (eventRegistration) {
            var remaining = [];
            for (var i = 0; i < this.eventRegistrations_.length; ++i) {
              var existing = this.eventRegistrations_[i];
              if (existing.matches(eventRegistration)) {
                if (eventRegistration.hasAnyCallback()) {
                  remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));
                  break;
                }
              } else remaining.push(existing);
            }
            this.eventRegistrations_ = remaining;
          } else this.eventRegistrations_ = [];
          return cancelEvents;
        };
        View.prototype.applyOperation = function(operation, writesCache, completeServerCache) {
          if (operation.type === OperationType.MERGE && null !== operation.source.queryId) {
            util.assert(this.viewCache_.getCompleteServerSnap(), "We should always have a full cache before handling merges");
            util.assert(this.viewCache_.getCompleteEventSnap(), "Missing event cache, even though we have a server cache");
          }
          var oldViewCache = this.viewCache_;
          var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);
          this.processor_.assertIndexed(result.viewCache);
          util.assert(result.viewCache.getServerCache().isFullyInitialized() || !oldViewCache.getServerCache().isFullyInitialized(), "Once a server snap is complete, it should never go back");
          this.viewCache_ = result.viewCache;
          return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);
        };
        View.prototype.getInitialEvents = function(registration) {
          var eventSnap = this.viewCache_.getEventCache();
          var initialChanges = [];
          if (!eventSnap.getNode().isLeafNode()) {
            var eventNode = eventSnap.getNode();
            eventNode.forEachChild(PRIORITY_INDEX, function(key, childNode) {
              initialChanges.push(Change.childAddedChange(key, childNode));
            });
          }
          eventSnap.isFullyInitialized() && initialChanges.push(Change.valueChange(eventSnap.getNode()));
          return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);
        };
        View.prototype.generateEventsForChanges_ = function(changes, eventCache, eventRegistration) {
          var registrations = eventRegistration ? [ eventRegistration ] : this.eventRegistrations_;
          return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);
        };
        return View;
      }();
      var __referenceConstructor$1;
      var SyncPoint = function() {
        function SyncPoint() {
          this.views_ = {};
        }
        Object.defineProperty(SyncPoint, "__referenceConstructor", {
          get: function() {
            util.assert(__referenceConstructor$1, "Reference.ts has not been loaded");
            return __referenceConstructor$1;
          },
          set: function(val) {
            util.assert(!__referenceConstructor$1, "__referenceConstructor has already been defined");
            __referenceConstructor$1 = val;
          },
          enumerable: true,
          configurable: true
        });
        SyncPoint.prototype.isEmpty = function() {
          return util.isEmpty(this.views_);
        };
        SyncPoint.prototype.applyOperation = function(operation, writesCache, optCompleteServerCache) {
          var queryId = operation.source.queryId;
          if (null !== queryId) {
            var view = util.safeGet(this.views_, queryId);
            util.assert(null != view, "SyncTree gave us an op for an invalid query.");
            return view.applyOperation(operation, writesCache, optCompleteServerCache);
          }
          var events_1 = [];
          util.forEach(this.views_, function(key, view) {
            events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));
          });
          return events_1;
        };
        SyncPoint.prototype.addEventRegistration = function(query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
          var queryId = query.queryIdentifier();
          var view = util.safeGet(this.views_, queryId);
          if (!view) {
            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);
            var eventCacheComplete = false;
            if (eventCache) eventCacheComplete = true; else if (serverCache instanceof ChildrenNode) {
              eventCache = writesCache.calcCompleteEventChildren(serverCache);
              eventCacheComplete = false;
            } else {
              eventCache = ChildrenNode.EMPTY_NODE;
              eventCacheComplete = false;
            }
            var viewCache = new ViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
            view = new View(query, viewCache);
            this.views_[queryId] = view;
          }
          view.addEventRegistration(eventRegistration);
          return view.getInitialEvents(eventRegistration);
        };
        SyncPoint.prototype.removeEventRegistration = function(query, eventRegistration, cancelError) {
          var queryId = query.queryIdentifier();
          var removed = [];
          var cancelEvents = [];
          var hadCompleteView = this.hasCompleteView();
          if ("default" === queryId) {
            var self_1 = this;
            util.forEach(this.views_, function(viewQueryId, view) {
              cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
              if (view.isEmpty()) {
                delete self_1.views_[viewQueryId];
                view.getQuery().getQueryParams().loadsAllData() || removed.push(view.getQuery());
              }
            });
          } else {
            var view = util.safeGet(this.views_, queryId);
            if (view) {
              cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
              if (view.isEmpty()) {
                delete this.views_[queryId];
                view.getQuery().getQueryParams().loadsAllData() || removed.push(view.getQuery());
              }
            }
          }
          hadCompleteView && !this.hasCompleteView() && removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));
          return {
            removed: removed,
            events: cancelEvents
          };
        };
        SyncPoint.prototype.getQueryViews = function() {
          var _this = this;
          var values = Object.keys(this.views_).map(function(key) {
            return _this.views_[key];
          });
          return values.filter(function(view) {
            return !view.getQuery().getQueryParams().loadsAllData();
          });
        };
        SyncPoint.prototype.getCompleteServerCache = function(path) {
          var serverCache = null;
          util.forEach(this.views_, function(key, view) {
            serverCache = serverCache || view.getCompleteServerCache(path);
          });
          return serverCache;
        };
        SyncPoint.prototype.viewForQuery = function(query) {
          var params = query.getQueryParams();
          if (params.loadsAllData()) return this.getCompleteView();
          var queryId = query.queryIdentifier();
          return util.safeGet(this.views_, queryId);
        };
        SyncPoint.prototype.viewExistsForQuery = function(query) {
          return null != this.viewForQuery(query);
        };
        SyncPoint.prototype.hasCompleteView = function() {
          return null != this.getCompleteView();
        };
        SyncPoint.prototype.getCompleteView = function() {
          var completeView = util.findValue(this.views_, function(view) {
            return view.getQuery().getQueryParams().loadsAllData();
          });
          return completeView || null;
        };
        return SyncPoint;
      }();
      var CompoundWrite = function() {
        function CompoundWrite(writeTree_) {
          this.writeTree_ = writeTree_;
        }
        CompoundWrite.prototype.addWrite = function(path, node) {
          if (path.isEmpty()) return new CompoundWrite(new ImmutableTree(node));
          var rootmost = this.writeTree_.findRootMostValueAndPath(path);
          if (null != rootmost) {
            var rootMostPath = rootmost.path;
            var value = rootmost.value;
            var relativePath = Path.relativePath(rootMostPath, path);
            value = value.updateChild(relativePath, node);
            return new CompoundWrite(this.writeTree_.set(rootMostPath, value));
          }
          var subtree = new ImmutableTree(node);
          var newWriteTree = this.writeTree_.setTree(path, subtree);
          return new CompoundWrite(newWriteTree);
        };
        CompoundWrite.prototype.addWrites = function(path, updates) {
          var newWrite = this;
          util.forEach(updates, function(childKey, node) {
            newWrite = newWrite.addWrite(path.child(childKey), node);
          });
          return newWrite;
        };
        CompoundWrite.prototype.removeWrite = function(path) {
          if (path.isEmpty()) return CompoundWrite.Empty;
          var newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);
          return new CompoundWrite(newWriteTree);
        };
        CompoundWrite.prototype.hasCompleteWrite = function(path) {
          return null != this.getCompleteNode(path);
        };
        CompoundWrite.prototype.getCompleteNode = function(path) {
          var rootmost = this.writeTree_.findRootMostValueAndPath(path);
          return null != rootmost ? this.writeTree_.get(rootmost.path).getChild(Path.relativePath(rootmost.path, path)) : null;
        };
        CompoundWrite.prototype.getCompleteChildren = function() {
          var children = [];
          var node = this.writeTree_.value;
          null != node ? node.isLeafNode() || node.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
            children.push(new NamedNode(childName, childNode));
          }) : this.writeTree_.children.inorderTraversal(function(childName, childTree) {
            null != childTree.value && children.push(new NamedNode(childName, childTree.value));
          });
          return children;
        };
        CompoundWrite.prototype.childCompoundWrite = function(path) {
          if (path.isEmpty()) return this;
          var shadowingNode = this.getCompleteNode(path);
          return new CompoundWrite(null != shadowingNode ? new ImmutableTree(shadowingNode) : this.writeTree_.subtree(path));
        };
        CompoundWrite.prototype.isEmpty = function() {
          return this.writeTree_.isEmpty();
        };
        CompoundWrite.prototype.apply = function(node) {
          return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);
        };
        CompoundWrite.Empty = new CompoundWrite(new ImmutableTree(null));
        CompoundWrite.applySubtreeWrite_ = function(relativePath, writeTree, node) {
          if (null != writeTree.value) return node.updateChild(relativePath, writeTree.value);
          var priorityWrite_1 = null;
          writeTree.children.inorderTraversal(function(childKey, childTree) {
            if (".priority" === childKey) {
              util.assert(null !== childTree.value, "Priority writes must always be leaf nodes");
              priorityWrite_1 = childTree.value;
            } else node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);
          });
          node.getChild(relativePath).isEmpty() || null === priorityWrite_1 || (node = node.updateChild(relativePath.child(".priority"), priorityWrite_1));
          return node;
        };
        return CompoundWrite;
      }();
      var WriteTree = function() {
        function WriteTree() {
          this.visibleWrites_ = CompoundWrite.Empty;
          this.allWrites_ = [];
          this.lastWriteId_ = -1;
        }
        WriteTree.prototype.childWrites = function(path) {
          return new WriteTreeRef(path, this);
        };
        WriteTree.prototype.addOverwrite = function(path, snap, writeId, visible) {
          util.assert(writeId > this.lastWriteId_, "Stacking an older write on top of newer ones");
          void 0 === visible && (visible = true);
          this.allWrites_.push({
            path: path,
            snap: snap,
            writeId: writeId,
            visible: visible
          });
          visible && (this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap));
          this.lastWriteId_ = writeId;
        };
        WriteTree.prototype.addMerge = function(path, changedChildren, writeId) {
          util.assert(writeId > this.lastWriteId_, "Stacking an older merge on top of newer ones");
          this.allWrites_.push({
            path: path,
            children: changedChildren,
            writeId: writeId,
            visible: true
          });
          this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);
          this.lastWriteId_ = writeId;
        };
        WriteTree.prototype.getWrite = function(writeId) {
          for (var i = 0; i < this.allWrites_.length; i++) {
            var record = this.allWrites_[i];
            if (record.writeId === writeId) return record;
          }
          return null;
        };
        WriteTree.prototype.removeWrite = function(writeId) {
          var _this = this;
          var idx = this.allWrites_.findIndex(function(s) {
            return s.writeId === writeId;
          });
          util.assert(idx >= 0, "removeWrite called with nonexistent writeId.");
          var writeToRemove = this.allWrites_[idx];
          this.allWrites_.splice(idx, 1);
          var removedWriteWasVisible = writeToRemove.visible;
          var removedWriteOverlapsWithOtherWrites = false;
          var i = this.allWrites_.length - 1;
          while (removedWriteWasVisible && i >= 0) {
            var currentWrite = this.allWrites_[i];
            currentWrite.visible && (i >= idx && this.recordContainsPath_(currentWrite, writeToRemove.path) ? removedWriteWasVisible = false : writeToRemove.path.contains(currentWrite.path) && (removedWriteOverlapsWithOtherWrites = true));
            i--;
          }
          if (removedWriteWasVisible) {
            if (removedWriteOverlapsWithOtherWrites) {
              this.resetTree_();
              return true;
            }
            if (writeToRemove.snap) this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path); else {
              var children = writeToRemove.children;
              util.forEach(children, function(childName) {
                _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));
              });
            }
            return true;
          }
          return false;
        };
        WriteTree.prototype.getCompleteWriteData = function(path) {
          return this.visibleWrites_.getCompleteNode(path);
        };
        WriteTree.prototype.calcCompleteEventCache = function(treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
          if (writeIdsToExclude || includeHiddenWrites) {
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            if (!includeHiddenWrites && merge.isEmpty()) return completeServerCache;
            if (includeHiddenWrites || null != completeServerCache || merge.hasCompleteWrite(Path.Empty)) {
              var filter = function(write) {
                return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (write.path.contains(treePath) || treePath.contains(write.path));
              };
              var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);
              var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
              return mergeAtPath.apply(layeredCache);
            }
            return null;
          }
          var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);
          if (null != shadowingNode) return shadowingNode;
          var subMerge = this.visibleWrites_.childCompoundWrite(treePath);
          if (subMerge.isEmpty()) return completeServerCache;
          if (null != completeServerCache || subMerge.hasCompleteWrite(Path.Empty)) {
            var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
            return subMerge.apply(layeredCache);
          }
          return null;
        };
        WriteTree.prototype.calcCompleteEventChildren = function(treePath, completeServerChildren) {
          var completeChildren = ChildrenNode.EMPTY_NODE;
          var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);
          if (topLevelSet) {
            topLevelSet.isLeafNode() || topLevelSet.forEachChild(PRIORITY_INDEX, function(childName, childSnap) {
              completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
            });
            return completeChildren;
          }
          if (completeServerChildren) {
            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);
            completeServerChildren.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
              var node = merge_1.childCompoundWrite(new Path(childName)).apply(childNode);
              completeChildren = completeChildren.updateImmediateChild(childName, node);
            });
            merge_1.getCompleteChildren().forEach(function(namedNode) {
              completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
          }
          var merge = this.visibleWrites_.childCompoundWrite(treePath);
          merge.getCompleteChildren().forEach(function(namedNode) {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
          });
          return completeChildren;
        };
        WriteTree.prototype.calcEventCacheAfterServerOverwrite = function(treePath, childPath, existingEventSnap, existingServerSnap) {
          util.assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
          var path = treePath.child(childPath);
          if (this.visibleWrites_.hasCompleteWrite(path)) return null;
          var childMerge = this.visibleWrites_.childCompoundWrite(path);
          return childMerge.isEmpty() ? existingServerSnap.getChild(childPath) : childMerge.apply(existingServerSnap.getChild(childPath));
        };
        WriteTree.prototype.calcCompleteChild = function(treePath, childKey, existingServerSnap) {
          var path = treePath.child(childKey);
          var shadowingNode = this.visibleWrites_.getCompleteNode(path);
          if (null != shadowingNode) return shadowingNode;
          if (existingServerSnap.isCompleteForChild(childKey)) {
            var childMerge = this.visibleWrites_.childCompoundWrite(path);
            return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));
          }
          return null;
        };
        WriteTree.prototype.shadowingWrite = function(path) {
          return this.visibleWrites_.getCompleteNode(path);
        };
        WriteTree.prototype.calcIndexedSlice = function(treePath, completeServerData, startPost, count, reverse, index) {
          var toIterate;
          var merge = this.visibleWrites_.childCompoundWrite(treePath);
          var shadowingNode = merge.getCompleteNode(Path.Empty);
          if (null != shadowingNode) toIterate = shadowingNode; else {
            if (null == completeServerData) return [];
            toIterate = merge.apply(completeServerData);
          }
          toIterate = toIterate.withIndex(index);
          if (toIterate.isEmpty() || toIterate.isLeafNode()) return [];
          var nodes = [];
          var cmp = index.getCompare();
          var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
          var next = iter.getNext();
          while (next && nodes.length < count) {
            0 !== cmp(next, startPost) && nodes.push(next);
            next = iter.getNext();
          }
          return nodes;
        };
        WriteTree.prototype.recordContainsPath_ = function(writeRecord, path) {
          return writeRecord.snap ? writeRecord.path.contains(path) : !!util.findKey(writeRecord.children, function(childSnap, childName) {
            return writeRecord.path.child(childName).contains(path);
          });
        };
        WriteTree.prototype.resetTree_ = function() {
          this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path.Empty);
          this.allWrites_.length > 0 ? this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId : this.lastWriteId_ = -1;
        };
        WriteTree.DefaultFilter_ = function(write) {
          return write.visible;
        };
        WriteTree.layerTree_ = function(writes, filter, treeRoot) {
          var compoundWrite = CompoundWrite.Empty;
          for (var i = 0; i < writes.length; ++i) {
            var write = writes[i];
            if (filter(write)) {
              var writePath = write.path;
              var relativePath = void 0;
              if (write.snap) {
                if (treeRoot.contains(writePath)) {
                  relativePath = Path.relativePath(treeRoot, writePath);
                  compoundWrite = compoundWrite.addWrite(relativePath, write.snap);
                } else if (writePath.contains(treeRoot)) {
                  relativePath = Path.relativePath(writePath, treeRoot);
                  compoundWrite = compoundWrite.addWrite(Path.Empty, write.snap.getChild(relativePath));
                }
              } else {
                if (!write.children) throw util.assertionError("WriteRecord should have .snap or .children");
                if (treeRoot.contains(writePath)) {
                  relativePath = Path.relativePath(treeRoot, writePath);
                  compoundWrite = compoundWrite.addWrites(relativePath, write.children);
                } else if (writePath.contains(treeRoot)) {
                  relativePath = Path.relativePath(writePath, treeRoot);
                  if (relativePath.isEmpty()) compoundWrite = compoundWrite.addWrites(Path.Empty, write.children); else {
                    var child = util.safeGet(write.children, relativePath.getFront());
                    if (child) {
                      var deepNode = child.getChild(relativePath.popFront());
                      compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);
                    }
                  }
                }
              }
            }
          }
          return compoundWrite;
        };
        return WriteTree;
      }();
      var WriteTreeRef = function() {
        function WriteTreeRef(path, writeTree) {
          this.treePath_ = path;
          this.writeTree_ = writeTree;
        }
        WriteTreeRef.prototype.calcCompleteEventCache = function(completeServerCache, writeIdsToExclude, includeHiddenWrites) {
          return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);
        };
        WriteTreeRef.prototype.calcCompleteEventChildren = function(completeServerChildren) {
          return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);
        };
        WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function(path, existingEventSnap, existingServerSnap) {
          return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);
        };
        WriteTreeRef.prototype.shadowingWrite = function(path) {
          return this.writeTree_.shadowingWrite(this.treePath_.child(path));
        };
        WriteTreeRef.prototype.calcIndexedSlice = function(completeServerData, startPost, count, reverse, index) {
          return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);
        };
        WriteTreeRef.prototype.calcCompleteChild = function(childKey, existingServerCache) {
          return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);
        };
        WriteTreeRef.prototype.child = function(childName) {
          return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);
        };
        return WriteTreeRef;
      }();
      var SyncTree = function() {
        function SyncTree(listenProvider_) {
          this.listenProvider_ = listenProvider_;
          this.syncPointTree_ = ImmutableTree.Empty;
          this.pendingWriteTree_ = new WriteTree();
          this.tagToQueryMap_ = {};
          this.queryToTagMap_ = {};
        }
        SyncTree.prototype.applyUserOverwrite = function(path, newData, writeId, visible) {
          this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);
          return visible ? this.applyOperationToSyncPoints_(new Overwrite(OperationSource.User, path, newData)) : [];
        };
        SyncTree.prototype.applyUserMerge = function(path, changedChildren, writeId) {
          this.pendingWriteTree_.addMerge(path, changedChildren, writeId);
          var changeTree = ImmutableTree.fromObject(changedChildren);
          return this.applyOperationToSyncPoints_(new Merge(OperationSource.User, path, changeTree));
        };
        SyncTree.prototype.ackUserWrite = function(writeId, revert) {
          void 0 === revert && (revert = false);
          var write = this.pendingWriteTree_.getWrite(writeId);
          var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);
          if (needToReevaluate) {
            var affectedTree_1 = ImmutableTree.Empty;
            null != write.snap ? affectedTree_1 = affectedTree_1.set(Path.Empty, true) : util.forEach(write.children, function(pathString, node) {
              affectedTree_1 = affectedTree_1.set(new Path(pathString), node);
            });
            return this.applyOperationToSyncPoints_(new AckUserWrite(write.path, affectedTree_1, revert));
          }
          return [];
        };
        SyncTree.prototype.applyServerOverwrite = function(path, newData) {
          return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.Server, path, newData));
        };
        SyncTree.prototype.applyServerMerge = function(path, changedChildren) {
          var changeTree = ImmutableTree.fromObject(changedChildren);
          return this.applyOperationToSyncPoints_(new Merge(OperationSource.Server, path, changeTree));
        };
        SyncTree.prototype.applyListenComplete = function(path) {
          return this.applyOperationToSyncPoints_(new ListenComplete(OperationSource.Server, path));
        };
        SyncTree.prototype.applyTaggedQueryOverwrite = function(path, snap, tag) {
          var queryKey = this.queryKeyForTag_(tag);
          if (null != queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var op = new Overwrite(OperationSource.forServerTaggedQuery(queryId), relativePath, snap);
            return this.applyTaggedOperation_(queryPath, op);
          }
          return [];
        };
        SyncTree.prototype.applyTaggedQueryMerge = function(path, changedChildren, tag) {
          var queryKey = this.queryKeyForTag_(tag);
          if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var changeTree = ImmutableTree.fromObject(changedChildren);
            var op = new Merge(OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);
            return this.applyTaggedOperation_(queryPath, op);
          }
          return [];
        };
        SyncTree.prototype.applyTaggedListenComplete = function(path, tag) {
          var queryKey = this.queryKeyForTag_(tag);
          if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path.relativePath(queryPath, path);
            var op = new ListenComplete(OperationSource.forServerTaggedQuery(queryId), relativePath);
            return this.applyTaggedOperation_(queryPath, op);
          }
          return [];
        };
        SyncTree.prototype.addEventRegistration = function(query, eventRegistration) {
          var path = query.path;
          var serverCache = null;
          var foundAncestorDefaultView = false;
          this.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
            var relativePath = Path.relativePath(pathToSyncPoint, path);
            serverCache = serverCache || sp.getCompleteServerCache(relativePath);
            foundAncestorDefaultView = foundAncestorDefaultView || sp.hasCompleteView();
          });
          var syncPoint = this.syncPointTree_.get(path);
          if (syncPoint) {
            foundAncestorDefaultView = foundAncestorDefaultView || syncPoint.hasCompleteView();
            serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);
          } else {
            syncPoint = new SyncPoint();
            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);
          }
          var serverCacheComplete;
          if (null != serverCache) serverCacheComplete = true; else {
            serverCacheComplete = false;
            serverCache = ChildrenNode.EMPTY_NODE;
            var subtree = this.syncPointTree_.subtree(path);
            subtree.foreachChild(function(childName, childSyncPoint) {
              var completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);
              completeCache && (serverCache = serverCache.updateImmediateChild(childName, completeCache));
            });
          }
          var viewAlreadyExists = syncPoint.viewExistsForQuery(query);
          if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {
            var queryKey = SyncTree.makeQueryKey_(query);
            util.assert(!(queryKey in this.queryToTagMap_), "View does not exist, but we have a tag");
            var tag = SyncTree.getNextQueryTag_();
            this.queryToTagMap_[queryKey] = tag;
            this.tagToQueryMap_["_" + tag] = queryKey;
          }
          var writesCache = this.pendingWriteTree_.childWrites(path);
          var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);
          if (!viewAlreadyExists && !foundAncestorDefaultView) {
            var view = syncPoint.viewForQuery(query);
            events = events.concat(this.setupListener_(query, view));
          }
          return events;
        };
        SyncTree.prototype.removeEventRegistration = function(query, eventRegistration, cancelError) {
          var _this = this;
          var path = query.path;
          var maybeSyncPoint = this.syncPointTree_.get(path);
          var cancelEvents = [];
          if (maybeSyncPoint && ("default" === query.queryIdentifier() || maybeSyncPoint.viewExistsForQuery(query))) {
            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);
            maybeSyncPoint.isEmpty() && (this.syncPointTree_ = this.syncPointTree_.remove(path));
            var removed = removedAndEvents.removed;
            cancelEvents = removedAndEvents.events;
            var removingDefault = -1 !== removed.findIndex(function(query) {
              return query.getQueryParams().loadsAllData();
            });
            var covered = this.syncPointTree_.findOnPath(path, function(relativePath, parentSyncPoint) {
              return parentSyncPoint.hasCompleteView();
            });
            if (removingDefault && !covered) {
              var subtree = this.syncPointTree_.subtree(path);
              if (!subtree.isEmpty()) {
                var newViews = this.collectDistinctViewsForSubTree_(subtree);
                for (var i = 0; i < newViews.length; ++i) {
                  var view = newViews[i], newQuery = view.getQuery();
                  var listener = this.createListenerForView_(view);
                  this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);
                }
              }
            }
            if (!covered && removed.length > 0 && !cancelError) if (removingDefault) {
              var defaultTag = null;
              this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);
            } else removed.forEach(function(queryToRemove) {
              var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];
              _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);
            });
            this.removeTags_(removed);
          }
          return cancelEvents;
        };
        SyncTree.prototype.calcCompleteEventCache = function(path, writeIdsToExclude) {
          var includeHiddenSets = true;
          var writeTree = this.pendingWriteTree_;
          var serverCache = this.syncPointTree_.findOnPath(path, function(pathSoFar, syncPoint) {
            var relativePath = Path.relativePath(pathSoFar, path);
            var serverCache = syncPoint.getCompleteServerCache(relativePath);
            if (serverCache) return serverCache;
          });
          return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);
        };
        SyncTree.prototype.collectDistinctViewsForSubTree_ = function(subtree) {
          return subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {
              var completeView = maybeChildSyncPoint.getCompleteView();
              return [ completeView ];
            }
            var views_1 = [];
            maybeChildSyncPoint && (views_1 = maybeChildSyncPoint.getQueryViews());
            util.forEach(childMap, function(key, childViews) {
              views_1 = views_1.concat(childViews);
            });
            return views_1;
          });
        };
        SyncTree.prototype.removeTags_ = function(queries) {
          for (var j = 0; j < queries.length; ++j) {
            var removedQuery = queries[j];
            if (!removedQuery.getQueryParams().loadsAllData()) {
              var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);
              var removedQueryTag = this.queryToTagMap_[removedQueryKey];
              delete this.queryToTagMap_[removedQueryKey];
              delete this.tagToQueryMap_["_" + removedQueryTag];
            }
          }
        };
        SyncTree.queryForListening_ = function(query) {
          return query.getQueryParams().loadsAllData() && !query.getQueryParams().isDefault() ? query.getRef() : query;
        };
        SyncTree.prototype.setupListener_ = function(query, view) {
          var path = query.path;
          var tag = this.tagForQuery_(query);
          var listener = this.createListenerForView_(view);
          var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);
          var subtree = this.syncPointTree_.subtree(path);
          if (tag) util.assert(!subtree.value.hasCompleteView(), "If we're adding a query, it shouldn't be shadowed"); else {
            var queriesToStop = subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
              if (!relativePath.isEmpty() && maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) return [ maybeChildSyncPoint.getCompleteView().getQuery() ];
              var queries_1 = [];
              maybeChildSyncPoint && (queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function(view) {
                return view.getQuery();
              })));
              util.forEach(childMap, function(key, childQueries) {
                queries_1 = queries_1.concat(childQueries);
              });
              return queries_1;
            });
            for (var i = 0; i < queriesToStop.length; ++i) {
              var queryToStop = queriesToStop[i];
              this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));
            }
          }
          return events;
        };
        SyncTree.prototype.createListenerForView_ = function(view) {
          var _this = this;
          var query = view.getQuery();
          var tag = this.tagForQuery_(query);
          return {
            hashFn: function() {
              var cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;
              return cache.hash();
            },
            onComplete: function(status) {
              if ("ok" === status) return tag ? _this.applyTaggedListenComplete(query.path, tag) : _this.applyListenComplete(query.path);
              var error$$1 = errorForServerCode(status, query);
              return _this.removeEventRegistration(query, null, error$$1);
            }
          };
        };
        SyncTree.makeQueryKey_ = function(query) {
          return query.path.toString() + "$" + query.queryIdentifier();
        };
        SyncTree.parseQueryKey_ = function(queryKey) {
          var splitIndex = queryKey.indexOf("$");
          util.assert(-1 !== splitIndex && splitIndex < queryKey.length - 1, "Bad queryKey.");
          return {
            queryId: queryKey.substr(splitIndex + 1),
            path: new Path(queryKey.substr(0, splitIndex))
          };
        };
        SyncTree.prototype.queryKeyForTag_ = function(tag) {
          return this.tagToQueryMap_["_" + tag];
        };
        SyncTree.prototype.tagForQuery_ = function(query) {
          var queryKey = SyncTree.makeQueryKey_(query);
          return util.safeGet(this.queryToTagMap_, queryKey);
        };
        SyncTree.getNextQueryTag_ = function() {
          return SyncTree.nextQueryTag_++;
        };
        SyncTree.prototype.applyTaggedOperation_ = function(queryPath, operation) {
          var syncPoint = this.syncPointTree_.get(queryPath);
          util.assert(syncPoint, "Missing sync point for query tag that we're tracking");
          var writesCache = this.pendingWriteTree_.childWrites(queryPath);
          return syncPoint.applyOperation(operation, writesCache, null);
        };
        SyncTree.prototype.applyOperationToSyncPoints_ = function(operation) {
          return this.applyOperationHelper_(operation, this.syncPointTree_, null, this.pendingWriteTree_.childWrites(Path.Empty));
        };
        SyncTree.prototype.applyOperationHelper_ = function(operation, syncPointTree, serverCache, writesCache) {
          if (operation.path.isEmpty()) return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
          var syncPoint = syncPointTree.get(Path.Empty);
          null == serverCache && null != syncPoint && (serverCache = syncPoint.getCompleteServerCache(Path.Empty));
          var events = [];
          var childName = operation.path.getFront();
          var childOperation = operation.operationForChild(childName);
          var childTree = syncPointTree.children.get(childName);
          if (childTree && childOperation) {
            var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
            var childWritesCache = writesCache.child(childName);
            events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
          }
          syncPoint && (events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache)));
          return events;
        };
        SyncTree.prototype.applyOperationDescendantsHelper_ = function(operation, syncPointTree, serverCache, writesCache) {
          var _this = this;
          var syncPoint = syncPointTree.get(Path.Empty);
          null == serverCache && null != syncPoint && (serverCache = syncPoint.getCompleteServerCache(Path.Empty));
          var events = [];
          syncPointTree.children.inorderTraversal(function(childName, childTree) {
            var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
            var childWritesCache = writesCache.child(childName);
            var childOperation = operation.operationForChild(childName);
            childOperation && (events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache)));
          });
          syncPoint && (events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache)));
          return events;
        };
        SyncTree.nextQueryTag_ = 1;
        return SyncTree;
      }();
      var SnapshotHolder = function() {
        function SnapshotHolder() {
          this.rootNode_ = ChildrenNode.EMPTY_NODE;
        }
        SnapshotHolder.prototype.getNode = function(path) {
          return this.rootNode_.getChild(path);
        };
        SnapshotHolder.prototype.updateSnapshot = function(path, newSnapshotNode) {
          this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
        };
        return SnapshotHolder;
      }();
      var AuthTokenProvider = function() {
        function AuthTokenProvider(app_) {
          this.app_ = app_;
        }
        AuthTokenProvider.prototype.getToken = function(forceRefresh) {
          return this.app_["INTERNAL"]["getToken"](forceRefresh).then(null, function(error$$1) {
            if (error$$1 && "auth/token-not-initialized" === error$$1.code) {
              log("Got auth/token-not-initialized error.  Treating as null token.");
              return null;
            }
            return Promise.reject(error$$1);
          });
        };
        AuthTokenProvider.prototype.addTokenChangeListener = function(listener) {
          this.app_["INTERNAL"]["addAuthTokenListener"](listener);
        };
        AuthTokenProvider.prototype.removeTokenChangeListener = function(listener) {
          this.app_["INTERNAL"]["removeAuthTokenListener"](listener);
        };
        AuthTokenProvider.prototype.notifyForInvalidToken = function() {
          var errorMessage = 'Provided authentication credentials for the app named "' + this.app_.name + '" are invalid. This usually indicates your app was not initialized correctly. ';
          "credential" in this.app_.options ? errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.app_.options ? errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
          warn(errorMessage);
        };
        return AuthTokenProvider;
      }();
      var StatsCollection = function() {
        function StatsCollection() {
          this.counters_ = {};
        }
        StatsCollection.prototype.incrementCounter = function(name, amount) {
          void 0 === amount && (amount = 1);
          util.contains(this.counters_, name) || (this.counters_[name] = 0);
          this.counters_[name] += amount;
        };
        StatsCollection.prototype.get = function() {
          return util.deepCopy(this.counters_);
        };
        return StatsCollection;
      }();
      var StatsManager = function() {
        function StatsManager() {}
        StatsManager.getCollection = function(repoInfo) {
          var hashString = repoInfo.toString();
          this.collections_[hashString] || (this.collections_[hashString] = new StatsCollection());
          return this.collections_[hashString];
        };
        StatsManager.getOrCreateReporter = function(repoInfo, creatorFunction) {
          var hashString = repoInfo.toString();
          this.reporters_[hashString] || (this.reporters_[hashString] = creatorFunction());
          return this.reporters_[hashString];
        };
        StatsManager.collections_ = {};
        StatsManager.reporters_ = {};
        return StatsManager;
      }();
      var StatsListener = function() {
        function StatsListener(collection_) {
          this.collection_ = collection_;
          this.last_ = null;
        }
        StatsListener.prototype.get = function() {
          var newStats = this.collection_.get();
          var delta = util.clone(newStats);
          this.last_ && util.forEach(this.last_, function(stat, value) {
            delta[stat] = delta[stat] - value;
          });
          this.last_ = newStats;
          return delta;
        };
        return StatsListener;
      }();
      var FIRST_STATS_MIN_TIME = 1e4;
      var FIRST_STATS_MAX_TIME = 3e4;
      var REPORT_STATS_INTERVAL = 3e5;
      var StatsReporter = function() {
        function StatsReporter(collection, server_) {
          this.server_ = server_;
          this.statsToReport_ = {};
          this.statsListener_ = new StatsListener(collection);
          var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
          setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
        }
        StatsReporter.prototype.includeStat = function(stat) {
          this.statsToReport_[stat] = true;
        };
        StatsReporter.prototype.reportStats_ = function() {
          var _this = this;
          var stats = this.statsListener_.get();
          var reportedStats = {};
          var haveStatsToReport = false;
          util.forEach(stats, function(stat, value) {
            if (value > 0 && util.contains(_this.statsToReport_, stat)) {
              reportedStats[stat] = value;
              haveStatsToReport = true;
            }
          });
          haveStatsToReport && this.server_.reportStats(reportedStats);
          setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(2 * Math.random() * REPORT_STATS_INTERVAL));
        };
        return StatsReporter;
      }();
      var EventQueue = function() {
        function EventQueue() {
          this.eventLists_ = [];
          this.recursionDepth_ = 0;
        }
        EventQueue.prototype.queueEvents = function(eventDataList) {
          var currList = null;
          for (var i = 0; i < eventDataList.length; i++) {
            var eventData = eventDataList[i];
            var eventPath = eventData.getPath();
            if (null !== currList && !eventPath.equals(currList.getPath())) {
              this.eventLists_.push(currList);
              currList = null;
            }
            null === currList && (currList = new EventList(eventPath));
            currList.add(eventData);
          }
          currList && this.eventLists_.push(currList);
        };
        EventQueue.prototype.raiseEventsAtPath = function(path, eventDataList) {
          this.queueEvents(eventDataList);
          this.raiseQueuedEventsMatchingPredicate_(function(eventPath) {
            return eventPath.equals(path);
          });
        };
        EventQueue.prototype.raiseEventsForChangedPath = function(changedPath, eventDataList) {
          this.queueEvents(eventDataList);
          this.raiseQueuedEventsMatchingPredicate_(function(eventPath) {
            return eventPath.contains(changedPath) || changedPath.contains(eventPath);
          });
        };
        EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function(predicate) {
          this.recursionDepth_++;
          var sentAll = true;
          for (var i = 0; i < this.eventLists_.length; i++) {
            var eventList = this.eventLists_[i];
            if (eventList) {
              var eventPath = eventList.getPath();
              if (predicate(eventPath)) {
                this.eventLists_[i].raise();
                this.eventLists_[i] = null;
              } else sentAll = false;
            }
          }
          sentAll && (this.eventLists_ = []);
          this.recursionDepth_--;
        };
        return EventQueue;
      }();
      var EventList = function() {
        function EventList(path_) {
          this.path_ = path_;
          this.events_ = [];
        }
        EventList.prototype.add = function(eventData) {
          this.events_.push(eventData);
        };
        EventList.prototype.raise = function() {
          for (var i = 0; i < this.events_.length; i++) {
            var eventData = this.events_[i];
            if (null !== eventData) {
              this.events_[i] = null;
              var eventFn = eventData.getEventRunner();
              logger$1 && log("event: " + eventData.toString());
              exceptionGuard(eventFn);
            }
          }
        };
        EventList.prototype.getPath = function() {
          return this.path_;
        };
        return EventList;
      }();
      var EventEmitter = function() {
        function EventEmitter(allowedEvents_) {
          this.allowedEvents_ = allowedEvents_;
          this.listeners_ = {};
          util.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
        }
        EventEmitter.prototype.trigger = function(eventType) {
          var var_args = [];
          for (var _i = 1; _i < arguments.length; _i++) var_args[_i - 1] = arguments[_i];
          if (Array.isArray(this.listeners_[eventType])) {
            var listeners = this.listeners_[eventType].slice();
            for (var i = 0; i < listeners.length; i++) listeners[i].callback.apply(listeners[i].context, var_args);
          }
        };
        EventEmitter.prototype.on = function(eventType, callback, context) {
          this.validateEventType_(eventType);
          this.listeners_[eventType] = this.listeners_[eventType] || [];
          this.listeners_[eventType].push({
            callback: callback,
            context: context
          });
          var eventData = this.getInitialEvent(eventType);
          eventData && callback.apply(context, eventData);
        };
        EventEmitter.prototype.off = function(eventType, callback, context) {
          this.validateEventType_(eventType);
          var listeners = this.listeners_[eventType] || [];
          for (var i = 0; i < listeners.length; i++) if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {
            listeners.splice(i, 1);
            return;
          }
        };
        EventEmitter.prototype.validateEventType_ = function(eventType) {
          util.assert(this.allowedEvents_.find(function(et) {
            return et === eventType;
          }), "Unknown event: " + eventType);
        };
        return EventEmitter;
      }();
      var VisibilityMonitor = function(_super) {
        tslib_1.__extends(VisibilityMonitor, _super);
        function VisibilityMonitor() {
          var _this = _super.call(this, [ "visible" ]) || this;
          var hidden;
          var visibilityChange;
          if ("undefined" !== typeof document && "undefined" !== typeof document.addEventListener) if ("undefined" !== typeof document["hidden"]) {
            visibilityChange = "visibilitychange";
            hidden = "hidden";
          } else if ("undefined" !== typeof document["mozHidden"]) {
            visibilityChange = "mozvisibilitychange";
            hidden = "mozHidden";
          } else if ("undefined" !== typeof document["msHidden"]) {
            visibilityChange = "msvisibilitychange";
            hidden = "msHidden";
          } else if ("undefined" !== typeof document["webkitHidden"]) {
            visibilityChange = "webkitvisibilitychange";
            hidden = "webkitHidden";
          }
          _this.visible_ = true;
          visibilityChange && document.addEventListener(visibilityChange, function() {
            var visible = !document[hidden];
            if (visible !== _this.visible_) {
              _this.visible_ = visible;
              _this.trigger("visible", visible);
            }
          }, false);
          return _this;
        }
        VisibilityMonitor.getInstance = function() {
          return new VisibilityMonitor();
        };
        VisibilityMonitor.prototype.getInitialEvent = function(eventType) {
          util.assert("visible" === eventType, "Unknown event type: " + eventType);
          return [ this.visible_ ];
        };
        return VisibilityMonitor;
      }(EventEmitter);
      var OnlineMonitor = function(_super) {
        tslib_1.__extends(OnlineMonitor, _super);
        function OnlineMonitor() {
          var _this = _super.call(this, [ "online" ]) || this;
          _this.online_ = true;
          if ("undefined" !== typeof window && "undefined" !== typeof window.addEventListener && !util.isMobileCordova()) {
            window.addEventListener("online", function() {
              if (!_this.online_) {
                _this.online_ = true;
                _this.trigger("online", true);
              }
            }, false);
            window.addEventListener("offline", function() {
              if (_this.online_) {
                _this.online_ = false;
                _this.trigger("online", false);
              }
            }, false);
          }
          return _this;
        }
        OnlineMonitor.getInstance = function() {
          return new OnlineMonitor();
        };
        OnlineMonitor.prototype.getInitialEvent = function(eventType) {
          util.assert("online" === eventType, "Unknown event type: " + eventType);
          return [ this.online_ ];
        };
        OnlineMonitor.prototype.currentlyOnline = function() {
          return this.online_;
        };
        return OnlineMonitor;
      }(EventEmitter);
      var PacketReceiver = function() {
        function PacketReceiver(onMessage_) {
          this.onMessage_ = onMessage_;
          this.pendingResponses = [];
          this.currentResponseNum = 0;
          this.closeAfterResponse = -1;
          this.onClose = null;
        }
        PacketReceiver.prototype.closeAfter = function(responseNum, callback) {
          this.closeAfterResponse = responseNum;
          this.onClose = callback;
          if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
          }
        };
        PacketReceiver.prototype.handleResponse = function(requestNum, data) {
          var _this = this;
          this.pendingResponses[requestNum] = data;
          var _loop_1 = function() {
            var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
            delete this_1.pendingResponses[this_1.currentResponseNum];
            var _loop_2 = function(i) {
              toProcess[i] && exceptionGuard(function() {
                _this.onMessage_(toProcess[i]);
              });
            };
            for (var i = 0; i < toProcess.length; ++i) _loop_2(i);
            if (this_1.currentResponseNum === this_1.closeAfterResponse) {
              if (this_1.onClose) {
                this_1.onClose();
                this_1.onClose = null;
              }
              return "break";
            }
            this_1.currentResponseNum++;
          };
          var this_1 = this;
          while (this.pendingResponses[this.currentResponseNum]) {
            var state_1 = _loop_1();
            if ("break" === state_1) break;
          }
        };
        return PacketReceiver;
      }();
      var FIREBASE_LONGPOLL_START_PARAM = "start";
      var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
      var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
      var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
      var FIREBASE_LONGPOLL_ID_PARAM = "id";
      var FIREBASE_LONGPOLL_PW_PARAM = "pw";
      var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
      var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
      var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
      var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
      var FIREBASE_LONGPOLL_DATA_PARAM = "d";
      var FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = "disconn";
      var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
      var MAX_URL_DATA_SIZE = 1870;
      var SEG_HEADER_SIZE = 30;
      var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
      var KEEPALIVE_REQUEST_INTERVAL = 25e3;
      var LP_CONNECT_TIMEOUT = 3e4;
      var BrowserPollConnection = function() {
        function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {
          this.connId = connId;
          this.repoInfo = repoInfo;
          this.transportSessionId = transportSessionId;
          this.lastSessionId = lastSessionId;
          this.bytesSent = 0;
          this.bytesReceived = 0;
          this.everConnected_ = false;
          this.log_ = logWrapper(connId);
          this.stats_ = StatsManager.getCollection(repoInfo);
          this.urlFn = function(params) {
            return repoInfo.connectionURL(LONG_POLLING, params);
          };
        }
        BrowserPollConnection.prototype.open = function(onMessage, onDisconnect) {
          var _this = this;
          this.curSegmentNum = 0;
          this.onDisconnect_ = onDisconnect;
          this.myPacketOrderer = new PacketReceiver(onMessage);
          this.isClosed_ = false;
          this.connectTimeoutTimer_ = setTimeout(function() {
            _this.log_("Timed out trying to connect.");
            _this.onClosed_();
            _this.connectTimeoutTimer_ = null;
          }, Math.floor(LP_CONNECT_TIMEOUT));
          executeWhenDOMReady(function() {
            if (_this.isClosed_) return;
            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
              var command = args[0], arg1 = args[1], arg2 = args[2];
              _this.incrementIncomingBytes_(args);
              if (!_this.scriptTagHolder) return;
              if (_this.connectTimeoutTimer_) {
                clearTimeout(_this.connectTimeoutTimer_);
                _this.connectTimeoutTimer_ = null;
              }
              _this.everConnected_ = true;
              if (command == FIREBASE_LONGPOLL_START_PARAM) {
                _this.id = arg1;
                _this.password = arg2;
              } else {
                if (command !== FIREBASE_LONGPOLL_CLOSE_COMMAND) throw new Error("Unrecognized command received: " + command);
                if (arg1) {
                  _this.scriptTagHolder.sendNewPolls = false;
                  _this.myPacketOrderer.closeAfter(arg1, function() {
                    _this.onClosed_();
                  });
                } else _this.onClosed_();
              }
            }, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
              var pN = args[0], data = args[1];
              _this.incrementIncomingBytes_(args);
              _this.myPacketOrderer.handleResponse(pN, data);
            }, function() {
              _this.onClosed_();
            }, _this.urlFn);
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(1e8 * Math.random());
            _this.scriptTagHolder.uniqueCallbackIdentifier && (urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier);
            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
            _this.transportSessionId && (urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId);
            _this.lastSessionId && (urlParams[LAST_SESSION_PARAM] = _this.lastSessionId);
            !util.isNodeSdk() && "undefined" !== typeof location && location.href && -1 !== location.href.indexOf(FORGE_DOMAIN) && (urlParams[REFERER_PARAM] = FORGE_REF);
            var connectURL = _this.urlFn(urlParams);
            _this.log_("Connecting via long-poll to " + connectURL);
            _this.scriptTagHolder.addTag(connectURL, function() {});
          });
        };
        BrowserPollConnection.prototype.start = function() {
          this.scriptTagHolder.startLongPoll(this.id, this.password);
          this.addDisconnectPingFrame(this.id, this.password);
        };
        BrowserPollConnection.forceAllow = function() {
          BrowserPollConnection.forceAllow_ = true;
        };
        BrowserPollConnection.forceDisallow = function() {
          BrowserPollConnection.forceDisallow_ = true;
        };
        BrowserPollConnection.isAvailable = function() {
          return BrowserPollConnection.forceAllow_ || !BrowserPollConnection.forceDisallow_ && "undefined" !== typeof document && null != document.createElement && !isChromeExtensionContentScript() && !isWindowsStoreApp() && !util.isNodeSdk();
        };
        BrowserPollConnection.prototype.markConnectionHealthy = function() {};
        BrowserPollConnection.prototype.shutdown_ = function() {
          this.isClosed_ = true;
          if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
          }
          if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
          }
          if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
          }
        };
        BrowserPollConnection.prototype.onClosed_ = function() {
          if (!this.isClosed_) {
            this.log_("Longpoll is closing itself");
            this.shutdown_();
            if (this.onDisconnect_) {
              this.onDisconnect_(this.everConnected_);
              this.onDisconnect_ = null;
            }
          }
        };
        BrowserPollConnection.prototype.close = function() {
          if (!this.isClosed_) {
            this.log_("Longpoll is being closed.");
            this.shutdown_();
          }
        };
        BrowserPollConnection.prototype.send = function(data) {
          var dataStr = util.stringify(data);
          this.bytesSent += dataStr.length;
          this.stats_.incrementCounter("bytes_sent", dataStr.length);
          var base64data = util.base64Encode(dataStr);
          var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
          for (var i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
          }
        };
        BrowserPollConnection.prototype.addDisconnectPingFrame = function(id, pw) {
          if (util.isNodeSdk()) return;
          this.myDisconnFrame = document.createElement("iframe");
          var urlParams = {};
          urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
          urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
          urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
          this.myDisconnFrame.src = this.urlFn(urlParams);
          this.myDisconnFrame.style.display = "none";
          document.body.appendChild(this.myDisconnFrame);
        };
        BrowserPollConnection.prototype.incrementIncomingBytes_ = function(args) {
          var bytesReceived = util.stringify(args).length;
          this.bytesReceived += bytesReceived;
          this.stats_.incrementCounter("bytes_received", bytesReceived);
        };
        return BrowserPollConnection;
      }();
      var FirebaseIFrameScriptHolder = function() {
        function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {
          this.onDisconnect = onDisconnect;
          this.urlFn = urlFn;
          this.outstandingRequests = new CountedSet();
          this.pendingSegs = [];
          this.currentSerial = Math.floor(1e8 * Math.random());
          this.sendNewPolls = true;
          if (util.isNodeSdk()) {
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
          } else {
            this.uniqueCallbackIdentifier = LUIDGenerator();
            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            var script = "";
            if (this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, "javascript:".length)) {
              var currentDomain = document.domain;
              script = '<script>document.domain="' + currentDomain + '";<\/script>';
            }
            var iframeContents = "<html><body>" + script + "</body></html>";
            try {
              this.myIFrame.doc.open();
              this.myIFrame.doc.write(iframeContents);
              this.myIFrame.doc.close();
            } catch (e) {
              log("frame writing exception");
              e.stack && log(e.stack);
              log(e);
            }
          }
        }
        FirebaseIFrameScriptHolder.createIFrame_ = function() {
          var iframe = document.createElement("iframe");
          iframe.style.display = "none";
          if (!document.body) throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
          document.body.appendChild(iframe);
          try {
            var a = iframe.contentWindow.document;
            a || log("No IE domain setting required");
          } catch (e) {
            var domain = document.domain;
            iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
          }
          iframe.contentDocument ? iframe.doc = iframe.contentDocument : iframe.contentWindow ? iframe.doc = iframe.contentWindow.document : iframe.document && (iframe.doc = iframe.document);
          return iframe;
        };
        FirebaseIFrameScriptHolder.prototype.close = function() {
          var _this = this;
          this.alive = false;
          if (this.myIFrame) {
            this.myIFrame.doc.body.innerHTML = "";
            setTimeout(function() {
              if (null !== _this.myIFrame) {
                document.body.removeChild(_this.myIFrame);
                _this.myIFrame = null;
              }
            }, Math.floor(0));
          }
          if (util.isNodeSdk() && this.myID) {
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = "t";
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            var theURL = this.urlFn(urlParams);
            FirebaseIFrameScriptHolder.nodeRestRequest(theURL);
          }
          var onDisconnect = this.onDisconnect;
          if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
          }
        };
        FirebaseIFrameScriptHolder.prototype.startLongPoll = function(id, pw) {
          this.myID = id;
          this.myPW = pw;
          this.alive = true;
          while (this.newRequest_()) ;
        };
        FirebaseIFrameScriptHolder.prototype.newRequest_ = function() {
          if (this.alive && this.sendNewPolls && this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {
            this.currentSerial++;
            var urlParams = {};
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            var theURL = this.urlFn(urlParams);
            var curDataString = "";
            var i = 0;
            while (this.pendingSegs.length > 0) {
              var nextSeg = this.pendingSegs[0];
              if (!(nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE)) break;
              var theSeg = this.pendingSegs.shift();
              curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
              i++;
            }
            theURL += curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
          }
          return false;
        };
        FirebaseIFrameScriptHolder.prototype.enqueueSegment = function(segnum, totalsegs, data) {
          this.pendingSegs.push({
            seg: segnum,
            ts: totalsegs,
            d: data
          });
          this.alive && this.newRequest_();
        };
        FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function(url, serial) {
          var _this = this;
          this.outstandingRequests.add(serial, 1);
          var doNewRequest = function() {
            _this.outstandingRequests.remove(serial);
            _this.newRequest_();
          };
          var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
          var readyStateCB = function() {
            clearTimeout(keepaliveTimeout);
            doNewRequest();
          };
          this.addTag(url, readyStateCB);
        };
        FirebaseIFrameScriptHolder.prototype.addTag = function(url, loadCB) {
          var _this = this;
          util.isNodeSdk() ? this.doNodeLongPoll(url, loadCB) : setTimeout(function() {
            try {
              if (!_this.sendNewPolls) return;
              var newScript_1 = _this.myIFrame.doc.createElement("script");
              newScript_1.type = "text/javascript";
              newScript_1.async = true;
              newScript_1.src = url;
              newScript_1.onload = newScript_1.onreadystatechange = function() {
                var rstate = newScript_1.readyState;
                if (!rstate || "loaded" === rstate || "complete" === rstate) {
                  newScript_1.onload = newScript_1.onreadystatechange = null;
                  newScript_1.parentNode && newScript_1.parentNode.removeChild(newScript_1);
                  loadCB();
                }
              };
              newScript_1.onerror = function() {
                log("Long-poll script failed to load: " + url);
                _this.sendNewPolls = false;
                _this.close();
              };
              _this.myIFrame.doc.body.appendChild(newScript_1);
            } catch (e) {}
          }, Math.floor(1));
        };
        return FirebaseIFrameScriptHolder;
      }();
      var WEBSOCKET_MAX_FRAME_SIZE = 16384;
      var WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
      var WebSocketImpl = null;
      "undefined" !== typeof MozWebSocket ? WebSocketImpl = MozWebSocket : "undefined" !== typeof WebSocket && (WebSocketImpl = WebSocket);
      var WebSocketConnection = function() {
        function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {
          this.connId = connId;
          this.keepaliveTimer = null;
          this.frames = null;
          this.totalFrames = 0;
          this.bytesSent = 0;
          this.bytesReceived = 0;
          this.log_ = logWrapper(this.connId);
          this.stats_ = StatsManager.getCollection(repoInfo);
          this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);
        }
        WebSocketConnection.connectionURL_ = function(repoInfo, transportSessionId, lastSessionId) {
          var urlParams = {};
          urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
          !util.isNodeSdk() && "undefined" !== typeof location && location.href && -1 !== location.href.indexOf(FORGE_DOMAIN) && (urlParams[REFERER_PARAM] = FORGE_REF);
          transportSessionId && (urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId);
          lastSessionId && (urlParams[LAST_SESSION_PARAM] = lastSessionId);
          return repoInfo.connectionURL(WEBSOCKET, urlParams);
        };
        WebSocketConnection.prototype.open = function(onMessage, onDisconnect) {
          var _this = this;
          this.onDisconnect = onDisconnect;
          this.onMessage = onMessage;
          this.log_("Websocket connecting to " + this.connURL);
          this.everConnected_ = false;
          PersistentStorage.set("previous_websocket_failure", true);
          try {
            if (util.isNodeSdk()) {
              var device = util.CONSTANTS.NODE_ADMIN ? "AdminNode" : "Node";
              var options = {
                headers: {
                  "User-Agent": "Firebase/" + PROTOCOL_VERSION + "/" + firebase.SDK_VERSION + "/" + process.platform + "/" + device
                }
              };
              var env = process["env"];
              var proxy = 0 == this.connURL.indexOf("wss://") ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
              proxy && (options["proxy"] = {
                origin: proxy
              });
              this.mySock = new WebSocketImpl(this.connURL, [], options);
            } else this.mySock = new WebSocketImpl(this.connURL);
          } catch (e) {
            this.log_("Error instantiating WebSocket.");
            var error$$1 = e.message || e.data;
            error$$1 && this.log_(error$$1);
            this.onClosed_();
            return;
          }
          this.mySock.onopen = function() {
            _this.log_("Websocket connected.");
            _this.everConnected_ = true;
          };
          this.mySock.onclose = function() {
            _this.log_("Websocket connection was disconnected.");
            _this.mySock = null;
            _this.onClosed_();
          };
          this.mySock.onmessage = function(m) {
            _this.handleIncomingFrame(m);
          };
          this.mySock.onerror = function(e) {
            _this.log_("WebSocket error.  Closing connection.");
            var error$$1 = e.message || e.data;
            error$$1 && _this.log_(error$$1);
            _this.onClosed_();
          };
        };
        WebSocketConnection.prototype.start = function() {};
        WebSocketConnection.forceDisallow = function() {
          WebSocketConnection.forceDisallow_ = true;
        };
        WebSocketConnection.isAvailable = function() {
          var isOldAndroid = false;
          if ("undefined" !== typeof navigator && navigator.userAgent) {
            var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            oldAndroidMatch && oldAndroidMatch.length > 1 && parseFloat(oldAndroidMatch[1]) < 4.4 && (isOldAndroid = true);
          }
          return !isOldAndroid && null !== WebSocketImpl && !WebSocketConnection.forceDisallow_;
        };
        WebSocketConnection.previouslyFailed = function() {
          return PersistentStorage.isInMemoryStorage || true === PersistentStorage.get("previous_websocket_failure");
        };
        WebSocketConnection.prototype.markConnectionHealthy = function() {
          PersistentStorage.remove("previous_websocket_failure");
        };
        WebSocketConnection.prototype.appendFrame_ = function(data) {
          this.frames.push(data);
          if (this.frames.length == this.totalFrames) {
            var fullMess = this.frames.join("");
            this.frames = null;
            var jsonMess = util.jsonEval(fullMess);
            this.onMessage(jsonMess);
          }
        };
        WebSocketConnection.prototype.handleNewFrameCount_ = function(frameCount) {
          this.totalFrames = frameCount;
          this.frames = [];
        };
        WebSocketConnection.prototype.extractFrameCount_ = function(data) {
          util.assert(null === this.frames, "We already have a frame buffer");
          if (data.length <= 6) {
            var frameCount = Number(data);
            if (!isNaN(frameCount)) {
              this.handleNewFrameCount_(frameCount);
              return null;
            }
          }
          this.handleNewFrameCount_(1);
          return data;
        };
        WebSocketConnection.prototype.handleIncomingFrame = function(mess) {
          if (null === this.mySock) return;
          var data = mess["data"];
          this.bytesReceived += data.length;
          this.stats_.incrementCounter("bytes_received", data.length);
          this.resetKeepAlive();
          if (null !== this.frames) this.appendFrame_(data); else {
            var remainingData = this.extractFrameCount_(data);
            null !== remainingData && this.appendFrame_(remainingData);
          }
        };
        WebSocketConnection.prototype.send = function(data) {
          this.resetKeepAlive();
          var dataStr = util.stringify(data);
          this.bytesSent += dataStr.length;
          this.stats_.incrementCounter("bytes_sent", dataStr.length);
          var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
          dataSegs.length > 1 && this.sendString_(String(dataSegs.length));
          for (var i = 0; i < dataSegs.length; i++) this.sendString_(dataSegs[i]);
        };
        WebSocketConnection.prototype.shutdown_ = function() {
          this.isClosed_ = true;
          if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
          }
          if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
          }
        };
        WebSocketConnection.prototype.onClosed_ = function() {
          if (!this.isClosed_) {
            this.log_("WebSocket is closing itself");
            this.shutdown_();
            if (this.onDisconnect) {
              this.onDisconnect(this.everConnected_);
              this.onDisconnect = null;
            }
          }
        };
        WebSocketConnection.prototype.close = function() {
          if (!this.isClosed_) {
            this.log_("WebSocket is being closed");
            this.shutdown_();
          }
        };
        WebSocketConnection.prototype.resetKeepAlive = function() {
          var _this = this;
          clearInterval(this.keepaliveTimer);
          this.keepaliveTimer = setInterval(function() {
            _this.mySock && _this.sendString_("0");
            _this.resetKeepAlive();
          }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
        };
        WebSocketConnection.prototype.sendString_ = function(str) {
          try {
            this.mySock.send(str);
          } catch (e) {
            this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
            setTimeout(this.onClosed_.bind(this), 0);
          }
        };
        WebSocketConnection.responsesRequiredToBeHealthy = 2;
        WebSocketConnection.healthyTimeout = 3e4;
        return WebSocketConnection;
      }();
      var TransportManager = function() {
        function TransportManager(repoInfo) {
          this.initTransports_(repoInfo);
        }
        Object.defineProperty(TransportManager, "ALL_TRANSPORTS", {
          get: function() {
            return [ BrowserPollConnection, WebSocketConnection ];
          },
          enumerable: true,
          configurable: true
        });
        TransportManager.prototype.initTransports_ = function(repoInfo) {
          var isWebSocketsAvailable = WebSocketConnection && WebSocketConnection["isAvailable"]();
          var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
          if (repoInfo.webSocketOnly) {
            isWebSocketsAvailable || warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            isSkipPollConnection = true;
          }
          if (isSkipPollConnection) this.transports_ = [ WebSocketConnection ]; else {
            var transports_1 = this.transports_ = [];
            each(TransportManager.ALL_TRANSPORTS, function(i, transport) {
              transport && transport["isAvailable"]() && transports_1.push(transport);
            });
          }
        };
        TransportManager.prototype.initialTransport = function() {
          if (this.transports_.length > 0) return this.transports_[0];
          throw new Error("No transports available");
        };
        TransportManager.prototype.upgradeTransport = function() {
          return this.transports_.length > 1 ? this.transports_[1] : null;
        };
        return TransportManager;
      }();
      var UPGRADE_TIMEOUT = 6e4;
      var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
      var BYTES_SENT_HEALTHY_OVERRIDE = 10240;
      var BYTES_RECEIVED_HEALTHY_OVERRIDE = 102400;
      var MESSAGE_TYPE = "t";
      var MESSAGE_DATA = "d";
      var CONTROL_SHUTDOWN = "s";
      var CONTROL_RESET = "r";
      var CONTROL_ERROR = "e";
      var CONTROL_PONG = "o";
      var SWITCH_ACK = "a";
      var END_TRANSMISSION = "n";
      var PING = "p";
      var SERVER_HELLO = "h";
      var Connection = function() {
        function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
          this.id = id;
          this.repoInfo_ = repoInfo_;
          this.onMessage_ = onMessage_;
          this.onReady_ = onReady_;
          this.onDisconnect_ = onDisconnect_;
          this.onKill_ = onKill_;
          this.lastSessionId = lastSessionId;
          this.connectionCount = 0;
          this.pendingDataMessages = [];
          this.state_ = 0;
          this.log_ = logWrapper("c:" + this.id + ":");
          this.transportManager_ = new TransportManager(repoInfo_);
          this.log_("Connection created");
          this.start_();
        }
        Connection.prototype.start_ = function() {
          var _this = this;
          var conn = this.transportManager_.initialTransport();
          this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, void 0, this.lastSessionId);
          this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
          var onMessageReceived = this.connReceiver_(this.conn_);
          var onConnectionLost = this.disconnReceiver_(this.conn_);
          this.tx_ = this.conn_;
          this.rx_ = this.conn_;
          this.secondaryConn_ = null;
          this.isHealthy_ = false;
          setTimeout(function() {
            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
          }, Math.floor(0));
          var healthyTimeout_ms = conn["healthyTimeout"] || 0;
          healthyTimeout_ms > 0 && (this.healthyTimeout_ = setTimeoutNonBlocking(function() {
            _this.healthyTimeout_ = null;
            if (!_this.isHealthy_) if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
              _this.log_("Connection exceeded healthy timeout but has received " + _this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
              _this.isHealthy_ = true;
              _this.conn_.markConnectionHealthy();
            } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) _this.log_("Connection exceeded healthy timeout but has sent " + _this.conn_.bytesSent + " bytes.  Leaving connection alive."); else {
              _this.log_("Closing unhealthy connection after timeout.");
              _this.close();
            }
          }, Math.floor(healthyTimeout_ms)));
        };
        Connection.prototype.nextTransportId_ = function() {
          return "c:" + this.id + ":" + this.connectionCount++;
        };
        Connection.prototype.disconnReceiver_ = function(conn) {
          var _this = this;
          return function(everConnected) {
            if (conn === _this.conn_) _this.onConnectionLost_(everConnected); else if (conn === _this.secondaryConn_) {
              _this.log_("Secondary connection lost.");
              _this.onSecondaryConnectionLost_();
            } else _this.log_("closing an old connection");
          };
        };
        Connection.prototype.connReceiver_ = function(conn) {
          var _this = this;
          return function(message) {
            2 != _this.state_ && (conn === _this.rx_ ? _this.onPrimaryMessageReceived_(message) : conn === _this.secondaryConn_ ? _this.onSecondaryMessageReceived_(message) : _this.log_("message on old connection"));
          };
        };
        Connection.prototype.sendRequest = function(dataMsg) {
          var msg = {
            t: "d",
            d: dataMsg
          };
          this.sendData_(msg);
        };
        Connection.prototype.tryCleanupConnection = function() {
          if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
          }
        };
        Connection.prototype.onSecondaryControl_ = function(controlData) {
          if (MESSAGE_TYPE in controlData) {
            var cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) this.upgradeIfSecondaryHealthy_(); else if (cmd === CONTROL_RESET) {
              this.log_("Got a reset on secondary, closing it");
              this.secondaryConn_.close();
              this.tx_ !== this.secondaryConn_ && this.rx_ !== this.secondaryConn_ || this.close();
            } else if (cmd === CONTROL_PONG) {
              this.log_("got pong on secondary.");
              this.secondaryResponsesRequired_--;
              this.upgradeIfSecondaryHealthy_();
            }
          }
        };
        Connection.prototype.onSecondaryMessageReceived_ = function(parsedData) {
          var layer = requireKey("t", parsedData);
          var data = requireKey("d", parsedData);
          if ("c" == layer) this.onSecondaryControl_(data); else {
            if ("d" != layer) throw new Error("Unknown protocol layer: " + layer);
            this.pendingDataMessages.push(data);
          }
        };
        Connection.prototype.upgradeIfSecondaryHealthy_ = function() {
          if (this.secondaryResponsesRequired_ <= 0) {
            this.log_("Secondary connection is healthy.");
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
          } else {
            this.log_("sending ping on secondary.");
            this.secondaryConn_.send({
              t: "c",
              d: {
                t: PING,
                d: {}
              }
            });
          }
        };
        Connection.prototype.proceedWithUpgrade_ = function() {
          this.secondaryConn_.start();
          this.log_("sending client ack on secondary");
          this.secondaryConn_.send({
            t: "c",
            d: {
              t: SWITCH_ACK,
              d: {}
            }
          });
          this.log_("Ending transmission on primary");
          this.conn_.send({
            t: "c",
            d: {
              t: END_TRANSMISSION,
              d: {}
            }
          });
          this.tx_ = this.secondaryConn_;
          this.tryCleanupConnection();
        };
        Connection.prototype.onPrimaryMessageReceived_ = function(parsedData) {
          var layer = requireKey("t", parsedData);
          var data = requireKey("d", parsedData);
          "c" == layer ? this.onControl_(data) : "d" == layer && this.onDataMessage_(data);
        };
        Connection.prototype.onDataMessage_ = function(message) {
          this.onPrimaryResponse_();
          this.onMessage_(message);
        };
        Connection.prototype.onPrimaryResponse_ = function() {
          if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
              this.log_("Primary connection is healthy.");
              this.isHealthy_ = true;
              this.conn_.markConnectionHealthy();
            }
          }
        };
        Connection.prototype.onControl_ = function(controlData) {
          var cmd = requireKey(MESSAGE_TYPE, controlData);
          if (MESSAGE_DATA in controlData) {
            var payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) this.onHandshake_(payload); else if (cmd === END_TRANSMISSION) {
              this.log_("recvd end transmission on primary");
              this.rx_ = this.secondaryConn_;
              for (var i = 0; i < this.pendingDataMessages.length; ++i) this.onDataMessage_(this.pendingDataMessages[i]);
              this.pendingDataMessages = [];
              this.tryCleanupConnection();
            } else if (cmd === CONTROL_SHUTDOWN) this.onConnectionShutdown_(payload); else if (cmd === CONTROL_RESET) this.onReset_(payload); else if (cmd === CONTROL_ERROR) error("Server Error: " + payload); else if (cmd === CONTROL_PONG) {
              this.log_("got pong on primary.");
              this.onPrimaryResponse_();
              this.sendPingOnPrimaryIfNecessary_();
            } else error("Unknown control packet command: " + cmd);
          }
        };
        Connection.prototype.onHandshake_ = function(handshake) {
          var timestamp = handshake.ts;
          var version = handshake.v;
          var host = handshake.h;
          this.sessionId = handshake.s;
          this.repoInfo_.updateHost(host);
          if (0 == this.state_) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            PROTOCOL_VERSION !== version && warn("Protocol version mismatch detected");
            this.tryStartUpgrade_();
          }
        };
        Connection.prototype.tryStartUpgrade_ = function() {
          var conn = this.transportManager_.upgradeTransport();
          conn && this.startUpgrade_(conn);
        };
        Connection.prototype.startUpgrade_ = function(conn) {
          var _this = this;
          this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);
          this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
          var onMessage = this.connReceiver_(this.secondaryConn_);
          var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
          this.secondaryConn_.open(onMessage, onDisconnect);
          setTimeoutNonBlocking(function() {
            if (_this.secondaryConn_) {
              _this.log_("Timed out trying to upgrade.");
              _this.secondaryConn_.close();
            }
          }, Math.floor(UPGRADE_TIMEOUT));
        };
        Connection.prototype.onReset_ = function(host) {
          this.log_("Reset packet received.  New host: " + host);
          this.repoInfo_.updateHost(host);
          if (1 === this.state_) this.close(); else {
            this.closeConnections_();
            this.start_();
          }
        };
        Connection.prototype.onConnectionEstablished_ = function(conn, timestamp) {
          var _this = this;
          this.log_("Realtime connection established.");
          this.conn_ = conn;
          this.state_ = 1;
          if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
          }
          if (0 === this.primaryResponsesRequired_) {
            this.log_("Primary connection is healthy.");
            this.isHealthy_ = true;
          } else setTimeoutNonBlocking(function() {
            _this.sendPingOnPrimaryIfNecessary_();
          }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        };
        Connection.prototype.sendPingOnPrimaryIfNecessary_ = function() {
          if (!this.isHealthy_ && 1 === this.state_) {
            this.log_("sending ping on primary.");
            this.sendData_({
              t: "c",
              d: {
                t: PING,
                d: {}
              }
            });
          }
        };
        Connection.prototype.onSecondaryConnectionLost_ = function() {
          var conn = this.secondaryConn_;
          this.secondaryConn_ = null;
          this.tx_ !== conn && this.rx_ !== conn || this.close();
        };
        Connection.prototype.onConnectionLost_ = function(everConnected) {
          this.conn_ = null;
          if (everConnected || 0 !== this.state_) 1 === this.state_ && this.log_("Realtime connection lost."); else {
            this.log_("Realtime connection failed.");
            if (this.repoInfo_.isCacheableHost()) {
              PersistentStorage.remove("host:" + this.repoInfo_.host);
              this.repoInfo_.internalHost = this.repoInfo_.host;
            }
          }
          this.close();
        };
        Connection.prototype.onConnectionShutdown_ = function(reason) {
          this.log_("Connection shutdown command received. Shutting down...");
          if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
          }
          this.onDisconnect_ = null;
          this.close();
        };
        Connection.prototype.sendData_ = function(data) {
          if (1 !== this.state_) throw "Connection is not connected";
          this.tx_.send(data);
        };
        Connection.prototype.close = function() {
          if (2 !== this.state_) {
            this.log_("Closing realtime connection.");
            this.state_ = 2;
            this.closeConnections_();
            if (this.onDisconnect_) {
              this.onDisconnect_();
              this.onDisconnect_ = null;
            }
          }
        };
        Connection.prototype.closeConnections_ = function() {
          this.log_("Shutting down all connections");
          if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
          }
          if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
          }
          if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
          }
        };
        return Connection;
      }();
      var ServerActions = function() {
        function ServerActions() {}
        ServerActions.prototype.put = function(pathString, data, onComplete, hash) {};
        ServerActions.prototype.merge = function(pathString, data, onComplete, hash) {};
        ServerActions.prototype.refreshAuthToken = function(token) {};
        ServerActions.prototype.onDisconnectPut = function(pathString, data, onComplete) {};
        ServerActions.prototype.onDisconnectMerge = function(pathString, data, onComplete) {};
        ServerActions.prototype.onDisconnectCancel = function(pathString, onComplete) {};
        ServerActions.prototype.reportStats = function(stats) {};
        return ServerActions;
      }();
      var RECONNECT_MIN_DELAY = 1e3;
      var RECONNECT_MAX_DELAY_DEFAULT = 3e5;
      var RECONNECT_MAX_DELAY_FOR_ADMINS = 3e4;
      var RECONNECT_DELAY_MULTIPLIER = 1.3;
      var RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
      var SERVER_KILL_INTERRUPT_REASON = "server_kill";
      var INVALID_AUTH_TOKEN_THRESHOLD = 3;
      var PersistentConnection = function(_super) {
        tslib_1.__extends(PersistentConnection, _super);
        function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {
          var _this = _super.call(this) || this;
          _this.repoInfo_ = repoInfo_;
          _this.onDataUpdate_ = onDataUpdate_;
          _this.onConnectStatus_ = onConnectStatus_;
          _this.onServerInfoUpdate_ = onServerInfoUpdate_;
          _this.authTokenProvider_ = authTokenProvider_;
          _this.authOverride_ = authOverride_;
          _this.id = PersistentConnection.nextPersistentConnectionId_++;
          _this.log_ = logWrapper("p:" + _this.id + ":");
          _this.interruptReasons_ = {};
          _this.listens_ = {};
          _this.outstandingPuts_ = [];
          _this.outstandingPutCount_ = 0;
          _this.onDisconnectRequestQueue_ = [];
          _this.connected_ = false;
          _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
          _this.securityDebugCallback_ = null;
          _this.lastSessionId = null;
          _this.establishConnectionTimer_ = null;
          _this.visible_ = false;
          _this.requestCBHash_ = {};
          _this.requestNumber_ = 0;
          _this.realtime_ = null;
          _this.authToken_ = null;
          _this.forceTokenRefresh_ = false;
          _this.invalidAuthTokenCount_ = 0;
          _this.firstConnection_ = true;
          _this.lastConnectionAttemptTime_ = null;
          _this.lastConnectionEstablishedTime_ = null;
          if (authOverride_ && !util.isNodeSdk()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
          _this.scheduleConnect_(0);
          VisibilityMonitor.getInstance().on("visible", _this.onVisible_, _this);
          -1 === repoInfo_.host.indexOf("fblocal") && OnlineMonitor.getInstance().on("online", _this.onOnline_, _this);
          return _this;
        }
        PersistentConnection.prototype.sendRequest = function(action, body, onResponse) {
          var curReqNum = ++this.requestNumber_;
          var msg = {
            r: curReqNum,
            a: action,
            b: body
          };
          this.log_(util.stringify(msg));
          util.assert(this.connected_, "sendRequest call when we're not connected not allowed.");
          this.realtime_.sendRequest(msg);
          onResponse && (this.requestCBHash_[curReqNum] = onResponse);
        };
        PersistentConnection.prototype.listen = function(query, currentHashFn, tag, onComplete) {
          var queryId = query.queryIdentifier();
          var pathString = query.path.toString();
          this.log_("Listen called for " + pathString + " " + queryId);
          this.listens_[pathString] = this.listens_[pathString] || {};
          util.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), "listen() called for non-default but complete query");
          util.assert(!this.listens_[pathString][queryId], "listen() called twice for same path/queryId.");
          var listenSpec = {
            onComplete: onComplete,
            hashFn: currentHashFn,
            query: query,
            tag: tag
          };
          this.listens_[pathString][queryId] = listenSpec;
          this.connected_ && this.sendListen_(listenSpec);
        };
        PersistentConnection.prototype.sendListen_ = function(listenSpec) {
          var _this = this;
          var query = listenSpec.query;
          var pathString = query.path.toString();
          var queryId = query.queryIdentifier();
          this.log_("Listen on " + pathString + " for " + queryId);
          var req = {
            p: pathString
          };
          var action = "q";
          if (listenSpec.tag) {
            req["q"] = query.queryObject();
            req["t"] = listenSpec.tag;
          }
          req["h"] = listenSpec.hashFn();
          this.sendRequest(action, req, function(message) {
            var payload = message["d"];
            var status = message["s"];
            PersistentConnection.warnOnListenWarnings_(payload, query);
            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];
            if (currentListenSpec === listenSpec) {
              _this.log_("listen response", message);
              "ok" !== status && _this.removeListen_(pathString, queryId);
              listenSpec.onComplete && listenSpec.onComplete(status, payload);
            }
          });
        };
        PersistentConnection.warnOnListenWarnings_ = function(payload, query) {
          if (payload && "object" === typeof payload && util.contains(payload, "w")) {
            var warnings = util.safeGet(payload, "w");
            if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
              var indexSpec = '".indexOn": "' + query.getQueryParams().getIndex().toString() + '"';
              var indexPath = query.path.toString();
              warn("Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding " + indexSpec + " at " + indexPath + " to your security rules for better performance.");
            }
          }
        };
        PersistentConnection.prototype.refreshAuthToken = function(token) {
          this.authToken_ = token;
          this.log_("Auth token refreshed");
          this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, function() {});
          this.reduceReconnectDelayIfAdminCredential_(token);
        };
        PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function(credential) {
          var isFirebaseSecret = credential && 40 === credential.length;
          if (isFirebaseSecret || util.isAdmin(credential)) {
            this.log_("Admin auth credential detected.  Reducing max reconnect time.");
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
          }
        };
        PersistentConnection.prototype.tryAuth = function() {
          var _this = this;
          if (this.connected_ && this.authToken_) {
            var token_1 = this.authToken_;
            var authMethod = util.isValidFormat(token_1) ? "auth" : "gauth";
            var requestData = {
              cred: token_1
            };
            null === this.authOverride_ ? requestData["noauth"] = true : "object" === typeof this.authOverride_ && (requestData["authvar"] = this.authOverride_);
            this.sendRequest(authMethod, requestData, function(res) {
              var status = res["s"];
              var data = res["d"] || "error";
              _this.authToken_ === token_1 && ("ok" === status ? _this.invalidAuthTokenCount_ = 0 : _this.onAuthRevoked_(status, data));
            });
          }
        };
        PersistentConnection.prototype.unlisten = function(query, tag) {
          var pathString = query.path.toString();
          var queryId = query.queryIdentifier();
          this.log_("Unlisten called for " + pathString + " " + queryId);
          util.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), "unlisten() called for non-default but complete query");
          var listen = this.removeListen_(pathString, queryId);
          listen && this.connected_ && this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);
        };
        PersistentConnection.prototype.sendUnlisten_ = function(pathString, queryId, queryObj, tag) {
          this.log_("Unlisten on " + pathString + " for " + queryId);
          var req = {
            p: pathString
          };
          var action = "n";
          if (tag) {
            req["q"] = queryObj;
            req["t"] = tag;
          }
          this.sendRequest(action, req);
        };
        PersistentConnection.prototype.onDisconnectPut = function(pathString, data, onComplete) {
          this.connected_ ? this.sendOnDisconnect_("o", pathString, data, onComplete) : this.onDisconnectRequestQueue_.push({
            pathString: pathString,
            action: "o",
            data: data,
            onComplete: onComplete
          });
        };
        PersistentConnection.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
          this.connected_ ? this.sendOnDisconnect_("om", pathString, data, onComplete) : this.onDisconnectRequestQueue_.push({
            pathString: pathString,
            action: "om",
            data: data,
            onComplete: onComplete
          });
        };
        PersistentConnection.prototype.onDisconnectCancel = function(pathString, onComplete) {
          this.connected_ ? this.sendOnDisconnect_("oc", pathString, null, onComplete) : this.onDisconnectRequestQueue_.push({
            pathString: pathString,
            action: "oc",
            data: null,
            onComplete: onComplete
          });
        };
        PersistentConnection.prototype.sendOnDisconnect_ = function(action, pathString, data, onComplete) {
          var request = {
            p: pathString,
            d: data
          };
          this.log_("onDisconnect " + action, request);
          this.sendRequest(action, request, function(response) {
            onComplete && setTimeout(function() {
              onComplete(response["s"], response["d"]);
            }, Math.floor(0));
          });
        };
        PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {
          this.putInternal("p", pathString, data, onComplete, hash);
        };
        PersistentConnection.prototype.merge = function(pathString, data, onComplete, hash) {
          this.putInternal("m", pathString, data, onComplete, hash);
        };
        PersistentConnection.prototype.putInternal = function(action, pathString, data, onComplete, hash) {
          var request = {
            p: pathString,
            d: data
          };
          void 0 !== hash && (request["h"] = hash);
          this.outstandingPuts_.push({
            action: action,
            request: request,
            onComplete: onComplete
          });
          this.outstandingPutCount_++;
          var index = this.outstandingPuts_.length - 1;
          this.connected_ ? this.sendPut_(index) : this.log_("Buffering put: " + pathString);
        };
        PersistentConnection.prototype.sendPut_ = function(index) {
          var _this = this;
          var action = this.outstandingPuts_[index].action;
          var request = this.outstandingPuts_[index].request;
          var onComplete = this.outstandingPuts_[index].onComplete;
          this.outstandingPuts_[index].queued = this.connected_;
          this.sendRequest(action, request, function(message) {
            _this.log_(action + " response", message);
            delete _this.outstandingPuts_[index];
            _this.outstandingPutCount_--;
            0 === _this.outstandingPutCount_ && (_this.outstandingPuts_ = []);
            onComplete && onComplete(message["s"], message["d"]);
          });
        };
        PersistentConnection.prototype.reportStats = function(stats) {
          var _this = this;
          if (this.connected_) {
            var request = {
              c: stats
            };
            this.log_("reportStats", request);
            this.sendRequest("s", request, function(result) {
              var status = result["s"];
              if ("ok" !== status) {
                var errorReason = result["d"];
                _this.log_("reportStats", "Error sending stats: " + errorReason);
              }
            });
          }
        };
        PersistentConnection.prototype.onDataMessage_ = function(message) {
          if ("r" in message) {
            this.log_("from server: " + util.stringify(message));
            var reqNum = message["r"];
            var onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
              delete this.requestCBHash_[reqNum];
              onResponse(message["b"]);
            }
          } else {
            if ("error" in message) throw "A server-side error has occurred: " + message["error"];
            "a" in message && this.onDataPush_(message["a"], message["b"]);
          }
        };
        PersistentConnection.prototype.onDataPush_ = function(action, body) {
          this.log_("handleServerMessage", action, body);
          "d" === action ? this.onDataUpdate_(body["p"], body["d"], false, body["t"]) : "m" === action ? this.onDataUpdate_(body["p"], body["d"], true, body["t"]) : "c" === action ? this.onListenRevoked_(body["p"], body["q"]) : "ac" === action ? this.onAuthRevoked_(body["s"], body["d"]) : "sd" === action ? this.onSecurityDebugPacket_(body) : error("Unrecognized action received from server: " + util.stringify(action) + "\nAre you using the latest client?");
        };
        PersistentConnection.prototype.onReady_ = function(timestamp, sessionId) {
          this.log_("connection ready");
          this.connected_ = true;
          this.lastConnectionEstablishedTime_ = new Date().getTime();
          this.handleTimestamp_(timestamp);
          this.lastSessionId = sessionId;
          this.firstConnection_ && this.sendConnectStats_();
          this.restoreState_();
          this.firstConnection_ = false;
          this.onConnectStatus_(true);
        };
        PersistentConnection.prototype.scheduleConnect_ = function(timeout) {
          var _this = this;
          util.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
          this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_);
          this.establishConnectionTimer_ = setTimeout(function() {
            _this.establishConnectionTimer_ = null;
            _this.establishConnection_();
          }, Math.floor(timeout));
        };
        PersistentConnection.prototype.onVisible_ = function(visible) {
          if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_("Window became visible.  Reducing delay.");
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            this.realtime_ || this.scheduleConnect_(0);
          }
          this.visible_ = visible;
        };
        PersistentConnection.prototype.onOnline_ = function(online) {
          if (online) {
            this.log_("Browser went online.");
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            this.realtime_ || this.scheduleConnect_(0);
          } else {
            this.log_("Browser went offline.  Killing connection.");
            this.realtime_ && this.realtime_.close();
          }
        };
        PersistentConnection.prototype.onRealtimeDisconnect_ = function() {
          this.log_("data client disconnected");
          this.connected_ = false;
          this.realtime_ = null;
          this.cancelSentTransactions_();
          this.requestCBHash_ = {};
          if (this.shouldReconnect_()) {
            if (this.visible_) {
              if (this.lastConnectionEstablishedTime_) {
                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT && (this.reconnectDelay_ = RECONNECT_MIN_DELAY);
                this.lastConnectionEstablishedTime_ = null;
              }
            } else {
              this.log_("Window isn't visible.  Delaying reconnect.");
              this.reconnectDelay_ = this.maxReconnectDelay_;
              this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_("Trying to reconnect in " + reconnectDelay + "ms");
            this.scheduleConnect_(reconnectDelay);
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
          }
          this.onConnectStatus_(false);
        };
        PersistentConnection.prototype.establishConnection_ = function() {
          if (this.shouldReconnect_()) {
            this.log_("Making a connection attempt");
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            var onDataMessage_1 = this.onDataMessage_.bind(this);
            var onReady_1 = this.onReady_.bind(this);
            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
            var connId_1 = this.id + ":" + PersistentConnection.nextConnectionId_++;
            var self_1 = this;
            var lastSessionId_1 = this.lastSessionId;
            var canceled_1 = false;
            var connection_1 = null;
            var closeFn_1 = function() {
              if (connection_1) connection_1.close(); else {
                canceled_1 = true;
                onDisconnect_1();
              }
            };
            var sendRequestFn = function(msg) {
              util.assert(connection_1, "sendRequest call when we're not connected not allowed.");
              connection_1.sendRequest(msg);
            };
            this.realtime_ = {
              close: closeFn_1,
              sendRequest: sendRequestFn
            };
            var forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            this.authTokenProvider_.getToken(forceRefresh).then(function(result) {
              if (canceled_1) log("getToken() completed but was canceled"); else {
                log("getToken() completed. Creating connection.");
                self_1.authToken_ = result && result.accessToken;
                connection_1 = new Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, function(reason) {
                  warn(reason + " (" + self_1.repoInfo_.toString() + ")");
                  self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);
                }, lastSessionId_1);
              }
            }).then(null, function(error$$1) {
              self_1.log_("Failed to get token: " + error$$1);
              if (!canceled_1) {
                util.CONSTANTS.NODE_ADMIN && warn(error$$1);
                closeFn_1();
              }
            });
          }
        };
        PersistentConnection.prototype.interrupt = function(reason) {
          log("Interrupting connection for reason: " + reason);
          this.interruptReasons_[reason] = true;
          if (this.realtime_) this.realtime_.close(); else {
            if (this.establishConnectionTimer_) {
              clearTimeout(this.establishConnectionTimer_);
              this.establishConnectionTimer_ = null;
            }
            this.connected_ && this.onRealtimeDisconnect_();
          }
        };
        PersistentConnection.prototype.resume = function(reason) {
          log("Resuming connection for reason: " + reason);
          delete this.interruptReasons_[reason];
          if (util.isEmpty(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            this.realtime_ || this.scheduleConnect_(0);
          }
        };
        PersistentConnection.prototype.handleTimestamp_ = function(timestamp) {
          var delta = timestamp - new Date().getTime();
          this.onServerInfoUpdate_({
            serverTimeOffset: delta
          });
        };
        PersistentConnection.prototype.cancelSentTransactions_ = function() {
          for (var i = 0; i < this.outstandingPuts_.length; i++) {
            var put = this.outstandingPuts_[i];
            if (put && "h" in put.request && put.queued) {
              put.onComplete && put.onComplete("disconnect");
              delete this.outstandingPuts_[i];
              this.outstandingPutCount_--;
            }
          }
          0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []);
        };
        PersistentConnection.prototype.onListenRevoked_ = function(pathString, query) {
          var queryId;
          queryId = query ? query.map(function(q) {
            return ObjectToUniqueKey(q);
          }).join("$") : "default";
          var listen = this.removeListen_(pathString, queryId);
          listen && listen.onComplete && listen.onComplete("permission_denied");
        };
        PersistentConnection.prototype.removeListen_ = function(pathString, queryId) {
          var normalizedPathString = new Path(pathString).toString();
          var listen;
          if (void 0 !== this.listens_[normalizedPathString]) {
            listen = this.listens_[normalizedPathString][queryId];
            delete this.listens_[normalizedPathString][queryId];
            0 === util.getCount(this.listens_[normalizedPathString]) && delete this.listens_[normalizedPathString];
          } else listen = void 0;
          return listen;
        };
        PersistentConnection.prototype.onAuthRevoked_ = function(statusCode, explanation) {
          log("Auth token revoked: " + statusCode + "/" + explanation);
          this.authToken_ = null;
          this.forceTokenRefresh_ = true;
          this.realtime_.close();
          if ("invalid_token" === statusCode || "permission_denied" === statusCode) {
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {
              this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
              this.authTokenProvider_.notifyForInvalidToken();
            }
          }
        };
        PersistentConnection.prototype.onSecurityDebugPacket_ = function(body) {
          this.securityDebugCallback_ ? this.securityDebugCallback_(body) : "msg" in body && console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
        };
        PersistentConnection.prototype.restoreState_ = function() {
          var _this = this;
          this.tryAuth();
          util.forEach(this.listens_, function(pathString, queries) {
            util.forEach(queries, function(key, listenSpec) {
              _this.sendListen_(listenSpec);
            });
          });
          for (var i = 0; i < this.outstandingPuts_.length; i++) this.outstandingPuts_[i] && this.sendPut_(i);
          while (this.onDisconnectRequestQueue_.length) {
            var request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
          }
        };
        PersistentConnection.prototype.sendConnectStats_ = function() {
          var stats = {};
          var clientName = "js";
          util.CONSTANTS.NODE_ADMIN ? clientName = "admin_node" : util.CONSTANTS.NODE_CLIENT && (clientName = "node");
          stats["sdk." + clientName + "." + firebase.SDK_VERSION.replace(/\./g, "-")] = 1;
          util.isMobileCordova() ? stats["framework.cordova"] = 1 : util.isReactNative() && (stats["framework.reactnative"] = 1);
          this.reportStats(stats);
        };
        PersistentConnection.prototype.shouldReconnect_ = function() {
          var online = OnlineMonitor.getInstance().currentlyOnline();
          return util.isEmpty(this.interruptReasons_) && online;
        };
        PersistentConnection.nextPersistentConnectionId_ = 0;
        PersistentConnection.nextConnectionId_ = 0;
        return PersistentConnection;
      }(ServerActions);
      var ReadonlyRestClient = function(_super) {
        tslib_1.__extends(ReadonlyRestClient, _super);
        function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {
          var _this = _super.call(this) || this;
          _this.repoInfo_ = repoInfo_;
          _this.onDataUpdate_ = onDataUpdate_;
          _this.authTokenProvider_ = authTokenProvider_;
          _this.log_ = logWrapper("p:rest:");
          _this.listens_ = {};
          return _this;
        }
        ReadonlyRestClient.prototype.reportStats = function(stats) {
          throw new Error("Method not implemented.");
        };
        ReadonlyRestClient.getListenId_ = function(query, tag) {
          if (void 0 !== tag) return "tag$" + tag;
          util.assert(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
          return query.path.toString();
        };
        ReadonlyRestClient.prototype.listen = function(query, currentHashFn, tag, onComplete) {
          var _this = this;
          var pathString = query.path.toString();
          this.log_("Listen called for " + pathString + " " + query.queryIdentifier());
          var listenId = ReadonlyRestClient.getListenId_(query, tag);
          var thisListen = {};
          this.listens_[listenId] = thisListen;
          var queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();
          this.restRequest_(pathString + ".json", queryStringParamaters, function(error$$1, result) {
            var data = result;
            if (404 === error$$1) {
              data = null;
              error$$1 = null;
            }
            null === error$$1 && _this.onDataUpdate_(pathString, data, false, tag);
            if (util.safeGet(_this.listens_, listenId) === thisListen) {
              var status_1;
              status_1 = error$$1 ? 401 == error$$1 ? "permission_denied" : "rest_error:" + error$$1 : "ok";
              onComplete(status_1, null);
            }
          });
        };
        ReadonlyRestClient.prototype.unlisten = function(query, tag) {
          var listenId = ReadonlyRestClient.getListenId_(query, tag);
          delete this.listens_[listenId];
        };
        ReadonlyRestClient.prototype.refreshAuthToken = function(token) {};
        ReadonlyRestClient.prototype.restRequest_ = function(pathString, queryStringParameters, callback) {
          var _this = this;
          void 0 === queryStringParameters && (queryStringParameters = {});
          queryStringParameters["format"] = "export";
          this.authTokenProvider_.getToken(false).then(function(authTokenData) {
            var authToken = authTokenData && authTokenData.accessToken;
            authToken && (queryStringParameters["auth"] = authToken);
            var url = (_this.repoInfo_.secure ? "https://" : "http://") + _this.repoInfo_.host + pathString + "?" + util.querystring(queryStringParameters);
            _this.log_("Sending REST request for " + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
              if (callback && 4 === xhr.readyState) {
                _this.log_("REST Response for " + url + " received. status:", xhr.status, "response:", xhr.responseText);
                var res = null;
                if (xhr.status >= 200 && xhr.status < 300) {
                  try {
                    res = util.jsonEval(xhr.responseText);
                  } catch (e) {
                    warn("Failed to parse JSON response for " + url + ": " + xhr.responseText);
                  }
                  callback(null, res);
                } else {
                  401 !== xhr.status && 404 !== xhr.status && warn("Got unsuccessful REST response for " + url + " Status: " + xhr.status);
                  callback(xhr.status);
                }
                callback = null;
              }
            };
            xhr.open("GET", url, true);
            xhr.send();
          });
        };
        return ReadonlyRestClient;
      }(ServerActions);
      var INTERRUPT_REASON = "repo_interrupt";
      var Repo = function() {
        function Repo(repoInfo_, forceRestClient, app) {
          var _this = this;
          this.repoInfo_ = repoInfo_;
          this.app = app;
          this.dataUpdateCount = 0;
          this.statsListener_ = null;
          this.eventQueue_ = new EventQueue();
          this.nextWriteId_ = 1;
          this.interceptServerDataCallback_ = null;
          this.onDisconnect_ = new SparseSnapshotTree();
          this.persistentConnection_ = null;
          var authTokenProvider = new AuthTokenProvider(app);
          this.stats_ = StatsManager.getCollection(repoInfo_);
          if (forceRestClient || beingCrawled()) {
            this.server_ = new ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);
            setTimeout(this.onConnectStatus_.bind(this, true), 0);
          } else {
            var authOverride = app.options["databaseAuthVariableOverride"];
            if ("undefined" !== typeof authOverride && null !== authOverride) {
              if ("object" !== typeof authOverride) throw new Error("Only objects are supported for option databaseAuthVariableOverride");
              try {
                util.stringify(authOverride);
              } catch (e) {
                throw new Error("Invalid authOverride provided: " + e);
              }
            }
            this.persistentConnection_ = new PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);
            this.server_ = this.persistentConnection_;
          }
          authTokenProvider.addTokenChangeListener(function(token) {
            _this.server_.refreshAuthToken(token);
          });
          this.statsReporter_ = StatsManager.getOrCreateReporter(repoInfo_, function() {
            return new StatsReporter(_this.stats_, _this.server_);
          });
          this.transactions_init_();
          this.infoData_ = new SnapshotHolder();
          this.infoSyncTree_ = new SyncTree({
            startListening: function(query, tag, currentHashFn, onComplete) {
              var infoEvents = [];
              var node = _this.infoData_.getNode(query.path);
              if (!node.isEmpty()) {
                infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);
                setTimeout(function() {
                  onComplete("ok");
                }, 0);
              }
              return infoEvents;
            },
            stopListening: function() {}
          });
          this.updateInfo_("connected", false);
          this.serverSyncTree_ = new SyncTree({
            startListening: function(query, tag, currentHashFn, onComplete) {
              _this.server_.listen(query, currentHashFn, tag, function(status, data) {
                var events = onComplete(status, data);
                _this.eventQueue_.raiseEventsForChangedPath(query.path, events);
              });
              return [];
            },
            stopListening: function(query, tag) {
              _this.server_.unlisten(query, tag);
            }
          });
        }
        Repo.prototype.toString = function() {
          return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
        };
        Repo.prototype.name = function() {
          return this.repoInfo_.namespace;
        };
        Repo.prototype.serverTime = function() {
          var offsetNode = this.infoData_.getNode(new Path(".info/serverTimeOffset"));
          var offset = offsetNode.val() || 0;
          return new Date().getTime() + offset;
        };
        Repo.prototype.generateServerValues = function() {
          return generateWithValues({
            timestamp: this.serverTime()
          });
        };
        Repo.prototype.onDataUpdate_ = function(pathString, data, isMerge, tag) {
          this.dataUpdateCount++;
          var path = new Path(pathString);
          data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;
          var events = [];
          if (tag) if (isMerge) {
            var taggedChildren = util.map(data, function(raw) {
              return nodeFromJSON$1(raw);
            });
            events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);
          } else {
            var taggedSnap = nodeFromJSON$1(data);
            events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);
          } else if (isMerge) {
            var changedChildren = util.map(data, function(raw) {
              return nodeFromJSON$1(raw);
            });
            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);
          } else {
            var snap = nodeFromJSON$1(data);
            events = this.serverSyncTree_.applyServerOverwrite(path, snap);
          }
          var affectedPath = path;
          events.length > 0 && (affectedPath = this.rerunTransactions_(path));
          this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);
        };
        Repo.prototype.interceptServerData_ = function(callback) {
          this.interceptServerDataCallback_ = callback;
        };
        Repo.prototype.onConnectStatus_ = function(connectStatus) {
          this.updateInfo_("connected", connectStatus);
          false === connectStatus && this.runOnDisconnectEvents_();
        };
        Repo.prototype.onServerInfoUpdate_ = function(updates) {
          var _this = this;
          each(updates, function(value, key) {
            _this.updateInfo_(key, value);
          });
        };
        Repo.prototype.updateInfo_ = function(pathString, value) {
          var path = new Path("/.info/" + pathString);
          var newNode = nodeFromJSON$1(value);
          this.infoData_.updateSnapshot(path, newNode);
          var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);
          this.eventQueue_.raiseEventsForChangedPath(path, events);
        };
        Repo.prototype.getNextWriteId_ = function() {
          return this.nextWriteId_++;
        };
        Repo.prototype.setWithPriority = function(path, newVal, newPriority, onComplete) {
          var _this = this;
          this.log_("set", {
            path: path.toString(),
            value: newVal,
            priority: newPriority
          });
          var serverValues = this.generateServerValues();
          var newNodeUnresolved = nodeFromJSON$1(newVal, newPriority);
          var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
          var writeId = this.getNextWriteId_();
          var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);
          this.eventQueue_.queueEvents(events);
          this.server_.put(path.toString(), newNodeUnresolved.val(true), function(status, errorReason) {
            var success = "ok" === status;
            success || warn("set at " + path + " failed: " + status);
            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);
            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
          });
          var affectedPath = this.abortTransactions_(path);
          this.rerunTransactions_(affectedPath);
          this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);
        };
        Repo.prototype.update = function(path, childrenToMerge, onComplete) {
          var _this = this;
          this.log_("update", {
            path: path.toString(),
            value: childrenToMerge
          });
          var empty = true;
          var serverValues = this.generateServerValues();
          var changedChildren = {};
          util.forEach(childrenToMerge, function(changedKey, changedValue) {
            empty = false;
            var newNodeUnresolved = nodeFromJSON$1(changedValue);
            changedChildren[changedKey] = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
          });
          if (empty) {
            log("update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, "ok");
          } else {
            var writeId_1 = this.getNextWriteId_();
            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);
            this.eventQueue_.queueEvents(events);
            this.server_.merge(path.toString(), childrenToMerge, function(status, errorReason) {
              var success = "ok" === status;
              success || warn("update at " + path + " failed: " + status);
              var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);
              var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;
              _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);
              _this.callOnCompleteCallback(onComplete, status, errorReason);
            });
            util.forEach(childrenToMerge, function(changedPath) {
              var affectedPath = _this.abortTransactions_(path.child(changedPath));
              _this.rerunTransactions_(affectedPath);
            });
            this.eventQueue_.raiseEventsForChangedPath(path, []);
          }
        };
        Repo.prototype.runOnDisconnectEvents_ = function() {
          var _this = this;
          this.log_("onDisconnectEvents");
          var serverValues = this.generateServerValues();
          var resolvedOnDisconnectTree = resolveDeferredValueTree(this.onDisconnect_, serverValues);
          var events = [];
          resolvedOnDisconnectTree.forEachTree(Path.Empty, function(path, snap) {
            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));
            var affectedPath = _this.abortTransactions_(path);
            _this.rerunTransactions_(affectedPath);
          });
          this.onDisconnect_ = new SparseSnapshotTree();
          this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);
        };
        Repo.prototype.onDisconnectCancel = function(path, onComplete) {
          var _this = this;
          this.server_.onDisconnectCancel(path.toString(), function(status, errorReason) {
            "ok" === status && _this.onDisconnect_.forget(path);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
          });
        };
        Repo.prototype.onDisconnectSet = function(path, value, onComplete) {
          var _this = this;
          var newNode = nodeFromJSON$1(value);
          this.server_.onDisconnectPut(path.toString(), newNode.val(true), function(status, errorReason) {
            "ok" === status && _this.onDisconnect_.remember(path, newNode);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
          });
        };
        Repo.prototype.onDisconnectSetWithPriority = function(path, value, priority, onComplete) {
          var _this = this;
          var newNode = nodeFromJSON$1(value, priority);
          this.server_.onDisconnectPut(path.toString(), newNode.val(true), function(status, errorReason) {
            "ok" === status && _this.onDisconnect_.remember(path, newNode);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
          });
        };
        Repo.prototype.onDisconnectUpdate = function(path, childrenToMerge, onComplete) {
          var _this = this;
          if (util.isEmpty(childrenToMerge)) {
            log("onDisconnect().update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, "ok");
            return;
          }
          this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function(status, errorReason) {
            "ok" === status && util.forEach(childrenToMerge, function(childName, childNode) {
              var newChildNode = nodeFromJSON$1(childNode);
              _this.onDisconnect_.remember(path.child(childName), newChildNode);
            });
            _this.callOnCompleteCallback(onComplete, status, errorReason);
          });
        };
        Repo.prototype.addEventCallbackForQuery = function(query, eventRegistration) {
          var events;
          events = ".info" === query.path.getFront() ? this.infoSyncTree_.addEventRegistration(query, eventRegistration) : this.serverSyncTree_.addEventRegistration(query, eventRegistration);
          this.eventQueue_.raiseEventsAtPath(query.path, events);
        };
        Repo.prototype.removeEventCallbackForQuery = function(query, eventRegistration) {
          var events;
          events = ".info" === query.path.getFront() ? this.infoSyncTree_.removeEventRegistration(query, eventRegistration) : this.serverSyncTree_.removeEventRegistration(query, eventRegistration);
          this.eventQueue_.raiseEventsAtPath(query.path, events);
        };
        Repo.prototype.interrupt = function() {
          this.persistentConnection_ && this.persistentConnection_.interrupt(INTERRUPT_REASON);
        };
        Repo.prototype.resume = function() {
          this.persistentConnection_ && this.persistentConnection_.resume(INTERRUPT_REASON);
        };
        Repo.prototype.stats = function(showDelta) {
          void 0 === showDelta && (showDelta = false);
          if ("undefined" === typeof console) return;
          var stats;
          if (showDelta) {
            this.statsListener_ || (this.statsListener_ = new StatsListener(this.stats_));
            stats = this.statsListener_.get();
          } else stats = this.stats_.get();
          var longestName = Object.keys(stats).reduce(function(previousValue, currentValue) {
            return Math.max(currentValue.length, previousValue);
          }, 0);
          util.forEach(stats, function(stat, value) {
            for (var i = stat.length; i < longestName + 2; i++) stat += " ";
            console.log(stat + value);
          });
        };
        Repo.prototype.statsIncrementCounter = function(metric) {
          this.stats_.incrementCounter(metric);
          this.statsReporter_.includeStat(metric);
        };
        Repo.prototype.log_ = function() {
          var var_args = [];
          for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
          var prefix = "";
          this.persistentConnection_ && (prefix = this.persistentConnection_.id + ":");
          log.apply(void 0, [ prefix ].concat(var_args));
        };
        Repo.prototype.callOnCompleteCallback = function(callback, status, errorReason) {
          callback && exceptionGuard(function() {
            if ("ok" == status) callback(null); else {
              var code = (status || "error").toUpperCase();
              var message = code;
              errorReason && (message += ": " + errorReason);
              var error$$1 = new Error(message);
              error$$1.code = code;
              callback(error$$1);
            }
          });
        };
        Object.defineProperty(Repo.prototype, "database", {
          get: function() {
            return this.__database || (this.__database = new Database(this));
          },
          enumerable: true,
          configurable: true
        });
        return Repo;
      }();
      var RangedFilter = function() {
        function RangedFilter(params) {
          this.indexedFilter_ = new IndexedFilter(params.getIndex());
          this.index_ = params.getIndex();
          this.startPost_ = RangedFilter.getStartPost_(params);
          this.endPost_ = RangedFilter.getEndPost_(params);
        }
        RangedFilter.prototype.getStartPost = function() {
          return this.startPost_;
        };
        RangedFilter.prototype.getEndPost = function() {
          return this.endPost_;
        };
        RangedFilter.prototype.matches = function(node) {
          return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;
        };
        RangedFilter.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
          this.matches(new NamedNode(key, newChild)) || (newChild = ChildrenNode.EMPTY_NODE);
          return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        };
        RangedFilter.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
          newSnap.isLeafNode() && (newSnap = ChildrenNode.EMPTY_NODE);
          var filtered = newSnap.withIndex(this.index_);
          filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
          var self = this;
          newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            self.matches(new NamedNode(key, childNode)) || (filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE));
          });
          return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
        };
        RangedFilter.prototype.updatePriority = function(oldSnap, newPriority) {
          return oldSnap;
        };
        RangedFilter.prototype.filtersNodes = function() {
          return true;
        };
        RangedFilter.prototype.getIndexedFilter = function() {
          return this.indexedFilter_;
        };
        RangedFilter.prototype.getIndex = function() {
          return this.index_;
        };
        RangedFilter.getStartPost_ = function(params) {
          if (params.hasStart()) {
            var startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
          }
          return params.getIndex().minPost();
        };
        RangedFilter.getEndPost_ = function(params) {
          if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
          }
          return params.getIndex().maxPost();
        };
        return RangedFilter;
      }();
      var LimitedFilter = function() {
        function LimitedFilter(params) {
          this.rangedFilter_ = new RangedFilter(params);
          this.index_ = params.getIndex();
          this.limit_ = params.getLimit();
          this.reverse_ = !params.isViewFromLeft();
        }
        LimitedFilter.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
          this.rangedFilter_.matches(new NamedNode(key, newChild)) || (newChild = ChildrenNode.EMPTY_NODE);
          return snap.getImmediateChild(key).equals(newChild) ? snap : snap.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) : this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        };
        LimitedFilter.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
          var filtered;
          if (newSnap.isLeafNode() || newSnap.isEmpty()) filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_); else if (2 * this.limit_ < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
            var iterator = void 0;
            iterator = this.reverse_ ? newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
            var count = 0;
            while (iterator.hasNext() && count < this.limit_) {
              var next = iterator.getNext();
              var inRange = void 0;
              inRange = this.reverse_ ? this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0 : this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
              if (!inRange) break;
              filtered = filtered.updateImmediateChild(next.name, next.node);
              count++;
            }
          } else {
            filtered = newSnap.withIndex(this.index_);
            filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
            var startPost = void 0;
            var endPost = void 0;
            var cmp = void 0;
            var iterator = void 0;
            if (this.reverse_) {
              iterator = filtered.getReverseIterator(this.index_);
              startPost = this.rangedFilter_.getEndPost();
              endPost = this.rangedFilter_.getStartPost();
              var indexCompare_1 = this.index_.getCompare();
              cmp = function(a, b) {
                return indexCompare_1(b, a);
              };
            } else {
              iterator = filtered.getIterator(this.index_);
              startPost = this.rangedFilter_.getStartPost();
              endPost = this.rangedFilter_.getEndPost();
              cmp = this.index_.getCompare();
            }
            var count = 0;
            var foundStartPost = false;
            while (iterator.hasNext()) {
              var next = iterator.getNext();
              !foundStartPost && cmp(startPost, next) <= 0 && (foundStartPost = true);
              var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
              inRange ? count++ : filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
            }
          }
          return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
        };
        LimitedFilter.prototype.updatePriority = function(oldSnap, newPriority) {
          return oldSnap;
        };
        LimitedFilter.prototype.filtersNodes = function() {
          return true;
        };
        LimitedFilter.prototype.getIndexedFilter = function() {
          return this.rangedFilter_.getIndexedFilter();
        };
        LimitedFilter.prototype.getIndex = function() {
          return this.index_;
        };
        LimitedFilter.prototype.fullLimitUpdateChild_ = function(snap, childKey, childSnap, source, changeAccumulator) {
          var cmp;
          if (this.reverse_) {
            var indexCmp_1 = this.index_.getCompare();
            cmp = function(a, b) {
              return indexCmp_1(b, a);
            };
          } else cmp = this.index_.getCompare();
          var oldEventCache = snap;
          util.assert(oldEventCache.numChildren() == this.limit_, "");
          var newChildNamedNode = new NamedNode(childKey, childSnap);
          var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
          var inRange = this.rangedFilter_.matches(newChildNamedNode);
          if (oldEventCache.hasChild(childKey)) {
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (null != nextChild && (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            var compareNext = null == nextChild ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
              null != changeAccumulator && changeAccumulator.trackChildChange(Change.childChangedChange(childKey, childSnap, oldChildSnap));
              return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            null != changeAccumulator && changeAccumulator.trackChildChange(Change.childRemovedChange(childKey, oldChildSnap));
            var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
            var nextChildInRange = null != nextChild && this.rangedFilter_.matches(nextChild);
            if (nextChildInRange) {
              null != changeAccumulator && changeAccumulator.trackChildChange(Change.childAddedChange(nextChild.name, nextChild.node));
              return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
            }
            return newEventCache;
          }
          if (childSnap.isEmpty()) return snap;
          if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
              if (null != changeAccumulator) {
                changeAccumulator.trackChildChange(Change.childRemovedChange(windowBoundary.name, windowBoundary.node));
                changeAccumulator.trackChildChange(Change.childAddedChange(childKey, childSnap));
              }
              return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
            }
            return snap;
          }
          return snap;
        };
        return LimitedFilter;
      }();
      var QueryParams = function() {
        function QueryParams() {
          this.limitSet_ = false;
          this.startSet_ = false;
          this.startNameSet_ = false;
          this.endSet_ = false;
          this.endNameSet_ = false;
          this.limit_ = 0;
          this.viewFrom_ = "";
          this.indexStartValue_ = null;
          this.indexStartName_ = "";
          this.indexEndValue_ = null;
          this.indexEndName_ = "";
          this.index_ = PRIORITY_INDEX;
        }
        QueryParams.prototype.hasStart = function() {
          return this.startSet_;
        };
        QueryParams.prototype.isViewFromLeft = function() {
          return "" === this.viewFrom_ ? this.startSet_ : this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;
        };
        QueryParams.prototype.getIndexStartValue = function() {
          util.assert(this.startSet_, "Only valid if start has been set");
          return this.indexStartValue_;
        };
        QueryParams.prototype.getIndexStartName = function() {
          util.assert(this.startSet_, "Only valid if start has been set");
          return this.startNameSet_ ? this.indexStartName_ : MIN_NAME;
        };
        QueryParams.prototype.hasEnd = function() {
          return this.endSet_;
        };
        QueryParams.prototype.getIndexEndValue = function() {
          util.assert(this.endSet_, "Only valid if end has been set");
          return this.indexEndValue_;
        };
        QueryParams.prototype.getIndexEndName = function() {
          util.assert(this.endSet_, "Only valid if end has been set");
          return this.endNameSet_ ? this.indexEndName_ : MAX_NAME;
        };
        QueryParams.prototype.hasLimit = function() {
          return this.limitSet_;
        };
        QueryParams.prototype.hasAnchoredLimit = function() {
          return this.limitSet_ && "" !== this.viewFrom_;
        };
        QueryParams.prototype.getLimit = function() {
          util.assert(this.limitSet_, "Only valid if limit has been set");
          return this.limit_;
        };
        QueryParams.prototype.getIndex = function() {
          return this.index_;
        };
        QueryParams.prototype.copy_ = function() {
          var copy = new QueryParams();
          copy.limitSet_ = this.limitSet_;
          copy.limit_ = this.limit_;
          copy.startSet_ = this.startSet_;
          copy.indexStartValue_ = this.indexStartValue_;
          copy.startNameSet_ = this.startNameSet_;
          copy.indexStartName_ = this.indexStartName_;
          copy.endSet_ = this.endSet_;
          copy.indexEndValue_ = this.indexEndValue_;
          copy.endNameSet_ = this.endNameSet_;
          copy.indexEndName_ = this.indexEndName_;
          copy.index_ = this.index_;
          copy.viewFrom_ = this.viewFrom_;
          return copy;
        };
        QueryParams.prototype.limit = function(newLimit) {
          var newParams = this.copy_();
          newParams.limitSet_ = true;
          newParams.limit_ = newLimit;
          newParams.viewFrom_ = "";
          return newParams;
        };
        QueryParams.prototype.limitToFirst = function(newLimit) {
          var newParams = this.copy_();
          newParams.limitSet_ = true;
          newParams.limit_ = newLimit;
          newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;
          return newParams;
        };
        QueryParams.prototype.limitToLast = function(newLimit) {
          var newParams = this.copy_();
          newParams.limitSet_ = true;
          newParams.limit_ = newLimit;
          newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;
          return newParams;
        };
        QueryParams.prototype.startAt = function(indexValue, key) {
          var newParams = this.copy_();
          newParams.startSet_ = true;
          void 0 !== indexValue || (indexValue = null);
          newParams.indexStartValue_ = indexValue;
          if (null != key) {
            newParams.startNameSet_ = true;
            newParams.indexStartName_ = key;
          } else {
            newParams.startNameSet_ = false;
            newParams.indexStartName_ = "";
          }
          return newParams;
        };
        QueryParams.prototype.endAt = function(indexValue, key) {
          var newParams = this.copy_();
          newParams.endSet_ = true;
          void 0 !== indexValue || (indexValue = null);
          newParams.indexEndValue_ = indexValue;
          if (void 0 !== key) {
            newParams.endNameSet_ = true;
            newParams.indexEndName_ = key;
          } else {
            newParams.endNameSet_ = false;
            newParams.indexEndName_ = "";
          }
          return newParams;
        };
        QueryParams.prototype.orderBy = function(index) {
          var newParams = this.copy_();
          newParams.index_ = index;
          return newParams;
        };
        QueryParams.prototype.getQueryObject = function() {
          var WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;
          var obj = {};
          if (this.startSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;
            this.startNameSet_ && (obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_);
          }
          if (this.endSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;
            this.endNameSet_ && (obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_);
          }
          if (this.limitSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;
            var viewFrom = this.viewFrom_;
            "" === viewFrom && (viewFrom = this.isViewFromLeft() ? WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT : WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT);
            obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;
          }
          this.index_ !== PRIORITY_INDEX && (obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString());
          return obj;
        };
        QueryParams.prototype.loadsAllData = function() {
          return !(this.startSet_ || this.endSet_ || this.limitSet_);
        };
        QueryParams.prototype.isDefault = function() {
          return this.loadsAllData() && this.index_ == PRIORITY_INDEX;
        };
        QueryParams.prototype.getNodeFilter = function() {
          return this.loadsAllData() ? new IndexedFilter(this.getIndex()) : this.hasLimit() ? new LimitedFilter(this) : new RangedFilter(this);
        };
        QueryParams.prototype.toRestQueryStringParameters = function() {
          var REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;
          var qs = {};
          if (this.isDefault()) return qs;
          var orderBy;
          if (this.index_ === PRIORITY_INDEX) orderBy = REST_CONSTANTS.PRIORITY_INDEX; else if (this.index_ === VALUE_INDEX) orderBy = REST_CONSTANTS.VALUE_INDEX; else if (this.index_ === KEY_INDEX) orderBy = REST_CONSTANTS.KEY_INDEX; else {
            util.assert(this.index_ instanceof PathIndex, "Unrecognized index type!");
            orderBy = this.index_.toString();
          }
          qs[REST_CONSTANTS.ORDER_BY] = util.stringify(orderBy);
          if (this.startSet_) {
            qs[REST_CONSTANTS.START_AT] = util.stringify(this.indexStartValue_);
            this.startNameSet_ && (qs[REST_CONSTANTS.START_AT] += "," + util.stringify(this.indexStartName_));
          }
          if (this.endSet_) {
            qs[REST_CONSTANTS.END_AT] = util.stringify(this.indexEndValue_);
            this.endNameSet_ && (qs[REST_CONSTANTS.END_AT] += "," + util.stringify(this.indexEndName_));
          }
          this.limitSet_ && (this.isViewFromLeft() ? qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_ : qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_);
          return qs;
        };
        QueryParams.WIRE_PROTOCOL_CONSTANTS_ = {
          INDEX_START_VALUE: "sp",
          INDEX_START_NAME: "sn",
          INDEX_END_VALUE: "ep",
          INDEX_END_NAME: "en",
          LIMIT: "l",
          VIEW_FROM: "vf",
          VIEW_FROM_LEFT: "l",
          VIEW_FROM_RIGHT: "r",
          INDEX: "i"
        };
        QueryParams.REST_QUERY_CONSTANTS_ = {
          ORDER_BY: "orderBy",
          PRIORITY_INDEX: "$priority",
          VALUE_INDEX: "$value",
          KEY_INDEX: "$key",
          START_AT: "startAt",
          END_AT: "endAt",
          LIMIT_TO_FIRST: "limitToFirst",
          LIMIT_TO_LAST: "limitToLast"
        };
        QueryParams.DEFAULT = new QueryParams();
        return QueryParams;
      }();
      var Reference = function(_super) {
        tslib_1.__extends(Reference, _super);
        function Reference(repo, path) {
          var _this = this;
          if (!(repo instanceof Repo)) throw new Error("new Reference() no longer supported - use app.database().");
          _this = _super.call(this, repo, path, QueryParams.DEFAULT, false) || this;
          return _this;
        }
        Reference.prototype.getKey = function() {
          util.validateArgCount("Reference.key", 0, 0, arguments.length);
          return this.path.isEmpty() ? null : this.path.getBack();
        };
        Reference.prototype.child = function(pathString) {
          util.validateArgCount("Reference.child", 1, 1, arguments.length);
          "number" === typeof pathString ? pathString = String(pathString) : pathString instanceof Path || (null === this.path.getFront() ? validateRootPathString("Reference.child", 1, pathString, false) : validatePathString("Reference.child", 1, pathString, false));
          return new Reference(this.repo, this.path.child(pathString));
        };
        Reference.prototype.getParent = function() {
          util.validateArgCount("Reference.parent", 0, 0, arguments.length);
          var parentPath = this.path.parent();
          return null === parentPath ? null : new Reference(this.repo, parentPath);
        };
        Reference.prototype.getRoot = function() {
          util.validateArgCount("Reference.root", 0, 0, arguments.length);
          var ref = this;
          while (null !== ref.getParent()) ref = ref.getParent();
          return ref;
        };
        Reference.prototype.databaseProp = function() {
          return this.repo.database;
        };
        Reference.prototype.set = function(newVal, onComplete) {
          util.validateArgCount("Reference.set", 1, 2, arguments.length);
          validateWritablePath("Reference.set", this.path);
          validateFirebaseDataArg("Reference.set", 1, newVal, this.path, false);
          util.validateCallback("Reference.set", 2, onComplete, true);
          var deferred = new util.Deferred();
          this.repo.setWithPriority(this.path, newVal, null, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        Reference.prototype.update = function(objectToMerge, onComplete) {
          util.validateArgCount("Reference.update", 1, 2, arguments.length);
          validateWritablePath("Reference.update", this.path);
          if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) newObjectToMerge["" + i] = objectToMerge[i];
            objectToMerge = newObjectToMerge;
            warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
          }
          validateFirebaseMergeDataArg("Reference.update", 1, objectToMerge, this.path, false);
          util.validateCallback("Reference.update", 2, onComplete, true);
          var deferred = new util.Deferred();
          this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        Reference.prototype.setWithPriority = function(newVal, newPriority, onComplete) {
          util.validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
          validateWritablePath("Reference.setWithPriority", this.path);
          validateFirebaseDataArg("Reference.setWithPriority", 1, newVal, this.path, false);
          validatePriority("Reference.setWithPriority", 2, newPriority, false);
          util.validateCallback("Reference.setWithPriority", 3, onComplete, true);
          if (".length" === this.getKey() || ".keys" === this.getKey()) throw "Reference.setWithPriority failed: " + this.getKey() + " is a read-only object.";
          var deferred = new util.Deferred();
          this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        Reference.prototype.remove = function(onComplete) {
          util.validateArgCount("Reference.remove", 0, 1, arguments.length);
          validateWritablePath("Reference.remove", this.path);
          util.validateCallback("Reference.remove", 1, onComplete, true);
          return this.set(null, onComplete);
        };
        Reference.prototype.transaction = function(transactionUpdate, onComplete, applyLocally) {
          util.validateArgCount("Reference.transaction", 1, 3, arguments.length);
          validateWritablePath("Reference.transaction", this.path);
          util.validateCallback("Reference.transaction", 1, transactionUpdate, false);
          util.validateCallback("Reference.transaction", 2, onComplete, true);
          validateBoolean("Reference.transaction", 3, applyLocally, true);
          if (".length" === this.getKey() || ".keys" === this.getKey()) throw "Reference.transaction failed: " + this.getKey() + " is a read-only object.";
          void 0 === applyLocally && (applyLocally = true);
          var deferred = new util.Deferred();
          "function" === typeof onComplete && deferred.promise.catch(function() {});
          var promiseComplete = function(error$$1, committed, snapshot) {
            error$$1 ? deferred.reject(error$$1) : deferred.resolve(new TransactionResult(committed, snapshot));
            "function" === typeof onComplete && onComplete(error$$1, committed, snapshot);
          };
          this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);
          return deferred.promise;
        };
        Reference.prototype.setPriority = function(priority, onComplete) {
          util.validateArgCount("Reference.setPriority", 1, 2, arguments.length);
          validateWritablePath("Reference.setPriority", this.path);
          validatePriority("Reference.setPriority", 1, priority, false);
          util.validateCallback("Reference.setPriority", 2, onComplete, true);
          var deferred = new util.Deferred();
          this.repo.setWithPriority(this.path.child(".priority"), priority, null, deferred.wrapCallback(onComplete));
          return deferred.promise;
        };
        Reference.prototype.push = function(value, onComplete) {
          util.validateArgCount("Reference.push", 0, 2, arguments.length);
          validateWritablePath("Reference.push", this.path);
          validateFirebaseDataArg("Reference.push", 1, value, this.path, true);
          util.validateCallback("Reference.push", 2, onComplete, true);
          var now = this.repo.serverTime();
          var name = nextPushId(now);
          var thennablePushRef = this.child(name);
          var pushRef = this.child(name);
          var promise;
          promise = null != value ? thennablePushRef.set(value, onComplete).then(function() {
            return pushRef;
          }) : Promise.resolve(pushRef);
          thennablePushRef.then = promise.then.bind(promise);
          thennablePushRef.catch = promise.then.bind(promise, void 0);
          "function" === typeof onComplete && promise.catch(function() {});
          return thennablePushRef;
        };
        Reference.prototype.onDisconnect = function() {
          validateWritablePath("Reference.onDisconnect", this.path);
          return new OnDisconnect(this.repo, this.path);
        };
        Object.defineProperty(Reference.prototype, "database", {
          get: function() {
            return this.databaseProp();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Reference.prototype, "key", {
          get: function() {
            return this.getKey();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Reference.prototype, "parent", {
          get: function() {
            return this.getParent();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Reference.prototype, "root", {
          get: function() {
            return this.getRoot();
          },
          enumerable: true,
          configurable: true
        });
        return Reference;
      }(Query);
      Query.__referenceConstructor = Reference;
      SyncPoint.__referenceConstructor = Reference;
      var TreeNode = function() {
        function TreeNode() {
          this.children = {};
          this.childCount = 0;
          this.value = null;
        }
        return TreeNode;
      }();
      var Tree = function() {
        function Tree(name_, parent_, node_) {
          void 0 === name_ && (name_ = "");
          void 0 === parent_ && (parent_ = null);
          void 0 === node_ && (node_ = new TreeNode());
          this.name_ = name_;
          this.parent_ = parent_;
          this.node_ = node_;
        }
        Tree.prototype.subTree = function(pathObj) {
          var path = pathObj instanceof Path ? pathObj : new Path(pathObj);
          var child = this, next;
          while (null !== (next = path.getFront())) {
            var childNode = util.safeGet(child.node_.children, next) || new TreeNode();
            child = new Tree(next, child, childNode);
            path = path.popFront();
          }
          return child;
        };
        Tree.prototype.getValue = function() {
          return this.node_.value;
        };
        Tree.prototype.setValue = function(value) {
          util.assert("undefined" !== typeof value, "Cannot set value to undefined");
          this.node_.value = value;
          this.updateParents_();
        };
        Tree.prototype.clear = function() {
          this.node_.value = null;
          this.node_.children = {};
          this.node_.childCount = 0;
          this.updateParents_();
        };
        Tree.prototype.hasChildren = function() {
          return this.node_.childCount > 0;
        };
        Tree.prototype.isEmpty = function() {
          return null === this.getValue() && !this.hasChildren();
        };
        Tree.prototype.forEachChild = function(action) {
          var _this = this;
          util.forEach(this.node_.children, function(child, childTree) {
            action(new Tree(child, _this, childTree));
          });
        };
        Tree.prototype.forEachDescendant = function(action, includeSelf, childrenFirst) {
          includeSelf && !childrenFirst && action(this);
          this.forEachChild(function(child) {
            child.forEachDescendant(action, true, childrenFirst);
          });
          includeSelf && childrenFirst && action(this);
        };
        Tree.prototype.forEachAncestor = function(action, includeSelf) {
          var node = includeSelf ? this : this.parent();
          while (null !== node) {
            if (action(node)) return true;
            node = node.parent();
          }
          return false;
        };
        Tree.prototype.forEachImmediateDescendantWithValue = function(action) {
          this.forEachChild(function(child) {
            null !== child.getValue() ? action(child) : child.forEachImmediateDescendantWithValue(action);
          });
        };
        Tree.prototype.path = function() {
          return new Path(null === this.parent_ ? this.name_ : this.parent_.path() + "/" + this.name_);
        };
        Tree.prototype.name = function() {
          return this.name_;
        };
        Tree.prototype.parent = function() {
          return this.parent_;
        };
        Tree.prototype.updateParents_ = function() {
          null !== this.parent_ && this.parent_.updateChild_(this.name_, this);
        };
        Tree.prototype.updateChild_ = function(childName, child) {
          var childEmpty = child.isEmpty();
          var childExists = util.contains(this.node_.children, childName);
          if (childEmpty && childExists) {
            delete this.node_.children[childName];
            this.node_.childCount--;
            this.updateParents_();
          } else if (!childEmpty && !childExists) {
            this.node_.children[childName] = child.node_;
            this.node_.childCount++;
            this.updateParents_();
          }
        };
        return Tree;
      }();
      var TransactionStatus;
      (function(TransactionStatus) {
        TransactionStatus[TransactionStatus["RUN"] = 0] = "RUN";
        TransactionStatus[TransactionStatus["SENT"] = 1] = "SENT";
        TransactionStatus[TransactionStatus["COMPLETED"] = 2] = "COMPLETED";
        TransactionStatus[TransactionStatus["SENT_NEEDS_ABORT"] = 3] = "SENT_NEEDS_ABORT";
        TransactionStatus[TransactionStatus["NEEDS_ABORT"] = 4] = "NEEDS_ABORT";
      })(TransactionStatus || (TransactionStatus = {}));
      Repo.MAX_TRANSACTION_RETRIES_ = 25;
      Repo.prototype.transactions_init_ = function() {
        this.transactionQueueTree_ = new Tree();
      };
      Repo.prototype.startTransaction = function(path, transactionUpdate, onComplete, applyLocally) {
        this.log_("transaction on " + path);
        var valueCallback = function() {};
        var watchRef = new Reference(this, path);
        watchRef.on("value", valueCallback);
        var unwatcher = function() {
          watchRef.off("value", valueCallback);
        };
        var transaction = {
          path: path,
          update: transactionUpdate,
          onComplete: onComplete,
          status: null,
          order: LUIDGenerator(),
          applyLocally: applyLocally,
          retryCount: 0,
          unwatcher: unwatcher,
          abortReason: null,
          currentWriteId: null,
          currentInputSnapshot: null,
          currentOutputSnapshotRaw: null,
          currentOutputSnapshotResolved: null
        };
        var currentState = this.getLatestState_(path);
        transaction.currentInputSnapshot = currentState;
        var newVal = transaction.update(currentState.val());
        if (void 0 === newVal) {
          transaction.unwatcher();
          transaction.currentOutputSnapshotRaw = null;
          transaction.currentOutputSnapshotResolved = null;
          if (transaction.onComplete) {
            var snapshot = new DataSnapshot(transaction.currentInputSnapshot, new Reference(this, transaction.path), PRIORITY_INDEX);
            transaction.onComplete(null, false, snapshot);
          }
        } else {
          validateFirebaseData("transaction failed: Data returned ", newVal, transaction.path);
          transaction.status = TransactionStatus.RUN;
          var queueNode = this.transactionQueueTree_.subTree(path);
          var nodeQueue = queueNode.getValue() || [];
          nodeQueue.push(transaction);
          queueNode.setValue(nodeQueue);
          var priorityForNode = void 0;
          if ("object" === typeof newVal && null !== newVal && util.contains(newVal, ".priority")) {
            priorityForNode = util.safeGet(newVal, ".priority");
            util.assert(isValidPriority(priorityForNode), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.");
          } else {
            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) || ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
          }
          priorityForNode = priorityForNode;
          var serverValues = this.generateServerValues();
          var newNodeUnresolved = nodeFromJSON$1(newVal, priorityForNode);
          var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
          transaction.currentOutputSnapshotRaw = newNodeUnresolved;
          transaction.currentOutputSnapshotResolved = newNode;
          transaction.currentWriteId = this.getNextWriteId_();
          var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);
          this.eventQueue_.raiseEventsForChangedPath(path, events);
          this.sendReadyTransactions_();
        }
      };
      Repo.prototype.getLatestState_ = function(path, excludeSets) {
        return this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) || ChildrenNode.EMPTY_NODE;
      };
      Repo.prototype.sendReadyTransactions_ = function(node) {
        var _this = this;
        void 0 === node && (node = this.transactionQueueTree_);
        node || this.pruneCompletedTransactionsBelowNode_(node);
        if (null !== node.getValue()) {
          var queue = this.buildTransactionQueue_(node);
          util.assert(queue.length > 0, "Sending zero length transaction queue");
          var allRun = queue.every(function(transaction) {
            return transaction.status === TransactionStatus.RUN;
          });
          allRun && this.sendTransactionQueue_(node.path(), queue);
        } else node.hasChildren() && node.forEachChild(function(childNode) {
          _this.sendReadyTransactions_(childNode);
        });
      };
      Repo.prototype.sendTransactionQueue_ = function(path, queue) {
        var _this = this;
        var setsToIgnore = queue.map(function(txn) {
          return txn.currentWriteId;
        });
        var latestState = this.getLatestState_(path, setsToIgnore);
        var snapToSend = latestState;
        var latestHash = latestState.hash();
        for (var i = 0; i < queue.length; i++) {
          var txn = queue[i];
          util.assert(txn.status === TransactionStatus.RUN, "tryToSendTransactionQueue_: items in queue should all be run.");
          txn.status = TransactionStatus.SENT;
          txn.retryCount++;
          var relativePath = Path.relativePath(path, txn.path);
          snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
        }
        var dataToSend = snapToSend.val(true);
        var pathToSend = path;
        this.server_.put(pathToSend.toString(), dataToSend, function(status) {
          _this.log_("transaction put response", {
            path: pathToSend.toString(),
            status: status
          });
          var events = [];
          if ("ok" === status) {
            var callbacks = [];
            for (var i = 0; i < queue.length; i++) {
              queue[i].status = TransactionStatus.COMPLETED;
              events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));
              if (queue[i].onComplete) {
                var node = queue[i].currentOutputSnapshotResolved;
                var ref = new Reference(_this, queue[i].path);
                var snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);
                callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));
              }
              queue[i].unwatcher();
            }
            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));
            _this.sendReadyTransactions_();
            _this.eventQueue_.raiseEventsForChangedPath(path, events);
            for (var i = 0; i < callbacks.length; i++) exceptionGuard(callbacks[i]);
          } else {
            if ("datastale" === status) for (var i = 0; i < queue.length; i++) queue[i].status === TransactionStatus.SENT_NEEDS_ABORT ? queue[i].status = TransactionStatus.NEEDS_ABORT : queue[i].status = TransactionStatus.RUN; else {
              warn("transaction at " + pathToSend.toString() + " failed: " + status);
              for (var i = 0; i < queue.length; i++) {
                queue[i].status = TransactionStatus.NEEDS_ABORT;
                queue[i].abortReason = status;
              }
            }
            _this.rerunTransactions_(path);
          }
        }, latestHash);
      };
      Repo.prototype.rerunTransactions_ = function(changedPath) {
        var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);
        var path = rootMostTransactionNode.path();
        var queue = this.buildTransactionQueue_(rootMostTransactionNode);
        this.rerunTransactionQueue_(queue, path);
        return path;
      };
      Repo.prototype.rerunTransactionQueue_ = function(queue, path) {
        if (0 === queue.length) return;
        var callbacks = [];
        var events = [];
        var txnsToRerun = queue.filter(function(q) {
          return q.status === TransactionStatus.RUN;
        });
        var setsToIgnore = txnsToRerun.map(function(q) {
          return q.currentWriteId;
        });
        for (var i = 0; i < queue.length; i++) {
          var transaction = queue[i];
          var relativePath = Path.relativePath(path, transaction.path);
          var abortTransaction = false, abortReason = void 0;
          util.assert(null !== relativePath, "rerunTransactionsUnderNode_: relativePath should not be null.");
          if (transaction.status === TransactionStatus.NEEDS_ABORT) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
          } else if (transaction.status === TransactionStatus.RUN) if (transaction.retryCount >= Repo.MAX_TRANSACTION_RETRIES_) {
            abortTransaction = true;
            abortReason = "maxretry";
            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
          } else {
            var currentNode = this.getLatestState_(transaction.path, setsToIgnore);
            transaction.currentInputSnapshot = currentNode;
            var newData = queue[i].update(currentNode.val());
            if (void 0 !== newData) {
              validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
              var newDataNode = nodeFromJSON$1(newData);
              var hasExplicitPriority = "object" === typeof newData && null != newData && util.contains(newData, ".priority");
              hasExplicitPriority || (newDataNode = newDataNode.updatePriority(currentNode.getPriority()));
              var oldWriteId = transaction.currentWriteId;
              var serverValues = this.generateServerValues();
              var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, serverValues);
              transaction.currentOutputSnapshotRaw = newDataNode;
              transaction.currentOutputSnapshotResolved = newNodeResolved;
              transaction.currentWriteId = this.getNextWriteId_();
              setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
              events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
              events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));
            } else {
              abortTransaction = true;
              abortReason = "nodata";
              events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
            }
          }
          this.eventQueue_.raiseEventsForChangedPath(path, events);
          events = [];
          if (abortTransaction) {
            queue[i].status = TransactionStatus.COMPLETED;
            (function(unwatcher) {
              setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) if ("nodata" === abortReason) {
              var ref = new Reference(this, queue[i].path);
              var lastInput = queue[i].currentInputSnapshot;
              var snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);
              callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));
            } else callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));
          }
        }
        this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);
        for (var i = 0; i < callbacks.length; i++) exceptionGuard(callbacks[i]);
        this.sendReadyTransactions_();
      };
      Repo.prototype.getAncestorTransactionNode_ = function(path) {
        var front;
        var transactionNode = this.transactionQueueTree_;
        while (null !== (front = path.getFront()) && null === transactionNode.getValue()) {
          transactionNode = transactionNode.subTree(front);
          path = path.popFront();
        }
        return transactionNode;
      };
      Repo.prototype.buildTransactionQueue_ = function(transactionNode) {
        var transactionQueue = [];
        this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);
        transactionQueue.sort(function(a, b) {
          return a.order - b.order;
        });
        return transactionQueue;
      };
      Repo.prototype.aggregateTransactionQueuesForNode_ = function(node, queue) {
        var _this = this;
        var nodeQueue = node.getValue();
        if (null !== nodeQueue) for (var i = 0; i < nodeQueue.length; i++) queue.push(nodeQueue[i]);
        node.forEachChild(function(child) {
          _this.aggregateTransactionQueuesForNode_(child, queue);
        });
      };
      Repo.prototype.pruneCompletedTransactionsBelowNode_ = function(node) {
        var _this = this;
        var queue = node.getValue();
        if (queue) {
          var to = 0;
          for (var from = 0; from < queue.length; from++) if (queue[from].status !== TransactionStatus.COMPLETED) {
            queue[to] = queue[from];
            to++;
          }
          queue.length = to;
          node.setValue(queue.length > 0 ? queue : null);
        }
        node.forEachChild(function(childNode) {
          _this.pruneCompletedTransactionsBelowNode_(childNode);
        });
      };
      Repo.prototype.abortTransactions_ = function(path) {
        var _this = this;
        var affectedPath = this.getAncestorTransactionNode_(path).path();
        var transactionNode = this.transactionQueueTree_.subTree(path);
        transactionNode.forEachAncestor(function(node) {
          _this.abortTransactionsOnNode_(node);
        });
        this.abortTransactionsOnNode_(transactionNode);
        transactionNode.forEachDescendant(function(node) {
          _this.abortTransactionsOnNode_(node);
        });
        return affectedPath;
      };
      Repo.prototype.abortTransactionsOnNode_ = function(node) {
        var queue = node.getValue();
        if (null !== queue) {
          var callbacks = [];
          var events = [];
          var lastSent = -1;
          for (var i = 0; i < queue.length; i++) if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) ; else if (queue[i].status === TransactionStatus.SENT) {
            util.assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
            lastSent = i;
            queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;
            queue[i].abortReason = "set";
          } else {
            util.assert(queue[i].status === TransactionStatus.RUN, "Unexpected transaction status in abort");
            queue[i].unwatcher();
            events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));
            if (queue[i].onComplete) {
              var snapshot = null;
              callbacks.push(queue[i].onComplete.bind(null, new Error("set"), false, snapshot));
            }
          }
          -1 === lastSent ? node.setValue(null) : queue.length = lastSent + 1;
          this.eventQueue_.raiseEventsForChangedPath(node.path(), events);
          for (var i = 0; i < callbacks.length; i++) exceptionGuard(callbacks[i]);
        }
      };
      var DATABASE_URL_OPTION = "databaseURL";
      var _staticInstance;
      var RepoManager = function() {
        function RepoManager() {
          this.repos_ = {};
          this.useRestClient_ = false;
        }
        RepoManager.getInstance = function() {
          _staticInstance || (_staticInstance = new RepoManager());
          return _staticInstance;
        };
        RepoManager.prototype.interrupt = function() {
          for (var appName in this.repos_) for (var dbUrl in this.repos_[appName]) this.repos_[appName][dbUrl].interrupt();
        };
        RepoManager.prototype.resume = function() {
          for (var appName in this.repos_) for (var dbUrl in this.repos_[appName]) this.repos_[appName][dbUrl].resume();
        };
        RepoManager.prototype.databaseFromApp = function(app, url) {
          var dbUrl = url || app.options[DATABASE_URL_OPTION];
          void 0 === dbUrl && fatal("Can't determine Firebase Database URL.  Be sure to include " + DATABASE_URL_OPTION + " option when calling firebase.initializeApp().");
          var parsedUrl = parseRepoInfo(dbUrl);
          var repoInfo = parsedUrl.repoInfo;
          validateUrl("Invalid Firebase Database URL", 1, parsedUrl);
          parsedUrl.path.isEmpty() || fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
          var repo = this.createRepo(repoInfo, app);
          return repo.database;
        };
        RepoManager.prototype.deleteRepo = function(repo) {
          var appRepos = util.safeGet(this.repos_, repo.app.name);
          appRepos && util.safeGet(appRepos, repo.repoInfo_.toURLString()) === repo || fatal("Database " + repo.app.name + "(" + repo.repoInfo_ + ") has already been deleted.");
          repo.interrupt();
          delete appRepos[repo.repoInfo_.toURLString()];
        };
        RepoManager.prototype.createRepo = function(repoInfo, app) {
          var appRepos = util.safeGet(this.repos_, app.name);
          if (!appRepos) {
            appRepos = {};
            this.repos_[app.name] = appRepos;
          }
          var repo = util.safeGet(appRepos, repoInfo.toURLString());
          repo && fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
          repo = new Repo(repoInfo, this.useRestClient_, app);
          appRepos[repoInfo.toURLString()] = repo;
          return repo;
        };
        RepoManager.prototype.forceRestClient = function(forceRestClient) {
          this.useRestClient_ = forceRestClient;
        };
        return RepoManager;
      }();
      var Database = function() {
        function Database(repo_) {
          this.repo_ = repo_;
          repo_ instanceof Repo || fatal("Don't call new Database() directly - please use firebase.database().");
          this.root_ = new Reference(repo_, Path.Empty);
          this.INTERNAL = new DatabaseInternals(this);
        }
        Object.defineProperty(Database.prototype, "app", {
          get: function() {
            return this.repo_.app;
          },
          enumerable: true,
          configurable: true
        });
        Database.prototype.ref = function(path) {
          this.checkDeleted_("ref");
          util.validateArgCount("database.ref", 0, 1, arguments.length);
          if (path instanceof Reference) return this.refFromURL(path.toString());
          return void 0 !== path ? this.root_.child(path) : this.root_;
        };
        Database.prototype.refFromURL = function(url) {
          var apiName = "database.refFromURL";
          this.checkDeleted_(apiName);
          util.validateArgCount(apiName, 1, 1, arguments.length);
          var parsedURL = parseRepoInfo(url);
          validateUrl(apiName, 1, parsedURL);
          var repoInfo = parsedURL.repoInfo;
          repoInfo.host !== this.repo_.repoInfo_.host && fatal(apiName + ": Host name does not match the current database: (found " + repoInfo.host + " but expected " + this.repo_.repoInfo_.host + ")");
          return this.ref(parsedURL.path.toString());
        };
        Database.prototype.checkDeleted_ = function(apiName) {
          null === this.repo_ && fatal("Cannot call " + apiName + " on a deleted database.");
        };
        Database.prototype.goOffline = function() {
          util.validateArgCount("database.goOffline", 0, 0, arguments.length);
          this.checkDeleted_("goOffline");
          this.repo_.interrupt();
        };
        Database.prototype.goOnline = function() {
          util.validateArgCount("database.goOnline", 0, 0, arguments.length);
          this.checkDeleted_("goOnline");
          this.repo_.resume();
        };
        Database.ServerValue = {
          TIMESTAMP: {
            ".sv": "timestamp"
          }
        };
        return Database;
      }();
      var DatabaseInternals = function() {
        function DatabaseInternals(database) {
          this.database = database;
        }
        DatabaseInternals.prototype.delete = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              this.database.checkDeleted_("delete");
              RepoManager.getInstance().deleteRepo(this.database.repo_);
              this.database.repo_ = null;
              this.database.root_ = null;
              this.database.INTERNAL = null;
              this.database = null;
              return [ 2 ];
            });
          });
        };
        return DatabaseInternals;
      }();
      var forceLongPolling = function() {
        WebSocketConnection.forceDisallow();
        BrowserPollConnection.forceAllow();
      };
      var forceWebSockets = function() {
        BrowserPollConnection.forceDisallow();
      };
      var isWebSocketsAvailable = function() {
        return WebSocketConnection["isAvailable"]();
      };
      var setSecurityDebugCallback = function(ref, callback) {
        ref.repo.persistentConnection_.securityDebugCallback_ = callback;
      };
      var stats = function(ref, showDelta) {
        ref.repo.stats(showDelta);
      };
      var statsIncrementCounter = function(ref, metric) {
        ref.repo.statsIncrementCounter(metric);
      };
      var dataUpdateCount = function(ref) {
        return ref.repo.dataUpdateCount;
      };
      var interceptServerData = function(ref, callback) {
        return ref.repo.interceptServerData_(callback);
      };
      var INTERNAL = Object.freeze({
        forceLongPolling: forceLongPolling,
        forceWebSockets: forceWebSockets,
        isWebSocketsAvailable: isWebSocketsAvailable,
        setSecurityDebugCallback: setSecurityDebugCallback,
        stats: stats,
        statsIncrementCounter: statsIncrementCounter,
        dataUpdateCount: dataUpdateCount,
        interceptServerData: interceptServerData
      });
      var DataConnection = PersistentConnection;
      PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
        this.sendRequest("q", {
          p: pathString
        }, onComplete);
      };
      PersistentConnection.prototype.echo = function(data, onEcho) {
        this.sendRequest("echo", {
          d: data
        }, onEcho);
      };
      var RealTimeConnection = Connection;
      var hijackHash = function(newHash) {
        var oldPut = PersistentConnection.prototype.put;
        PersistentConnection.prototype.put = function(pathString, data, opt_onComplete, opt_hash) {
          void 0 !== opt_hash && (opt_hash = newHash());
          oldPut.call(this, pathString, data, opt_onComplete, opt_hash);
        };
        return function() {
          PersistentConnection.prototype.put = oldPut;
        };
      };
      var ConnectionTarget = RepoInfo;
      var queryIdentifier = function(query) {
        return query.queryIdentifier();
      };
      var listens = function(firebaseRef) {
        return firebaseRef.repo.persistentConnection_.listens_;
      };
      var forceRestClient = function(forceRestClient) {
        RepoManager.getInstance().forceRestClient(forceRestClient);
      };
      var TEST_ACCESS = Object.freeze({
        DataConnection: DataConnection,
        RealTimeConnection: RealTimeConnection,
        hijackHash: hijackHash,
        ConnectionTarget: ConnectionTarget,
        queryIdentifier: queryIdentifier,
        listens: listens,
        forceRestClient: forceRestClient
      });
      var ServerValue = Database.ServerValue;
      function registerDatabase(instance) {
        var namespace = instance.INTERNAL.registerService("database", function(app, unused, url) {
          return RepoManager.getInstance().databaseFromApp(app, url);
        }, {
          Reference: Reference,
          Query: Query,
          Database: Database,
          enableLogging: enableLogging,
          INTERNAL: INTERNAL,
          ServerValue: ServerValue,
          TEST_ACCESS: TEST_ACCESS
        }, null, true);
        util.isNodeSdk() && (module.exports = namespace);
      }
      registerDatabase(firebase);
      exports.registerDatabase = registerDatabase;
      exports.Database = Database;
      exports.Query = Query;
      exports.Reference = Reference;
      exports.enableLogging = enableLogging;
      exports.ServerValue = ServerValue;
      exports.DataSnapshot = DataSnapshot;
      exports.OnDisconnect = OnDisconnect;
    }).call(this, require("_process"));
  }, {
    "@firebase/app": 7,
    "@firebase/logger": 12,
    "@firebase/util": 16,
    _process: 6,
    tslib: 61
  } ],
  10: [ function(require, module, exports) {
    (function(process) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _interopDefault(ex) {
        return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
      }
      var firebase = _interopDefault(require("@firebase/app"));
      var logger = require("@firebase/logger");
      var tslib_1 = require("tslib");
      var webchannelWrapper = require("@firebase/webchannel-wrapper");
      var SDK_VERSION = firebase.SDK_VERSION;
      var logClient = new logger.Logger("@firebase/firestore");
      var LogLevel;
      (function(LogLevel) {
        LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
        LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
        LogLevel[LogLevel["SILENT"] = 2] = "SILENT";
      })(LogLevel || (LogLevel = {}));
      function getLogLevel() {
        return logClient.logLevel === logger.LogLevel.DEBUG ? LogLevel.DEBUG : logClient.logLevel === logger.LogLevel.SILENT ? LogLevel.SILENT : LogLevel.ERROR;
      }
      function setLogLevel(newLevel) {
        switch (newLevel) {
         case LogLevel.DEBUG:
          logClient.logLevel = logger.LogLevel.DEBUG;
          break;

         case LogLevel.ERROR:
          logClient.logLevel = logger.LogLevel.ERROR;
          break;

         case LogLevel.SILENT:
          logClient.logLevel = logger.LogLevel.SILENT;
          break;

         default:
          logClient.error("Firestore (" + SDK_VERSION + "): Invalid value passed to `setLogLevel`");
        }
      }
      function debug(tag, msg) {
        var obj = [];
        for (var _i = 2; _i < arguments.length; _i++) obj[_i - 2] = arguments[_i];
        if (logClient.logLevel <= logger.LogLevel.DEBUG) {
          var args = obj.map(argToString);
          logClient.debug.apply(logClient, [ "Firestore (" + SDK_VERSION + ") [" + tag + "]: " + msg ].concat(args));
        }
      }
      function error(msg) {
        var obj = [];
        for (var _i = 1; _i < arguments.length; _i++) obj[_i - 1] = arguments[_i];
        if (logClient.logLevel <= logger.LogLevel.ERROR) {
          var args = obj.map(argToString);
          logClient.error.apply(logClient, [ "Firestore (" + SDK_VERSION + "): " + msg ].concat(args));
        }
      }
      function argToString(obj) {
        if ("string" === typeof obj) return obj;
        var platform = PlatformSupport.getPlatform();
        try {
          return platform.formatJSON(obj);
        } catch (e) {
          return obj;
        }
      }
      function fail(failure) {
        var message = "FIRESTORE (" + SDK_VERSION + ") INTERNAL ASSERTION FAILED: " + failure;
        error(message);
        throw new Error(message);
      }
      function assert(assertion, message) {
        assertion || fail(message);
      }
      var PlatformSupport = function() {
        function PlatformSupport() {}
        PlatformSupport.setPlatform = function(platform) {
          PlatformSupport.platform && fail("Platform already defined");
          PlatformSupport.platform = platform;
        };
        PlatformSupport.getPlatform = function() {
          PlatformSupport.platform || fail("Platform not set");
          return PlatformSupport.platform;
        };
        return PlatformSupport;
      }();
      function emptyByteString() {
        return PlatformSupport.getPlatform().emptyByteString;
      }
      var Code = {
        OK: "ok",
        CANCELLED: "cancelled",
        UNKNOWN: "unknown",
        INVALID_ARGUMENT: "invalid-argument",
        DEADLINE_EXCEEDED: "deadline-exceeded",
        NOT_FOUND: "not-found",
        ALREADY_EXISTS: "already-exists",
        PERMISSION_DENIED: "permission-denied",
        UNAUTHENTICATED: "unauthenticated",
        RESOURCE_EXHAUSTED: "resource-exhausted",
        FAILED_PRECONDITION: "failed-precondition",
        ABORTED: "aborted",
        OUT_OF_RANGE: "out-of-range",
        UNIMPLEMENTED: "unimplemented",
        INTERNAL: "internal",
        UNAVAILABLE: "unavailable",
        DATA_LOSS: "data-loss"
      };
      var FirestoreError = function(_super) {
        tslib_1.__extends(FirestoreError, _super);
        function FirestoreError(code, message) {
          var _this = _super.call(this, message) || this;
          _this.code = code;
          _this.message = message;
          _this.name = "FirebaseError";
          _this.toString = function() {
            return _this.name + ": [code=" + _this.code + "]: " + _this.message;
          };
          return _this;
        }
        return FirestoreError;
      }(Error);
      function makeConstructorPrivate(cls, optionalMessage) {
        function PublicConstructor() {
          var error = "This constructor is private.";
          if (optionalMessage) {
            error += " ";
            error += optionalMessage;
          }
          throw new FirestoreError(Code.INVALID_ARGUMENT, error);
        }
        PublicConstructor.prototype = cls.prototype;
        for (var staticProperty in cls) cls.hasOwnProperty(staticProperty) && (PublicConstructor[staticProperty] = cls[staticProperty]);
        return PublicConstructor;
      }
      function contains(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      function defaulted(value, defaultValue) {
        return void 0 !== value ? value : defaultValue;
      }
      function forEachNumber(obj, fn) {
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var num = Number(key);
          isNaN(num) || fn(num, obj[key]);
        }
      }
      function forEach(obj, fn) {
        for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && fn(key, obj[key]);
      }
      function isEmpty(obj) {
        assert(null != obj && "object" === typeof obj, "isEmpty() expects object parameter.");
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) return false;
        return true;
      }
      function shallowCopy(obj) {
        assert(obj && "object" === typeof obj, "shallowCopy() expects object parameter.");
        var result = {};
        for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (result[key] = obj[key]);
        return result;
      }
      function validateExactNumberOfArgs(functionName, args, numberOfArgs) {
        if (args.length !== numberOfArgs) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires " + formatPlural(numberOfArgs, "argument") + ", but was called with " + formatPlural(args.length, "argument") + ".");
      }
      function validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {
        if (args.length < minNumberOfArgs) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires at least " + formatPlural(minNumberOfArgs, "argument") + ", but was called with " + formatPlural(args.length, "argument") + ".");
      }
      function validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {
        if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires between " + minNumberOfArgs + " and " + maxNumberOfArgs + " arguments, but was called with " + formatPlural(args.length, "argument") + ".");
      }
      function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {
        if (!(value instanceof Array) || value.length < minNumberOfElements) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + name + " argument to be an array with at least " + formatPlural(minNumberOfElements, "element") + ".");
      }
      function validateArgType(functionName, type, position, argument) {
        validateType(functionName, type, ordinal(position) + " argument", argument);
      }
      function validateOptionalArgType(functionName, type, position, argument) {
        void 0 !== argument && validateArgType(functionName, type, position, argument);
      }
      function validateNamedType(functionName, type, optionName, argument) {
        validateType(functionName, type, optionName + " option", argument);
      }
      function validateNamedOptionalType(functionName, type, optionName, argument) {
        void 0 !== argument && validateNamedType(functionName, type, optionName, argument);
      }
      function validateArrayElements(functionName, optionName, typeDescription, argument, validator) {
        if (!(argument instanceof Array)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + optionName + " option to be an array, but it was: " + valueDescription(argument));
        for (var i = 0; i < argument.length; ++i) if (!validator(argument[i])) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires all " + optionName + " elements to be " + typeDescription + ", but the value at index " + i + " was: " + valueDescription(argument[i]));
      }
      function validateOptionalArrayElements(functionName, optionName, typeDescription, argument, validator) {
        void 0 !== argument && validateArrayElements(functionName, optionName, typeDescription, argument, validator);
      }
      function validateNamedPropertyEquals(functionName, inputName, optionName, input, expected) {
        var expectedDescription = [];
        for (var _i = 0, expected_1 = expected; _i < expected_1.length; _i++) {
          var val = expected_1[_i];
          if (val === input) return;
          expectedDescription.push(valueDescription(val));
        }
        var actualDescription = valueDescription(input);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid value " + actualDescription + " provided to function " + functionName + '() for option "' + optionName + '". Acceptable values: ' + expectedDescription.join(", "));
      }
      function validateNamedOptionalPropertyEquals(functionName, inputName, optionName, input, expected) {
        void 0 !== input && validateNamedPropertyEquals(functionName, inputName, optionName, input, expected);
      }
      function validateType(functionName, type, inputName, input) {
        if (typeof input !== type || "object" === type && !isPlainObject(input)) {
          var description = valueDescription(input);
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + inputName + " to be of type " + type + ", but it was: " + description);
        }
      }
      function isPlainObject(input) {
        return "object" === typeof input && null !== input && (Object.getPrototypeOf(input) === Object.prototype || null === Object.getPrototypeOf(input));
      }
      function valueDescription(input) {
        if (void 0 === input) return "undefined";
        if (null === input) return "null";
        if ("string" === typeof input) {
          input.length > 20 && (input = input.substring(0, 20) + "...");
          return JSON.stringify(input);
        }
        if ("number" === typeof input || "boolean" === typeof input) return "" + input;
        if ("object" === typeof input) {
          if (input instanceof Array) return "an array";
          var customObjectName = tryGetCustomObjectType(input);
          return customObjectName ? "a custom " + customObjectName + " object" : "an object";
        }
        return "function" === typeof input ? "a function" : fail("Unknown wrong type: " + typeof input);
      }
      function tryGetCustomObjectType(input) {
        if (input.constructor) {
          var funcNameRegex = /function\s+([^\s(]+)\s*\(/;
          var results = funcNameRegex.exec(input.constructor.toString());
          if (results && results.length > 1) return results[1];
        }
        return null;
      }
      function validateDefined(functionName, position, argument) {
        if (void 0 === argument) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a valid " + ordinal(position) + " argument, but it was undefined.");
      }
      function validateOptionNames(functionName, options, optionNames) {
        forEach(options, function(key, _) {
          if (optionNames.indexOf(key) < 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Unknown option '" + key + "' passed to function " + functionName + "(). Available options: " + optionNames.join(", "));
        });
      }
      function invalidClassError(functionName, type, position, argument) {
        var description = valueDescription(argument);
        return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + ordinal(position) + " argument to be a " + type + ", but it was: " + description);
      }
      function ordinal(num) {
        switch (num) {
         case 1:
          return "first";

         case 2:
          return "second";

         case 3:
          return "third";

         default:
          return num + "th";
        }
      }
      function formatPlural(num, str) {
        return num + " " + str + (1 === num ? "" : "s");
      }
      var AutoId = function() {
        function AutoId() {}
        AutoId.newId = function() {
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          var autoId = "";
          for (var i = 0; i < 20; i++) autoId += chars.charAt(Math.floor(Math.random() * chars.length));
          assert(20 === autoId.length, "Invalid auto ID: " + autoId);
          return autoId;
        };
        return AutoId;
      }();
      function primitiveComparator(left, right) {
        if (left < right) return -1;
        if (left > right) return 1;
        return 0;
      }
      function equals(left, right) {
        return null !== left && void 0 !== left ? !!(right && left.isEqual(right)) : left === right;
      }
      function arrayEquals(left, right) {
        if (left.length !== right.length) return false;
        for (var i = 0; i < left.length; i++) if (!left[i].isEqual(right[i])) return false;
        return true;
      }
      function immediatePredecessor(s) {
        var lastIndex = s.length - 1;
        return 0 === s.length ? "" : "\0" === s.charAt(lastIndex) ? s.substring(0, lastIndex) : s.substring(0, lastIndex) + String.fromCharCode(s.charCodeAt(lastIndex) - 1);
      }
      function immediateSuccessor(s) {
        return s + "\0";
      }
      function assertUint8ArrayAvailable() {
        if ("undefined" === typeof Uint8Array) throw new FirestoreError(Code.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
      }
      function assertBase64Available() {
        if (!PlatformSupport.getPlatform().base64Available) throw new FirestoreError(Code.UNIMPLEMENTED, "Blobs are unavailable in Firestore in this environment.");
      }
      var Blob = function() {
        function Blob(binaryString) {
          assertBase64Available();
          this._binaryString = binaryString;
        }
        Blob.fromBase64String = function(base64) {
          validateExactNumberOfArgs("Blob.fromBase64String", arguments, 1);
          validateArgType("Blob.fromBase64String", "string", 1, base64);
          assertBase64Available();
          try {
            var binaryString = PlatformSupport.getPlatform().atob(base64);
            return new Blob(binaryString);
          } catch (e) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Failed to construct Blob from Base64 string: " + e);
          }
        };
        Blob.fromUint8Array = function(array) {
          validateExactNumberOfArgs("Blob.fromUint8Array", arguments, 1);
          assertUint8ArrayAvailable();
          if (!(array instanceof Uint8Array)) throw invalidClassError("Blob.fromUint8Array", "Uint8Array", 1, array);
          var binaryString = Array.prototype.map.call(array, function(char) {
            return String.fromCharCode(char);
          }).join("");
          return new Blob(binaryString);
        };
        Blob.prototype.toBase64 = function() {
          validateExactNumberOfArgs("Blob.toBase64", arguments, 0);
          assertBase64Available();
          return PlatformSupport.getPlatform().btoa(this._binaryString);
        };
        Blob.prototype.toUint8Array = function() {
          validateExactNumberOfArgs("Blob.toUint8Array", arguments, 0);
          assertUint8ArrayAvailable();
          var buffer = new Uint8Array(this._binaryString.length);
          for (var i = 0; i < this._binaryString.length; i++) buffer[i] = this._binaryString.charCodeAt(i);
          return buffer;
        };
        Blob.prototype.toString = function() {
          return "Blob(base64: " + this.toBase64() + ")";
        };
        Blob.prototype.isEqual = function(other) {
          return this._binaryString === other._binaryString;
        };
        Blob.prototype._compareTo = function(other) {
          return primitiveComparator(this._binaryString, other._binaryString);
        };
        return Blob;
      }();
      var PublicBlob = makeConstructorPrivate(Blob, "Use Blob.fromUint8Array() or Blob.fromBase64String() instead.");
      var GeoPoint = function() {
        function GeoPoint(latitude, longitude) {
          validateExactNumberOfArgs("GeoPoint", arguments, 2);
          validateArgType("GeoPoint", "number", 1, latitude);
          validateArgType("GeoPoint", "number", 2, longitude);
          if (!isFinite(latitude) || latitude < -90 || latitude > 90) throw new FirestoreError(Code.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + latitude);
          if (!isFinite(longitude) || longitude < -180 || longitude > 180) throw new FirestoreError(Code.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + longitude);
          this._lat = latitude;
          this._long = longitude;
        }
        Object.defineProperty(GeoPoint.prototype, "latitude", {
          get: function() {
            return this._lat;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(GeoPoint.prototype, "longitude", {
          get: function() {
            return this._long;
          },
          enumerable: true,
          configurable: true
        });
        GeoPoint.prototype.isEqual = function(other) {
          return this._lat === other._lat && this._long === other._long;
        };
        GeoPoint.prototype._compareTo = function(other) {
          return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
        };
        return GeoPoint;
      }();
      var Timestamp = function() {
        function Timestamp(seconds, nanoseconds) {
          this.seconds = seconds;
          this.nanoseconds = nanoseconds;
          if (nanoseconds < 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
          if (nanoseconds >= 1e9) throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
          if (seconds < -62135596800) throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
          if (seconds >= 253402300800) throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
        }
        Timestamp.now = function() {
          return Timestamp.fromMillis(Date.now());
        };
        Timestamp.fromDate = function(date) {
          return Timestamp.fromMillis(date.getTime());
        };
        Timestamp.fromMillis = function(milliseconds) {
          var seconds = Math.floor(milliseconds / 1e3);
          var nanos = 1e6 * (milliseconds - 1e3 * seconds);
          return new Timestamp(seconds, nanos);
        };
        Timestamp.prototype.toDate = function() {
          return new Date(this.toMillis());
        };
        Timestamp.prototype.toMillis = function() {
          return 1e3 * this.seconds + this.nanoseconds / 1e6;
        };
        Timestamp.prototype._compareTo = function(other) {
          if (this.seconds === other.seconds) return primitiveComparator(this.nanoseconds, other.nanoseconds);
          return primitiveComparator(this.seconds, other.seconds);
        };
        Timestamp.prototype.isEqual = function(other) {
          return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
        };
        Timestamp.prototype.toString = function() {
          return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
        };
        return Timestamp;
      }();
      var DatabaseInfo = function() {
        function DatabaseInfo(databaseId, persistenceKey, host, ssl) {
          this.databaseId = databaseId;
          this.persistenceKey = persistenceKey;
          this.host = host;
          this.ssl = ssl;
        }
        return DatabaseInfo;
      }();
      var DEFAULT_DATABASE_NAME = "(default)";
      var DatabaseId = function() {
        function DatabaseId(projectId, database) {
          this.projectId = projectId;
          this.database = database || DEFAULT_DATABASE_NAME;
        }
        Object.defineProperty(DatabaseId.prototype, "isDefaultDatabase", {
          get: function() {
            return this.database === DEFAULT_DATABASE_NAME;
          },
          enumerable: true,
          configurable: true
        });
        DatabaseId.prototype.isEqual = function(other) {
          return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;
        };
        DatabaseId.prototype.compareTo = function(other) {
          return primitiveComparator(this.projectId, other.projectId) || primitiveComparator(this.database, other.database);
        };
        return DatabaseId;
      }();
      var DOCUMENT_KEY_NAME = "__name__";
      var Path = function() {
        function Path(segments, offset, length) {
          this.init(segments, offset, length);
        }
        Path.prototype.init = function(segments, offset, length) {
          void 0 === offset ? offset = 0 : offset > segments.length && fail("offset " + offset + " out of range " + segments.length);
          void 0 === length ? length = segments.length - offset : length > segments.length - offset && fail("length " + length + " out of range " + (segments.length - offset));
          this.segments = segments;
          this.offset = offset;
          this.len = length;
        };
        Path.prototype.construct = function(segments, offset, length) {
          var path = Object.create(Object.getPrototypeOf(this));
          path.init(segments, offset, length);
          return path;
        };
        Object.defineProperty(Path.prototype, "length", {
          get: function() {
            return this.len;
          },
          enumerable: true,
          configurable: true
        });
        Path.prototype.isEqual = function(other) {
          return 0 === Path.comparator(this, other);
        };
        Path.prototype.child = function(nameOrPath) {
          var segments = this.segments.slice(this.offset, this.limit());
          nameOrPath instanceof Path ? nameOrPath.forEach(function(segment) {
            segments.push(segment);
          }) : "string" === typeof nameOrPath ? segments.push(nameOrPath) : fail("Unknown parameter type for Path.child(): " + nameOrPath);
          return this.construct(segments);
        };
        Path.prototype.limit = function() {
          return this.offset + this.length;
        };
        Path.prototype.popFirst = function(size) {
          size = void 0 === size ? 1 : size;
          assert(this.length >= size, "Can't call popFirst() with less segments");
          return this.construct(this.segments, this.offset + size, this.length - size);
        };
        Path.prototype.popLast = function() {
          assert(!this.isEmpty(), "Can't call popLast() on empty path");
          return this.construct(this.segments, this.offset, this.length - 1);
        };
        Path.prototype.firstSegment = function() {
          assert(!this.isEmpty(), "Can't call firstSegment() on empty path");
          return this.segments[this.offset];
        };
        Path.prototype.lastSegment = function() {
          assert(!this.isEmpty(), "Can't call lastSegment() on empty path");
          return this.segments[this.limit() - 1];
        };
        Path.prototype.get = function(index) {
          assert(index < this.length, "Index out of range");
          return this.segments[this.offset + index];
        };
        Path.prototype.isEmpty = function() {
          return 0 === this.length;
        };
        Path.prototype.isPrefixOf = function(other) {
          if (other.length < this.length) return false;
          for (var i = 0; i < this.length; i++) if (this.get(i) !== other.get(i)) return false;
          return true;
        };
        Path.prototype.isImmediateParentOf = function(potentialChild) {
          if (this.length + 1 !== potentialChild.length) return false;
          for (var i = 0; i < this.length; i++) if (this.get(i) !== potentialChild.get(i)) return false;
          return true;
        };
        Path.prototype.forEach = function(fn) {
          for (var i = this.offset, end = this.limit(); i < end; i++) fn(this.segments[i]);
        };
        Path.prototype.toArray = function() {
          return this.segments.slice(this.offset, this.limit());
        };
        Path.comparator = function(p1, p2) {
          var len = Math.min(p1.length, p2.length);
          for (var i = 0; i < len; i++) {
            var left = p1.get(i);
            var right = p2.get(i);
            if (left < right) return -1;
            if (left > right) return 1;
          }
          if (p1.length < p2.length) return -1;
          if (p1.length > p2.length) return 1;
          return 0;
        };
        return Path;
      }();
      var ResourcePath = function(_super) {
        tslib_1.__extends(ResourcePath, _super);
        function ResourcePath() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ResourcePath.prototype.canonicalString = function() {
          return this.toArray().join("/");
        };
        ResourcePath.prototype.toString = function() {
          return this.canonicalString();
        };
        ResourcePath.fromString = function(path) {
          if (path.indexOf("//") >= 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid path (" + path + "). Paths must not contain // in them.");
          var segments = path.split("/").filter(function(segment) {
            return segment.length > 0;
          });
          return new ResourcePath(segments);
        };
        ResourcePath.EMPTY_PATH = new ResourcePath([]);
        return ResourcePath;
      }(Path);
      var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
      var FieldPath = function(_super) {
        tslib_1.__extends(FieldPath, _super);
        function FieldPath() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        FieldPath.isValidIdentifier = function(segment) {
          return identifierRegExp.test(segment);
        };
        FieldPath.prototype.canonicalString = function() {
          return this.toArray().map(function(str) {
            str = str.replace("\\", "\\\\").replace("`", "\\`");
            FieldPath.isValidIdentifier(str) || (str = "`" + str + "`");
            return str;
          }).join(".");
        };
        FieldPath.prototype.toString = function() {
          return this.canonicalString();
        };
        FieldPath.prototype.isKeyField = function() {
          return 1 === this.length && this.get(0) === DOCUMENT_KEY_NAME;
        };
        FieldPath.keyField = function() {
          return new FieldPath([ DOCUMENT_KEY_NAME ]);
        };
        FieldPath.fromServerFormat = function(path) {
          var segments = [];
          var current = "";
          var i = 0;
          var addCurrentSegment = function() {
            if (0 === current.length) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
            segments.push(current);
            current = "";
          };
          var inBackticks = false;
          while (i < path.length) {
            var c = path[i];
            if ("\\" === c) {
              if (i + 1 === path.length) throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path);
              var next = path[i + 1];
              if (!("\\" === next || "." === next || "`" === next)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path);
              current += next;
              i += 2;
            } else if ("`" === c) {
              inBackticks = !inBackticks;
              i++;
            } else if ("." !== c || inBackticks) {
              current += c;
              i++;
            } else {
              addCurrentSegment();
              i++;
            }
          }
          addCurrentSegment();
          if (inBackticks) throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path);
          return new FieldPath(segments);
        };
        FieldPath.EMPTY_PATH = new FieldPath([]);
        return FieldPath;
      }(Path);
      var DocumentKey = function() {
        function DocumentKey(path) {
          this.path = path;
          assert(DocumentKey.isDocumentKey(path), "Invalid DocumentKey with an odd number of segments: " + path.toArray().join("/"));
        }
        DocumentKey.prototype.isEqual = function(other) {
          return null !== other && 0 === ResourcePath.comparator(this.path, other.path);
        };
        DocumentKey.prototype.toString = function() {
          return this.path.toString();
        };
        DocumentKey.comparator = function(k1, k2) {
          return ResourcePath.comparator(k1.path, k2.path);
        };
        DocumentKey.isDocumentKey = function(path) {
          return path.length % 2 === 0;
        };
        DocumentKey.fromSegments = function(segments) {
          return new DocumentKey(new ResourcePath(segments.slice()));
        };
        DocumentKey.fromPathString = function(path) {
          return new DocumentKey(ResourcePath.fromString(path));
        };
        DocumentKey.EMPTY = new DocumentKey(new ResourcePath([]));
        return DocumentKey;
      }();
      var Document = function() {
        function Document(key, version, data, options) {
          this.key = key;
          this.version = version;
          this.data = data;
          this.hasLocalMutations = options.hasLocalMutations;
        }
        Document.prototype.field = function(path) {
          return this.data.field(path);
        };
        Document.prototype.fieldValue = function(path) {
          var field = this.field(path);
          return field ? field.value() : void 0;
        };
        Document.prototype.value = function() {
          return this.data.value();
        };
        Document.prototype.isEqual = function(other) {
          return other instanceof Document && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.data.isEqual(other.data) && this.hasLocalMutations === other.hasLocalMutations;
        };
        Document.prototype.toString = function() {
          return "Document(" + this.key + ", " + this.version + ", " + this.data.toString() + ", {hasLocalMutations: " + this.hasLocalMutations + "})";
        };
        Document.compareByKey = function(d1, d2) {
          return DocumentKey.comparator(d1.key, d2.key);
        };
        Document.compareByField = function(field, d1, d2) {
          var v1 = d1.field(field);
          var v2 = d2.field(field);
          return void 0 !== v1 && void 0 !== v2 ? v1.compareTo(v2) : fail("Trying to compare documents on fields that don't exist");
        };
        return Document;
      }();
      var NoDocument = function() {
        function NoDocument(key, version) {
          this.key = key;
          this.version = version;
        }
        NoDocument.prototype.toString = function() {
          return "NoDocument(" + this.key + ", " + this.version + ")";
        };
        NoDocument.prototype.isEqual = function(other) {
          return other && other.version.isEqual(this.version) && other.key.isEqual(this.key);
        };
        NoDocument.compareByKey = function(d1, d2) {
          return DocumentKey.comparator(d1.key, d2.key);
        };
        return NoDocument;
      }();
      var SortedMap = function() {
        function SortedMap(comparator, root) {
          this.comparator = comparator;
          this.root = root || LLRBNode.EMPTY;
        }
        SortedMap.prototype.insert = function(key, value) {
          return new SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
        };
        SortedMap.prototype.remove = function(key) {
          return new SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
        };
        SortedMap.prototype.get = function(key) {
          var node = this.root;
          while (!node.isEmpty()) {
            var cmp = this.comparator(key, node.key);
            if (0 === cmp) return node.value;
            cmp < 0 ? node = node.left : cmp > 0 && (node = node.right);
          }
          return null;
        };
        SortedMap.prototype.indexOf = function(key) {
          var prunedNodes = 0;
          var node = this.root;
          while (!node.isEmpty()) {
            var cmp = this.comparator(key, node.key);
            if (0 === cmp) return prunedNodes + node.left.size;
            if (cmp < 0) node = node.left; else {
              prunedNodes += node.left.size + 1;
              node = node.right;
            }
          }
          return -1;
        };
        SortedMap.prototype.isEmpty = function() {
          return this.root.isEmpty();
        };
        Object.defineProperty(SortedMap.prototype, "size", {
          get: function() {
            return this.root.size;
          },
          enumerable: true,
          configurable: true
        });
        SortedMap.prototype.minKey = function() {
          return this.root.minKey();
        };
        SortedMap.prototype.maxKey = function() {
          return this.root.maxKey();
        };
        SortedMap.prototype.inorderTraversal = function(action) {
          return this.root.inorderTraversal(action);
        };
        SortedMap.prototype.forEach = function(fn) {
          this.inorderTraversal(function(k, v) {
            fn(k, v);
            return false;
          });
        };
        SortedMap.prototype.reverseTraversal = function(action) {
          return this.root.reverseTraversal(action);
        };
        SortedMap.prototype.getIterator = function() {
          return new SortedMapIterator(this.root, null, this.comparator, false);
        };
        SortedMap.prototype.getIteratorFrom = function(key) {
          return new SortedMapIterator(this.root, key, this.comparator, false);
        };
        SortedMap.prototype.getReverseIterator = function() {
          return new SortedMapIterator(this.root, null, this.comparator, true);
        };
        SortedMap.prototype.getReverseIteratorFrom = function(key) {
          return new SortedMapIterator(this.root, key, this.comparator, true);
        };
        return SortedMap;
      }();
      var SortedMapIterator = function() {
        function SortedMapIterator(node, startKey, comparator, isReverse) {
          this.isReverse = isReverse;
          this.nodeStack = [];
          var cmp = 1;
          while (!node.isEmpty()) {
            cmp = startKey ? comparator(node.key, startKey) : 1;
            isReverse && (cmp *= -1);
            if (cmp < 0) node = this.isReverse ? node.left : node.right; else {
              if (0 === cmp) {
                this.nodeStack.push(node);
                break;
              }
              this.nodeStack.push(node);
              node = this.isReverse ? node.right : node.left;
            }
          }
        }
        SortedMapIterator.prototype.getNext = function() {
          assert(this.nodeStack.length > 0, "getNext() called on iterator when hasNext() is false.");
          var node = this.nodeStack.pop();
          var result = {
            key: node.key,
            value: node.value
          };
          if (this.isReverse) {
            node = node.left;
            while (!node.isEmpty()) {
              this.nodeStack.push(node);
              node = node.right;
            }
          } else {
            node = node.right;
            while (!node.isEmpty()) {
              this.nodeStack.push(node);
              node = node.left;
            }
          }
          return result;
        };
        SortedMapIterator.prototype.hasNext = function() {
          return this.nodeStack.length > 0;
        };
        SortedMapIterator.prototype.peek = function() {
          if (0 === this.nodeStack.length) return null;
          var node = this.nodeStack[this.nodeStack.length - 1];
          return {
            key: node.key,
            value: node.value
          };
        };
        return SortedMapIterator;
      }();
      var LLRBNode = function() {
        function LLRBNode(key, value, color, left, right) {
          this.key = key;
          this.value = value;
          this.color = null != color ? color : LLRBNode.RED;
          this.left = null != left ? left : LLRBNode.EMPTY;
          this.right = null != right ? right : LLRBNode.EMPTY;
          this.size = this.left.size + 1 + this.right.size;
        }
        LLRBNode.prototype.copy = function(key, value, color, left, right) {
          return new LLRBNode(null != key ? key : this.key, null != value ? value : this.value, null != color ? color : this.color, null != left ? left : this.left, null != right ? right : this.right);
        };
        LLRBNode.prototype.isEmpty = function() {
          return false;
        };
        LLRBNode.prototype.inorderTraversal = function(action) {
          return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
        };
        LLRBNode.prototype.reverseTraversal = function(action) {
          return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
        };
        LLRBNode.prototype.min = function() {
          return this.left.isEmpty() ? this : this.left.min();
        };
        LLRBNode.prototype.minKey = function() {
          return this.min().key;
        };
        LLRBNode.prototype.maxKey = function() {
          return this.right.isEmpty() ? this.key : this.right.maxKey();
        };
        LLRBNode.prototype.insert = function(key, value, comparator) {
          var n = this;
          var cmp = comparator(key, n.key);
          n = cmp < 0 ? n.copy(null, null, null, n.left.insert(key, value, comparator), null) : 0 === cmp ? n.copy(null, value, null, null, null) : n.copy(null, null, null, null, n.right.insert(key, value, comparator));
          return n.fixUp();
        };
        LLRBNode.prototype.removeMin = function() {
          if (this.left.isEmpty()) return LLRBNode.EMPTY;
          var n = this;
          n.left.isRed() || n.left.left.isRed() || (n = n.moveRedLeft());
          n = n.copy(null, null, null, n.left.removeMin(), null);
          return n.fixUp();
        };
        LLRBNode.prototype.remove = function(key, comparator) {
          var smallest;
          var n = this;
          if (comparator(key, n.key) < 0) {
            n.left.isEmpty() || n.left.isRed() || n.left.left.isRed() || (n = n.moveRedLeft());
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
          } else {
            n.left.isRed() && (n = n.rotateRight());
            n.right.isEmpty() || n.right.isRed() || n.right.left.isRed() || (n = n.moveRedRight());
            if (0 === comparator(key, n.key)) {
              if (n.right.isEmpty()) return LLRBNode.EMPTY;
              smallest = n.right.min();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
          }
          return n.fixUp();
        };
        LLRBNode.prototype.isRed = function() {
          return this.color;
        };
        LLRBNode.prototype.fixUp = function() {
          var n = this;
          n.right.isRed() && !n.left.isRed() && (n = n.rotateLeft());
          n.left.isRed() && n.left.left.isRed() && (n = n.rotateRight());
          n.left.isRed() && n.right.isRed() && (n = n.colorFlip());
          return n;
        };
        LLRBNode.prototype.moveRedLeft = function() {
          var n = this.colorFlip();
          if (n.right.left.isRed()) {
            n = n.copy(null, null, null, null, n.right.rotateRight());
            n = n.rotateLeft();
            n = n.colorFlip();
          }
          return n;
        };
        LLRBNode.prototype.moveRedRight = function() {
          var n = this.colorFlip();
          if (n.left.left.isRed()) {
            n = n.rotateRight();
            n = n.colorFlip();
          }
          return n;
        };
        LLRBNode.prototype.rotateLeft = function() {
          var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
          return this.right.copy(null, null, this.color, nl, null);
        };
        LLRBNode.prototype.rotateRight = function() {
          var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
          return this.left.copy(null, null, this.color, null, nr);
        };
        LLRBNode.prototype.colorFlip = function() {
          var left = this.left.copy(null, null, !this.left.color, null, null);
          var right = this.right.copy(null, null, !this.right.color, null, null);
          return this.copy(null, null, !this.color, left, right);
        };
        LLRBNode.prototype.checkMaxDepth = function() {
          var blackDepth = this.check();
          return Math.pow(2, blackDepth) <= this.size + 1;
        };
        LLRBNode.prototype.check = function() {
          if (this.isRed() && this.left.isRed()) throw fail("Red node has red child(" + this.key + "," + this.value + ")");
          if (this.right.isRed()) throw fail("Right child of (" + this.key + "," + this.value + ") is red");
          var blackDepth = this.left.check();
          if (blackDepth !== this.right.check()) throw fail("Black depths differ");
          return blackDepth + (this.isRed() ? 0 : 1);
        };
        LLRBNode.EMPTY = null;
        LLRBNode.RED = true;
        LLRBNode.BLACK = false;
        return LLRBNode;
      }();
      var LLRBEmptyNode = function() {
        function LLRBEmptyNode() {
          this.size = 0;
        }
        LLRBEmptyNode.prototype.copy = function(key, value, color, left, right) {
          return this;
        };
        LLRBEmptyNode.prototype.insert = function(key, value, comparator) {
          return new LLRBNode(key, value);
        };
        LLRBEmptyNode.prototype.remove = function(key, comparator) {
          return this;
        };
        LLRBEmptyNode.prototype.isEmpty = function() {
          return true;
        };
        LLRBEmptyNode.prototype.inorderTraversal = function(action) {
          return false;
        };
        LLRBEmptyNode.prototype.reverseTraversal = function(action) {
          return false;
        };
        LLRBEmptyNode.prototype.minKey = function() {
          return null;
        };
        LLRBEmptyNode.prototype.maxKey = function() {
          return null;
        };
        LLRBEmptyNode.prototype.isRed = function() {
          return false;
        };
        LLRBEmptyNode.prototype.checkMaxDepth = function() {
          return true;
        };
        LLRBEmptyNode.prototype.check = function() {
          return 0;
        };
        return LLRBEmptyNode;
      }();
      LLRBNode.EMPTY = new LLRBEmptyNode();
      var TypeOrder;
      (function(TypeOrder) {
        TypeOrder[TypeOrder["NullValue"] = 0] = "NullValue";
        TypeOrder[TypeOrder["BooleanValue"] = 1] = "BooleanValue";
        TypeOrder[TypeOrder["NumberValue"] = 2] = "NumberValue";
        TypeOrder[TypeOrder["TimestampValue"] = 3] = "TimestampValue";
        TypeOrder[TypeOrder["StringValue"] = 4] = "StringValue";
        TypeOrder[TypeOrder["BlobValue"] = 5] = "BlobValue";
        TypeOrder[TypeOrder["RefValue"] = 6] = "RefValue";
        TypeOrder[TypeOrder["GeoPointValue"] = 7] = "GeoPointValue";
        TypeOrder[TypeOrder["ArrayValue"] = 8] = "ArrayValue";
        TypeOrder[TypeOrder["ObjectValue"] = 9] = "ObjectValue";
      })(TypeOrder || (TypeOrder = {}));
      var ServerTimestampBehavior;
      (function(ServerTimestampBehavior) {
        ServerTimestampBehavior[ServerTimestampBehavior["Default"] = 0] = "Default";
        ServerTimestampBehavior[ServerTimestampBehavior["Estimate"] = 1] = "Estimate";
        ServerTimestampBehavior[ServerTimestampBehavior["Previous"] = 2] = "Previous";
      })(ServerTimestampBehavior || (ServerTimestampBehavior = {}));
      var FieldValueOptions = function() {
        function FieldValueOptions(serverTimestampBehavior, timestampsInSnapshots) {
          this.serverTimestampBehavior = serverTimestampBehavior;
          this.timestampsInSnapshots = timestampsInSnapshots;
        }
        FieldValueOptions.fromSnapshotOptions = function(options, timestampsInSnapshots) {
          switch (options.serverTimestamps) {
           case "estimate":
            return new FieldValueOptions(ServerTimestampBehavior.Estimate, timestampsInSnapshots);

           case "previous":
            return new FieldValueOptions(ServerTimestampBehavior.Previous, timestampsInSnapshots);

           case "none":
           case void 0:
            return new FieldValueOptions(ServerTimestampBehavior.Default, timestampsInSnapshots);

           default:
            return fail("fromSnapshotOptions() called with invalid options.");
          }
        };
        return FieldValueOptions;
      }();
      var FieldValue = function() {
        function FieldValue() {}
        FieldValue.prototype.toString = function() {
          var val = this.value();
          return null === val ? "null" : val.toString();
        };
        FieldValue.prototype.defaultCompareTo = function(other) {
          assert(this.typeOrder !== other.typeOrder, "Default compareTo should not be used for values of same type.");
          var cmp = primitiveComparator(this.typeOrder, other.typeOrder);
          return cmp;
        };
        return FieldValue;
      }();
      var NullValue = function(_super) {
        tslib_1.__extends(NullValue, _super);
        function NullValue() {
          var _this = _super.call(this) || this;
          _this.typeOrder = TypeOrder.NullValue;
          _this.internalValue = null;
          return _this;
        }
        NullValue.prototype.value = function(options) {
          return null;
        };
        NullValue.prototype.isEqual = function(other) {
          return other instanceof NullValue;
        };
        NullValue.prototype.compareTo = function(other) {
          if (other instanceof NullValue) return 0;
          return this.defaultCompareTo(other);
        };
        NullValue.INSTANCE = new NullValue();
        return NullValue;
      }(FieldValue);
      var BooleanValue = function(_super) {
        tslib_1.__extends(BooleanValue, _super);
        function BooleanValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.BooleanValue;
          return _this;
        }
        BooleanValue.prototype.value = function(options) {
          return this.internalValue;
        };
        BooleanValue.prototype.isEqual = function(other) {
          return other instanceof BooleanValue && this.internalValue === other.internalValue;
        };
        BooleanValue.prototype.compareTo = function(other) {
          if (other instanceof BooleanValue) return primitiveComparator(this, other);
          return this.defaultCompareTo(other);
        };
        BooleanValue.of = function(value) {
          return value ? BooleanValue.TRUE : BooleanValue.FALSE;
        };
        BooleanValue.TRUE = new BooleanValue(true);
        BooleanValue.FALSE = new BooleanValue(false);
        return BooleanValue;
      }(FieldValue);
      var NumberValue = function(_super) {
        tslib_1.__extends(NumberValue, _super);
        function NumberValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.NumberValue;
          return _this;
        }
        NumberValue.prototype.value = function(options) {
          return this.internalValue;
        };
        NumberValue.prototype.compareTo = function(other) {
          if (other instanceof NumberValue) return numericComparator(this.internalValue, other.internalValue);
          return this.defaultCompareTo(other);
        };
        return NumberValue;
      }(FieldValue);
      function numericComparator(left, right) {
        return left < right ? -1 : left > right ? 1 : left === right ? 0 : isNaN(left) ? isNaN(right) ? 0 : -1 : 1;
      }
      function numericEquals(left, right) {
        return left === right ? 0 !== left || 1 / left === 1 / right : left !== left && right !== right;
      }
      var IntegerValue = function(_super) {
        tslib_1.__extends(IntegerValue, _super);
        function IntegerValue(internalValue) {
          return _super.call(this, internalValue) || this;
        }
        IntegerValue.prototype.isEqual = function(other) {
          return other instanceof IntegerValue && numericEquals(this.internalValue, other.internalValue);
        };
        return IntegerValue;
      }(NumberValue);
      var DoubleValue = function(_super) {
        tslib_1.__extends(DoubleValue, _super);
        function DoubleValue(internalValue) {
          var _this = _super.call(this, internalValue) || this;
          _this.internalValue = internalValue;
          return _this;
        }
        DoubleValue.prototype.isEqual = function(other) {
          return other instanceof DoubleValue && numericEquals(this.internalValue, other.internalValue);
        };
        DoubleValue.NAN = new DoubleValue(NaN);
        DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);
        DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);
        return DoubleValue;
      }(NumberValue);
      var StringValue = function(_super) {
        tslib_1.__extends(StringValue, _super);
        function StringValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.StringValue;
          return _this;
        }
        StringValue.prototype.value = function(options) {
          return this.internalValue;
        };
        StringValue.prototype.isEqual = function(other) {
          return other instanceof StringValue && this.internalValue === other.internalValue;
        };
        StringValue.prototype.compareTo = function(other) {
          if (other instanceof StringValue) return primitiveComparator(this.internalValue, other.internalValue);
          return this.defaultCompareTo(other);
        };
        return StringValue;
      }(FieldValue);
      var TimestampValue = function(_super) {
        tslib_1.__extends(TimestampValue, _super);
        function TimestampValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.TimestampValue;
          return _this;
        }
        TimestampValue.prototype.value = function(options) {
          return options && options.timestampsInSnapshots ? this.internalValue : this.internalValue.toDate();
        };
        TimestampValue.prototype.isEqual = function(other) {
          return other instanceof TimestampValue && this.internalValue.isEqual(other.internalValue);
        };
        TimestampValue.prototype.compareTo = function(other) {
          return other instanceof TimestampValue ? this.internalValue._compareTo(other.internalValue) : other instanceof ServerTimestampValue ? -1 : this.defaultCompareTo(other);
        };
        return TimestampValue;
      }(FieldValue);
      var ServerTimestampValue = function(_super) {
        tslib_1.__extends(ServerTimestampValue, _super);
        function ServerTimestampValue(localWriteTime, previousValue) {
          var _this = _super.call(this) || this;
          _this.localWriteTime = localWriteTime;
          _this.previousValue = previousValue;
          _this.typeOrder = TypeOrder.TimestampValue;
          return _this;
        }
        ServerTimestampValue.prototype.value = function(options) {
          return options && options.serverTimestampBehavior === ServerTimestampBehavior.Estimate ? new TimestampValue(this.localWriteTime).value(options) : options && options.serverTimestampBehavior === ServerTimestampBehavior.Previous && this.previousValue ? this.previousValue.value(options) : null;
        };
        ServerTimestampValue.prototype.isEqual = function(other) {
          return other instanceof ServerTimestampValue && this.localWriteTime.isEqual(other.localWriteTime);
        };
        ServerTimestampValue.prototype.compareTo = function(other) {
          return other instanceof ServerTimestampValue ? this.localWriteTime._compareTo(other.localWriteTime) : other instanceof TimestampValue ? 1 : this.defaultCompareTo(other);
        };
        ServerTimestampValue.prototype.toString = function() {
          return "<ServerTimestamp localTime=" + this.localWriteTime.toString() + ">";
        };
        return ServerTimestampValue;
      }(FieldValue);
      var BlobValue = function(_super) {
        tslib_1.__extends(BlobValue, _super);
        function BlobValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.BlobValue;
          return _this;
        }
        BlobValue.prototype.value = function(options) {
          return this.internalValue;
        };
        BlobValue.prototype.isEqual = function(other) {
          return other instanceof BlobValue && this.internalValue.isEqual(other.internalValue);
        };
        BlobValue.prototype.compareTo = function(other) {
          if (other instanceof BlobValue) return this.internalValue._compareTo(other.internalValue);
          return this.defaultCompareTo(other);
        };
        return BlobValue;
      }(FieldValue);
      var RefValue = function(_super) {
        tslib_1.__extends(RefValue, _super);
        function RefValue(databaseId, key) {
          var _this = _super.call(this) || this;
          _this.databaseId = databaseId;
          _this.key = key;
          _this.typeOrder = TypeOrder.RefValue;
          return _this;
        }
        RefValue.prototype.value = function(options) {
          return this.key;
        };
        RefValue.prototype.isEqual = function(other) {
          return other instanceof RefValue && (this.key.isEqual(other.key) && this.databaseId.isEqual(other.databaseId));
        };
        RefValue.prototype.compareTo = function(other) {
          if (other instanceof RefValue) {
            var cmp = this.databaseId.compareTo(other.databaseId);
            return 0 !== cmp ? cmp : DocumentKey.comparator(this.key, other.key);
          }
          return this.defaultCompareTo(other);
        };
        return RefValue;
      }(FieldValue);
      var GeoPointValue = function(_super) {
        tslib_1.__extends(GeoPointValue, _super);
        function GeoPointValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.GeoPointValue;
          return _this;
        }
        GeoPointValue.prototype.value = function(options) {
          return this.internalValue;
        };
        GeoPointValue.prototype.isEqual = function(other) {
          return other instanceof GeoPointValue && this.internalValue.isEqual(other.internalValue);
        };
        GeoPointValue.prototype.compareTo = function(other) {
          if (other instanceof GeoPointValue) return this.internalValue._compareTo(other.internalValue);
          return this.defaultCompareTo(other);
        };
        return GeoPointValue;
      }(FieldValue);
      var ObjectValue = function(_super) {
        tslib_1.__extends(ObjectValue, _super);
        function ObjectValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.ObjectValue;
          return _this;
        }
        ObjectValue.prototype.value = function(options) {
          var result = {};
          this.internalValue.inorderTraversal(function(key, val) {
            result[key] = val.value(options);
          });
          return result;
        };
        ObjectValue.prototype.forEach = function(action) {
          this.internalValue.inorderTraversal(action);
        };
        ObjectValue.prototype.isEqual = function(other) {
          if (other instanceof ObjectValue) {
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) {
              var next1 = it1.getNext();
              var next2 = it2.getNext();
              if (next1.key !== next2.key || !next1.value.isEqual(next2.value)) return false;
            }
            return !it1.hasNext() && !it2.hasNext();
          }
          return false;
        };
        ObjectValue.prototype.compareTo = function(other) {
          if (other instanceof ObjectValue) {
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) {
              var next1 = it1.getNext();
              var next2 = it2.getNext();
              var cmp = primitiveComparator(next1.key, next2.key) || next1.value.compareTo(next2.value);
              if (cmp) return cmp;
            }
            return primitiveComparator(it1.hasNext(), it2.hasNext());
          }
          return this.defaultCompareTo(other);
        };
        ObjectValue.prototype.set = function(path, to) {
          assert(!path.isEmpty(), "Cannot set field for empty path on ObjectValue");
          if (1 === path.length) return this.setChild(path.firstSegment(), to);
          var child = this.child(path.firstSegment());
          child instanceof ObjectValue || (child = ObjectValue.EMPTY);
          var newChild = child.set(path.popFirst(), to);
          return this.setChild(path.firstSegment(), newChild);
        };
        ObjectValue.prototype.delete = function(path) {
          assert(!path.isEmpty(), "Cannot delete field for empty path on ObjectValue");
          if (1 === path.length) return new ObjectValue(this.internalValue.remove(path.firstSegment()));
          var child = this.child(path.firstSegment());
          if (child instanceof ObjectValue) {
            var newChild = child.delete(path.popFirst());
            return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));
          }
          return this;
        };
        ObjectValue.prototype.contains = function(path) {
          return void 0 !== this.field(path);
        };
        ObjectValue.prototype.field = function(path) {
          assert(!path.isEmpty(), "Can't get field of empty path");
          var field = this;
          path.forEach(function(pathSegment) {
            field = field instanceof ObjectValue && field.internalValue.get(pathSegment) || void 0;
          });
          return field;
        };
        ObjectValue.prototype.toString = function() {
          return JSON.stringify(this.value());
        };
        ObjectValue.prototype.child = function(childName) {
          return this.internalValue.get(childName) || void 0;
        };
        ObjectValue.prototype.setChild = function(childName, value) {
          return new ObjectValue(this.internalValue.insert(childName, value));
        };
        ObjectValue.EMPTY = new ObjectValue(new SortedMap(primitiveComparator));
        return ObjectValue;
      }(FieldValue);
      var ArrayValue = function(_super) {
        tslib_1.__extends(ArrayValue, _super);
        function ArrayValue(internalValue) {
          var _this = _super.call(this) || this;
          _this.internalValue = internalValue;
          _this.typeOrder = TypeOrder.ArrayValue;
          return _this;
        }
        ArrayValue.prototype.value = function(options) {
          return this.internalValue.map(function(v) {
            return v.value(options);
          });
        };
        ArrayValue.prototype.forEach = function(action) {
          this.internalValue.forEach(action);
        };
        ArrayValue.prototype.isEqual = function(other) {
          if (other instanceof ArrayValue) {
            if (this.internalValue.length !== other.internalValue.length) return false;
            for (var i = 0; i < this.internalValue.length; i++) if (!this.internalValue[i].isEqual(other.internalValue[i])) return false;
            return true;
          }
          return false;
        };
        ArrayValue.prototype.compareTo = function(other) {
          if (other instanceof ArrayValue) {
            var minLength = Math.min(this.internalValue.length, other.internalValue.length);
            for (var i = 0; i < minLength; i++) {
              var cmp = this.internalValue[i].compareTo(other.internalValue[i]);
              if (cmp) return cmp;
            }
            return primitiveComparator(this.internalValue.length, other.internalValue.length);
          }
          return this.defaultCompareTo(other);
        };
        ArrayValue.prototype.toString = function() {
          return JSON.stringify(this.value());
        };
        return ArrayValue;
      }(FieldValue);
      var NumberAsAny = Number;
      var MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);
      var MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
      var isInteger = NumberAsAny.isInteger || function(value) {
        return "number" === typeof value && isFinite(value) && Math.floor(value) === value;
      };
      function isNullOrUndefined(value) {
        return null === value || void 0 === value;
      }
      function isSafeInteger(value) {
        return isInteger(value) && value <= MAX_SAFE_INTEGER && value >= MIN_SAFE_INTEGER;
      }
      var Query = function() {
        function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {
          void 0 === explicitOrderBy && (explicitOrderBy = []);
          void 0 === filters && (filters = []);
          void 0 === limit && (limit = null);
          void 0 === startAt && (startAt = null);
          void 0 === endAt && (endAt = null);
          this.path = path;
          this.explicitOrderBy = explicitOrderBy;
          this.filters = filters;
          this.limit = limit;
          this.startAt = startAt;
          this.endAt = endAt;
          this.memoizedCanonicalId = null;
          this.memoizedOrderBy = null;
          this.startAt && this.assertValidBound(this.startAt);
          this.endAt && this.assertValidBound(this.endAt);
        }
        Query.atPath = function(path) {
          return new Query(path);
        };
        Object.defineProperty(Query.prototype, "orderBy", {
          get: function() {
            if (null === this.memoizedOrderBy) {
              var inequalityField = this.getInequalityFilterField();
              var firstOrderByField = this.getFirstOrderByField();
              if (null !== inequalityField && null === firstOrderByField) inequalityField.isKeyField() ? this.memoizedOrderBy = [ KEY_ORDERING_ASC ] : this.memoizedOrderBy = [ new OrderBy(inequalityField), KEY_ORDERING_ASC ]; else {
                assert(null === inequalityField || null !== firstOrderByField && inequalityField.isEqual(firstOrderByField), "First orderBy should match inequality field.");
                this.memoizedOrderBy = [];
                var foundKeyOrdering = false;
                for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
                  var orderBy = _a[_i];
                  this.memoizedOrderBy.push(orderBy);
                  orderBy.field.isKeyField() && (foundKeyOrdering = true);
                }
                if (!foundKeyOrdering) {
                  var lastDirection = this.explicitOrderBy.length > 0 ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Direction.ASCENDING;
                  this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING ? KEY_ORDERING_ASC : KEY_ORDERING_DESC);
                }
              }
            }
            return this.memoizedOrderBy;
          },
          enumerable: true,
          configurable: true
        });
        Query.prototype.addFilter = function(filter) {
          assert(null == this.getInequalityFilterField() || !(filter instanceof RelationFilter) || !filter.isInequality() || filter.field.isEqual(this.getInequalityFilterField()), "Query must only have one inequality field.");
          assert(!DocumentKey.isDocumentKey(this.path), "No filtering allowed for document query");
          var newFilters = this.filters.concat([ filter ]);
          return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);
        };
        Query.prototype.addOrderBy = function(orderBy) {
          assert(!DocumentKey.isDocumentKey(this.path), "No ordering allowed for document query");
          assert(!this.startAt && !this.endAt, "Bounds must be set after orderBy");
          var newOrderBy = this.explicitOrderBy.concat([ orderBy ]);
          return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);
        };
        Query.prototype.withLimit = function(limit) {
          return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);
        };
        Query.prototype.withStartAt = function(bound) {
          return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);
        };
        Query.prototype.withEndAt = function(bound) {
          return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);
        };
        Query.prototype.canonicalId = function() {
          if (null === this.memoizedCanonicalId) {
            var canonicalId = this.path.canonicalString();
            canonicalId += "|f:";
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
              var filter = _a[_i];
              canonicalId += filter.canonicalId();
              canonicalId += ",";
            }
            canonicalId += "|ob:";
            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {
              var orderBy = _c[_b];
              canonicalId += orderBy.canonicalId();
              canonicalId += ",";
            }
            if (!isNullOrUndefined(this.limit)) {
              canonicalId += "|l:";
              canonicalId += this.limit;
            }
            if (this.startAt) {
              canonicalId += "|lb:";
              canonicalId += this.startAt.canonicalId();
            }
            if (this.endAt) {
              canonicalId += "|ub:";
              canonicalId += this.endAt.canonicalId();
            }
            this.memoizedCanonicalId = canonicalId;
          }
          return this.memoizedCanonicalId;
        };
        Query.prototype.toString = function() {
          var str = "Query(" + this.path.canonicalString();
          this.filters.length > 0 && (str += ", filters: [" + this.filters.join(", ") + "]");
          isNullOrUndefined(this.limit) || (str += ", limit: " + this.limit);
          this.explicitOrderBy.length > 0 && (str += ", orderBy: [" + this.explicitOrderBy.join(", ") + "]");
          this.startAt && (str += ", startAt: " + this.startAt.canonicalId());
          this.endAt && (str += ", endAt: " + this.endAt.canonicalId());
          return str + ")";
        };
        Query.prototype.isEqual = function(other) {
          if (this.limit !== other.limit) return false;
          if (this.orderBy.length !== other.orderBy.length) return false;
          for (var i = 0; i < this.orderBy.length; i++) if (!this.orderBy[i].isEqual(other.orderBy[i])) return false;
          if (this.filters.length !== other.filters.length) return false;
          for (var i = 0; i < this.filters.length; i++) if (!this.filters[i].isEqual(other.filters[i])) return false;
          if (!this.path.isEqual(other.path)) return false;
          if (null !== this.startAt ? !this.startAt.isEqual(other.startAt) : null !== other.startAt) return false;
          return null !== this.endAt ? this.endAt.isEqual(other.endAt) : null === other.endAt;
        };
        Query.prototype.docComparator = function(d1, d2) {
          var comparedOnKeyField = false;
          for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            var comp = orderBy.compare(d1, d2);
            if (0 !== comp) return comp;
            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();
          }
          assert(comparedOnKeyField, "orderBy used that doesn't compare on key field");
          return 0;
        };
        Query.prototype.matches = function(doc) {
          return this.matchesAncestor(doc) && this.matchesOrderBy(doc) && this.matchesFilters(doc) && this.matchesBounds(doc);
        };
        Query.prototype.hasLimit = function() {
          return !isNullOrUndefined(this.limit);
        };
        Query.prototype.getFirstOrderByField = function() {
          return this.explicitOrderBy.length > 0 ? this.explicitOrderBy[0].field : null;
        };
        Query.prototype.getInequalityFilterField = function() {
          for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
            var filter = _a[_i];
            if (filter instanceof RelationFilter && filter.isInequality()) return filter.field;
          }
          return null;
        };
        Query.prototype.hasArrayContainsFilter = function() {
          return void 0 !== this.filters.find(function(filter) {
            return filter instanceof RelationFilter && filter.op === RelationOp.ARRAY_CONTAINS;
          });
        };
        Query.prototype.isDocumentQuery = function() {
          return DocumentKey.isDocumentKey(this.path) && 0 === this.filters.length;
        };
        Query.prototype.matchesAncestor = function(doc) {
          var docPath = doc.key.path;
          return DocumentKey.isDocumentKey(this.path) ? this.path.isEqual(docPath) : this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1;
        };
        Query.prototype.matchesOrderBy = function(doc) {
          for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            if (!orderBy.field.isKeyField() && void 0 === doc.field(orderBy.field)) return false;
          }
          return true;
        };
        Query.prototype.matchesFilters = function(doc) {
          for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
            var filter = _a[_i];
            if (!filter.matches(doc)) return false;
          }
          return true;
        };
        Query.prototype.matchesBounds = function(doc) {
          if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) return false;
          if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) return false;
          return true;
        };
        Query.prototype.assertValidBound = function(bound) {
          assert(bound.position.length <= this.orderBy.length, "Bound is longer than orderBy");
        };
        return Query;
      }();
      var Filter = function() {
        function Filter() {}
        Filter.create = function(field, op, value) {
          if (value.isEqual(NullValue.INSTANCE)) {
            if (op !== RelationOp.EQUAL) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You can only perform equals comparisons on null.");
            return new NullFilter(field);
          }
          if (value.isEqual(DoubleValue.NAN)) {
            if (op !== RelationOp.EQUAL) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You can only perform equals comparisons on NaN.");
            return new NanFilter(field);
          }
          return new RelationFilter(field, op, value);
        };
        return Filter;
      }();
      var RelationOp = function() {
        function RelationOp(name) {
          this.name = name;
        }
        RelationOp.fromString = function(op) {
          switch (op) {
           case "<":
            return RelationOp.LESS_THAN;

           case "<=":
            return RelationOp.LESS_THAN_OR_EQUAL;

           case "==":
            return RelationOp.EQUAL;

           case ">=":
            return RelationOp.GREATER_THAN_OR_EQUAL;

           case ">":
            return RelationOp.GREATER_THAN;

           case "array-contains":
            return RelationOp.ARRAY_CONTAINS;

           default:
            return fail("Unknown relation: " + op);
          }
        };
        RelationOp.prototype.toString = function() {
          return this.name;
        };
        RelationOp.prototype.isEqual = function(other) {
          return this.name === other.name;
        };
        RelationOp.LESS_THAN = new RelationOp("<");
        RelationOp.LESS_THAN_OR_EQUAL = new RelationOp("<=");
        RelationOp.EQUAL = new RelationOp("==");
        RelationOp.GREATER_THAN = new RelationOp(">");
        RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp(">=");
        RelationOp.ARRAY_CONTAINS = new RelationOp("array-contains");
        return RelationOp;
      }();
      var RelationFilter = function(_super) {
        tslib_1.__extends(RelationFilter, _super);
        function RelationFilter(field, op, value) {
          var _this = _super.call(this) || this;
          _this.field = field;
          _this.op = op;
          _this.value = value;
          return _this;
        }
        RelationFilter.prototype.matches = function(doc) {
          if (this.field.isKeyField()) {
            assert(this.value instanceof RefValue, "Comparing on key, but filter value not a RefValue");
            assert(this.op !== RelationOp.ARRAY_CONTAINS, "array-contains queries don't make sense on document keys.");
            var refValue = this.value;
            var comparison = DocumentKey.comparator(doc.key, refValue.key);
            return this.matchesComparison(comparison);
          }
          var val = doc.field(this.field);
          return void 0 !== val && this.matchesValue(val);
        };
        RelationFilter.prototype.matchesValue = function(value) {
          var _this = this;
          return this.op === RelationOp.ARRAY_CONTAINS ? value instanceof ArrayValue && void 0 !== value.internalValue.find(function(element) {
            return element.isEqual(_this.value);
          }) : this.value.typeOrder === value.typeOrder && this.matchesComparison(value.compareTo(this.value));
        };
        RelationFilter.prototype.matchesComparison = function(comparison) {
          switch (this.op) {
           case RelationOp.LESS_THAN:
            return comparison < 0;

           case RelationOp.LESS_THAN_OR_EQUAL:
            return comparison <= 0;

           case RelationOp.EQUAL:
            return 0 === comparison;

           case RelationOp.GREATER_THAN:
            return comparison > 0;

           case RelationOp.GREATER_THAN_OR_EQUAL:
            return comparison >= 0;

           default:
            return fail("Unknown relation op" + this.op);
          }
        };
        RelationFilter.prototype.isInequality = function() {
          return this.op !== RelationOp.EQUAL && this.op !== RelationOp.ARRAY_CONTAINS;
        };
        RelationFilter.prototype.canonicalId = function() {
          return this.field.canonicalString() + this.op.toString() + this.value.toString();
        };
        RelationFilter.prototype.isEqual = function(other) {
          return other instanceof RelationFilter && (this.op.isEqual(other.op) && this.field.isEqual(other.field) && this.value.isEqual(other.value));
        };
        RelationFilter.prototype.toString = function() {
          return this.field.canonicalString() + " " + this.op + " " + this.value.value();
        };
        return RelationFilter;
      }(Filter);
      var NullFilter = function(_super) {
        tslib_1.__extends(NullFilter, _super);
        function NullFilter(field) {
          var _this = _super.call(this) || this;
          _this.field = field;
          return _this;
        }
        NullFilter.prototype.matches = function(doc) {
          var val = doc.field(this.field);
          return void 0 !== val && null === val.value();
        };
        NullFilter.prototype.canonicalId = function() {
          return this.field.canonicalString() + " IS null";
        };
        NullFilter.prototype.toString = function() {
          return this.field.canonicalString() + " IS null";
        };
        NullFilter.prototype.isEqual = function(other) {
          return other instanceof NullFilter && this.field.isEqual(other.field);
        };
        return NullFilter;
      }(Filter);
      var NanFilter = function(_super) {
        tslib_1.__extends(NanFilter, _super);
        function NanFilter(field) {
          var _this = _super.call(this) || this;
          _this.field = field;
          return _this;
        }
        NanFilter.prototype.matches = function(doc) {
          var val = doc.field(this.field).value();
          return "number" === typeof val && isNaN(val);
        };
        NanFilter.prototype.canonicalId = function() {
          return this.field.canonicalString() + " IS NaN";
        };
        NanFilter.prototype.toString = function() {
          return this.field.canonicalString() + " IS NaN";
        };
        NanFilter.prototype.isEqual = function(other) {
          return other instanceof NanFilter && this.field.isEqual(other.field);
        };
        return NanFilter;
      }(Filter);
      var Direction = function() {
        function Direction(name) {
          this.name = name;
        }
        Direction.prototype.toString = function() {
          return this.name;
        };
        Direction.ASCENDING = new Direction("asc");
        Direction.DESCENDING = new Direction("desc");
        return Direction;
      }();
      var Bound = function() {
        function Bound(position, before) {
          this.position = position;
          this.before = before;
        }
        Bound.prototype.canonicalId = function() {
          var canonicalId = this.before ? "b:" : "a:";
          for (var _i = 0, _a = this.position; _i < _a.length; _i++) {
            var component = _a[_i];
            canonicalId += component.toString();
          }
          return canonicalId;
        };
        Bound.prototype.sortsBeforeDocument = function(orderBy, doc) {
          assert(this.position.length <= orderBy.length, "Bound has more components than query's orderBy");
          var comparison = 0;
          for (var i = 0; i < this.position.length; i++) {
            var orderByComponent = orderBy[i];
            var component = this.position[i];
            if (orderByComponent.field.isKeyField()) {
              assert(component instanceof RefValue, "Bound has a non-key value where the key path is being used.");
              comparison = DocumentKey.comparator(component.key, doc.key);
            } else {
              var docValue = doc.field(orderByComponent.field);
              assert(void 0 !== docValue, "Field should exist since document matched the orderBy already.");
              comparison = component.compareTo(docValue);
            }
            orderByComponent.dir === Direction.DESCENDING && (comparison *= -1);
            if (0 !== comparison) break;
          }
          return this.before ? comparison <= 0 : comparison < 0;
        };
        Bound.prototype.isEqual = function(other) {
          if (null === other) return false;
          if (this.before !== other.before || this.position.length !== other.position.length) return false;
          for (var i = 0; i < this.position.length; i++) {
            var thisPosition = this.position[i];
            var otherPosition = other.position[i];
            return thisPosition.isEqual(otherPosition);
          }
          return true;
        };
        return Bound;
      }();
      var OrderBy = function() {
        function OrderBy(field, dir) {
          this.field = field;
          void 0 === dir && (dir = Direction.ASCENDING);
          this.dir = dir;
          this.isKeyOrderBy = field.isKeyField();
        }
        OrderBy.prototype.compare = function(d1, d2) {
          var comparison = this.isKeyOrderBy ? Document.compareByKey(d1, d2) : Document.compareByField(this.field, d1, d2);
          switch (this.dir) {
           case Direction.ASCENDING:
            return comparison;

           case Direction.DESCENDING:
            return -1 * comparison;

           default:
            return fail("Unknown direction: " + this.dir);
          }
        };
        OrderBy.prototype.canonicalId = function() {
          return this.field.canonicalString() + this.dir.toString();
        };
        OrderBy.prototype.toString = function() {
          return this.field.canonicalString() + " (" + this.dir + ")";
        };
        OrderBy.prototype.isEqual = function(other) {
          return this.dir === other.dir && this.field.isEqual(other.field);
        };
        return OrderBy;
      }();
      var KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);
      var KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);
      var SnapshotVersion = function() {
        function SnapshotVersion(timestamp) {
          this.timestamp = timestamp;
        }
        SnapshotVersion.fromMicroseconds = function(value) {
          var seconds = Math.floor(value / 1e6);
          var nanos = value % 1e6 * 1e3;
          return new SnapshotVersion(new Timestamp(seconds, nanos));
        };
        SnapshotVersion.fromTimestamp = function(value) {
          return new SnapshotVersion(value);
        };
        SnapshotVersion.forDeletedDoc = function() {
          return SnapshotVersion.MIN;
        };
        SnapshotVersion.prototype.compareTo = function(other) {
          return this.timestamp._compareTo(other.timestamp);
        };
        SnapshotVersion.prototype.isEqual = function(other) {
          return this.timestamp.isEqual(other.timestamp);
        };
        SnapshotVersion.prototype.toMicroseconds = function() {
          return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
        };
        SnapshotVersion.prototype.toString = function() {
          return "SnapshotVersion(" + this.timestamp.toString() + ")";
        };
        SnapshotVersion.prototype.toTimestamp = function() {
          return this.timestamp;
        };
        SnapshotVersion.MIN = new SnapshotVersion(new Timestamp(0, 0));
        return SnapshotVersion;
      }();
      var QueryPurpose;
      (function(QueryPurpose) {
        QueryPurpose[QueryPurpose["Listen"] = 0] = "Listen";
        QueryPurpose[QueryPurpose["ExistenceFilterMismatch"] = 1] = "ExistenceFilterMismatch";
        QueryPurpose[QueryPurpose["LimboResolution"] = 2] = "LimboResolution";
      })(QueryPurpose || (QueryPurpose = {}));
      var QueryData = function() {
        function QueryData(query, targetId, purpose, snapshotVersion, resumeToken) {
          void 0 === snapshotVersion && (snapshotVersion = SnapshotVersion.MIN);
          void 0 === resumeToken && (resumeToken = emptyByteString());
          this.query = query;
          this.targetId = targetId;
          this.purpose = purpose;
          this.snapshotVersion = snapshotVersion;
          this.resumeToken = resumeToken;
        }
        QueryData.prototype.copy = function(overwrite) {
          return new QueryData(this.query, this.targetId, this.purpose, void 0 === overwrite.snapshotVersion ? this.snapshotVersion : overwrite.snapshotVersion, void 0 === overwrite.resumeToken ? this.resumeToken : overwrite.resumeToken);
        };
        QueryData.prototype.isEqual = function(other) {
          return this.targetId === other.targetId && this.purpose === other.purpose && this.snapshotVersion.isEqual(other.snapshotVersion) && this.resumeToken === other.resumeToken && this.query.isEqual(other.query);
        };
        return QueryData;
      }();
      var FieldMask = function() {
        function FieldMask(fields) {
          this.fields = fields;
        }
        FieldMask.prototype.covers = function(fieldPath) {
          for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
            var fieldMaskPath = _a[_i];
            if (fieldMaskPath.isPrefixOf(fieldPath)) return true;
          }
          return false;
        };
        FieldMask.prototype.isEqual = function(other) {
          return arrayEquals(this.fields, other.fields);
        };
        return FieldMask;
      }();
      var FieldTransform = function() {
        function FieldTransform(field, transform) {
          this.field = field;
          this.transform = transform;
        }
        FieldTransform.prototype.isEqual = function(other) {
          return this.field.isEqual(other.field) && this.transform.isEqual(other.transform);
        };
        return FieldTransform;
      }();
      var MutationResult = function() {
        function MutationResult(version, transformResults) {
          this.version = version;
          this.transformResults = transformResults;
        }
        return MutationResult;
      }();
      var MutationType;
      (function(MutationType) {
        MutationType[MutationType["Set"] = 0] = "Set";
        MutationType[MutationType["Patch"] = 1] = "Patch";
        MutationType[MutationType["Transform"] = 2] = "Transform";
        MutationType[MutationType["Delete"] = 3] = "Delete";
      })(MutationType || (MutationType = {}));
      var Precondition = function() {
        function Precondition(updateTime, exists) {
          this.updateTime = updateTime;
          this.exists = exists;
          assert(void 0 === updateTime || void 0 === exists, 'Precondition can specify "exists" or "updateTime" but not both');
        }
        Precondition.exists = function(exists) {
          return new Precondition(void 0, exists);
        };
        Precondition.updateTime = function(version) {
          return new Precondition(version);
        };
        Object.defineProperty(Precondition.prototype, "isNone", {
          get: function() {
            return void 0 === this.updateTime && void 0 === this.exists;
          },
          enumerable: true,
          configurable: true
        });
        Precondition.prototype.isValidFor = function(maybeDoc) {
          if (void 0 !== this.updateTime) return maybeDoc instanceof Document && maybeDoc.version.isEqual(this.updateTime);
          if (void 0 !== this.exists) return this.exists ? maybeDoc instanceof Document : null === maybeDoc || maybeDoc instanceof NoDocument;
          assert(this.isNone, "Precondition should be empty");
          return true;
        };
        Precondition.prototype.isEqual = function(other) {
          return equals(this.updateTime, other.updateTime) && this.exists === other.exists;
        };
        Precondition.NONE = new Precondition();
        return Precondition;
      }();
      var Mutation = function() {
        function Mutation() {}
        Mutation.prototype.verifyKeyMatches = function(maybeDoc) {
          null != maybeDoc && assert(maybeDoc.key.isEqual(this.key), "Can only apply a mutation to a document with the same key");
        };
        Mutation.getPostMutationVersion = function(maybeDoc) {
          return maybeDoc instanceof Document ? maybeDoc.version : SnapshotVersion.MIN;
        };
        return Mutation;
      }();
      var SetMutation = function(_super) {
        tslib_1.__extends(SetMutation, _super);
        function SetMutation(key, value, precondition) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.value = value;
          _this.precondition = precondition;
          _this.type = MutationType.Set;
          return _this;
        }
        SetMutation.prototype.applyToRemoteDocument = function(maybeDoc, mutationResult) {
          this.verifyKeyMatches(maybeDoc);
          assert(null == mutationResult.transformResults, "Transform results received by SetMutation.");
          var version = Mutation.getPostMutationVersion(maybeDoc);
          return new Document(this.key, version, this.value, {
            hasLocalMutations: false
          });
        };
        SetMutation.prototype.applyToLocalView = function(maybeDoc, baseDoc, localWriteTime) {
          this.verifyKeyMatches(maybeDoc);
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          var version = Mutation.getPostMutationVersion(maybeDoc);
          return new Document(this.key, version, this.value, {
            hasLocalMutations: true
          });
        };
        SetMutation.prototype.isEqual = function(other) {
          return other instanceof SetMutation && this.key.isEqual(other.key) && this.value.isEqual(other.value) && this.precondition.isEqual(other.precondition);
        };
        return SetMutation;
      }(Mutation);
      var PatchMutation = function(_super) {
        tslib_1.__extends(PatchMutation, _super);
        function PatchMutation(key, data, fieldMask, precondition) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.data = data;
          _this.fieldMask = fieldMask;
          _this.precondition = precondition;
          _this.type = MutationType.Patch;
          return _this;
        }
        PatchMutation.prototype.applyToRemoteDocument = function(maybeDoc, mutationResult) {
          this.verifyKeyMatches(maybeDoc);
          assert(null == mutationResult.transformResults, "Transform results received by PatchMutation.");
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          var version = Mutation.getPostMutationVersion(maybeDoc);
          var newData = this.patchDocument(maybeDoc);
          return new Document(this.key, version, newData, {
            hasLocalMutations: false
          });
        };
        PatchMutation.prototype.applyToLocalView = function(maybeDoc, baseDoc, localWriteTime) {
          this.verifyKeyMatches(maybeDoc);
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          var version = Mutation.getPostMutationVersion(maybeDoc);
          var newData = this.patchDocument(maybeDoc);
          return new Document(this.key, version, newData, {
            hasLocalMutations: true
          });
        };
        PatchMutation.prototype.isEqual = function(other) {
          return other instanceof PatchMutation && this.key.isEqual(other.key) && this.fieldMask.isEqual(other.fieldMask) && this.precondition.isEqual(other.precondition);
        };
        PatchMutation.prototype.patchDocument = function(maybeDoc) {
          var data;
          data = maybeDoc instanceof Document ? maybeDoc.data : ObjectValue.EMPTY;
          return this.patchObject(data);
        };
        PatchMutation.prototype.patchObject = function(data) {
          for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {
            var fieldPath = _a[_i];
            var newValue = this.data.field(fieldPath);
            data = void 0 !== newValue ? data.set(fieldPath, newValue) : data.delete(fieldPath);
          }
          return data;
        };
        return PatchMutation;
      }(Mutation);
      var TransformMutation = function(_super) {
        tslib_1.__extends(TransformMutation, _super);
        function TransformMutation(key, fieldTransforms) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.fieldTransforms = fieldTransforms;
          _this.type = MutationType.Transform;
          _this.precondition = Precondition.exists(true);
          return _this;
        }
        TransformMutation.prototype.applyToRemoteDocument = function(maybeDoc, mutationResult) {
          this.verifyKeyMatches(maybeDoc);
          assert(null != mutationResult.transformResults, "Transform results missing for TransformMutation.");
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          var doc = this.requireDocument(maybeDoc);
          var transformResults = this.serverTransformResults(maybeDoc, mutationResult.transformResults);
          var newData = this.transformObject(doc.data, transformResults);
          return new Document(this.key, doc.version, newData, {
            hasLocalMutations: false
          });
        };
        TransformMutation.prototype.applyToLocalView = function(maybeDoc, baseDoc, localWriteTime) {
          this.verifyKeyMatches(maybeDoc);
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          var doc = this.requireDocument(maybeDoc);
          var transformResults = this.localTransformResults(localWriteTime, baseDoc);
          var newData = this.transformObject(doc.data, transformResults);
          return new Document(this.key, doc.version, newData, {
            hasLocalMutations: true
          });
        };
        TransformMutation.prototype.isEqual = function(other) {
          return other instanceof TransformMutation && this.key.isEqual(other.key) && arrayEquals(this.fieldTransforms, other.fieldTransforms) && this.precondition.isEqual(other.precondition);
        };
        TransformMutation.prototype.requireDocument = function(maybeDoc) {
          assert(maybeDoc instanceof Document, "Unknown MaybeDocument type " + maybeDoc);
          var doc = maybeDoc;
          assert(doc.key.isEqual(this.key), "Can only transform a document with the same key");
          return doc;
        };
        TransformMutation.prototype.serverTransformResults = function(baseDoc, serverTransformResults) {
          var transformResults = [];
          assert(this.fieldTransforms.length === serverTransformResults.length, "server transform result count (" + serverTransformResults.length + ") should match field transform count (" + this.fieldTransforms.length + ")");
          for (var i = 0; i < serverTransformResults.length; i++) {
            var fieldTransform = this.fieldTransforms[i];
            var transform = fieldTransform.transform;
            var previousValue = null;
            baseDoc instanceof Document && (previousValue = baseDoc.field(fieldTransform.field) || null);
            transformResults.push(transform.applyToRemoteDocument(previousValue, serverTransformResults[i]));
          }
          return transformResults;
        };
        TransformMutation.prototype.localTransformResults = function(localWriteTime, baseDoc) {
          var transformResults = [];
          for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {
            var fieldTransform = _a[_i];
            var transform = fieldTransform.transform;
            var previousValue = null;
            baseDoc instanceof Document && (previousValue = baseDoc.field(fieldTransform.field) || null);
            transformResults.push(transform.applyToLocalView(previousValue, localWriteTime));
          }
          return transformResults;
        };
        TransformMutation.prototype.transformObject = function(data, transformResults) {
          assert(transformResults.length === this.fieldTransforms.length, "TransformResults length mismatch.");
          for (var i = 0; i < this.fieldTransforms.length; i++) {
            var fieldTransform = this.fieldTransforms[i];
            var fieldPath = fieldTransform.field;
            data = data.set(fieldPath, transformResults[i]);
          }
          return data;
        };
        return TransformMutation;
      }(Mutation);
      var DeleteMutation = function(_super) {
        tslib_1.__extends(DeleteMutation, _super);
        function DeleteMutation(key, precondition) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.precondition = precondition;
          _this.type = MutationType.Delete;
          return _this;
        }
        DeleteMutation.prototype.applyToRemoteDocument = function(maybeDoc, mutationResult) {
          this.verifyKeyMatches(maybeDoc);
          assert(null == mutationResult.transformResults, "Transform results received by DeleteMutation.");
          return new NoDocument(this.key, SnapshotVersion.MIN);
        };
        DeleteMutation.prototype.applyToLocalView = function(maybeDoc, baseDoc, localWriteTime) {
          this.verifyKeyMatches(maybeDoc);
          if (!this.precondition.isValidFor(maybeDoc)) return maybeDoc;
          maybeDoc && assert(maybeDoc.key.isEqual(this.key), "Can only apply mutation to document with same key");
          return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());
        };
        DeleteMutation.prototype.isEqual = function(other) {
          return other instanceof DeleteMutation && this.key.isEqual(other.key) && this.precondition.isEqual(other.precondition);
        };
        return DeleteMutation;
      }(Mutation);
      var ExistenceFilter = function() {
        function ExistenceFilter(count) {
          this.count = count;
        }
        ExistenceFilter.prototype.isEqual = function(other) {
          return other && other.count === this.count;
        };
        return ExistenceFilter;
      }();
      var RpcCode;
      (function(RpcCode) {
        RpcCode[RpcCode["OK"] = 0] = "OK";
        RpcCode[RpcCode["CANCELLED"] = 1] = "CANCELLED";
        RpcCode[RpcCode["UNKNOWN"] = 2] = "UNKNOWN";
        RpcCode[RpcCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
        RpcCode[RpcCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
        RpcCode[RpcCode["NOT_FOUND"] = 5] = "NOT_FOUND";
        RpcCode[RpcCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
        RpcCode[RpcCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
        RpcCode[RpcCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
        RpcCode[RpcCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
        RpcCode[RpcCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
        RpcCode[RpcCode["ABORTED"] = 10] = "ABORTED";
        RpcCode[RpcCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
        RpcCode[RpcCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
        RpcCode[RpcCode["INTERNAL"] = 13] = "INTERNAL";
        RpcCode[RpcCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
        RpcCode[RpcCode["DATA_LOSS"] = 15] = "DATA_LOSS";
      })(RpcCode || (RpcCode = {}));
      function isPermanentError(code) {
        switch (code) {
         case Code.OK:
          return fail("Treated status OK as error");

         case Code.CANCELLED:
         case Code.UNKNOWN:
         case Code.DEADLINE_EXCEEDED:
         case Code.RESOURCE_EXHAUSTED:
         case Code.INTERNAL:
         case Code.UNAVAILABLE:
         case Code.UNAUTHENTICATED:
          return false;

         case Code.INVALID_ARGUMENT:
         case Code.NOT_FOUND:
         case Code.ALREADY_EXISTS:
         case Code.PERMISSION_DENIED:
         case Code.FAILED_PRECONDITION:
         case Code.ABORTED:
         case Code.OUT_OF_RANGE:
         case Code.UNIMPLEMENTED:
         case Code.DATA_LOSS:
          return true;

         default:
          return fail("Unknown status code: " + code);
        }
      }
      function mapCodeFromRpcStatus(status) {
        var code = RpcCode[status];
        if (void 0 === code) return;
        return mapCodeFromRpcCode(code);
      }
      function mapCodeFromRpcCode(code) {
        if (void 0 === code) {
          error("GRPC error has no .code");
          return Code.UNKNOWN;
        }
        switch (code) {
         case RpcCode.OK:
          return Code.OK;

         case RpcCode.CANCELLED:
          return Code.CANCELLED;

         case RpcCode.UNKNOWN:
          return Code.UNKNOWN;

         case RpcCode.DEADLINE_EXCEEDED:
          return Code.DEADLINE_EXCEEDED;

         case RpcCode.RESOURCE_EXHAUSTED:
          return Code.RESOURCE_EXHAUSTED;

         case RpcCode.INTERNAL:
          return Code.INTERNAL;

         case RpcCode.UNAVAILABLE:
          return Code.UNAVAILABLE;

         case RpcCode.UNAUTHENTICATED:
          return Code.UNAUTHENTICATED;

         case RpcCode.INVALID_ARGUMENT:
          return Code.INVALID_ARGUMENT;

         case RpcCode.NOT_FOUND:
          return Code.NOT_FOUND;

         case RpcCode.ALREADY_EXISTS:
          return Code.ALREADY_EXISTS;

         case RpcCode.PERMISSION_DENIED:
          return Code.PERMISSION_DENIED;

         case RpcCode.FAILED_PRECONDITION:
          return Code.FAILED_PRECONDITION;

         case RpcCode.ABORTED:
          return Code.ABORTED;

         case RpcCode.OUT_OF_RANGE:
          return Code.OUT_OF_RANGE;

         case RpcCode.UNIMPLEMENTED:
          return Code.UNIMPLEMENTED;

         case RpcCode.DATA_LOSS:
          return Code.DATA_LOSS;

         default:
          return fail("Unknown status code: " + code);
        }
      }
      function mapRpcCodeFromCode(code) {
        if (void 0 === code) return RpcCode.OK;
        switch (code) {
         case Code.OK:
          return RpcCode.OK;

         case Code.CANCELLED:
          return RpcCode.CANCELLED;

         case Code.UNKNOWN:
          return RpcCode.UNKNOWN;

         case Code.DEADLINE_EXCEEDED:
          return RpcCode.DEADLINE_EXCEEDED;

         case Code.RESOURCE_EXHAUSTED:
          return RpcCode.RESOURCE_EXHAUSTED;

         case Code.INTERNAL:
          return RpcCode.INTERNAL;

         case Code.UNAVAILABLE:
          return RpcCode.UNAVAILABLE;

         case Code.UNAUTHENTICATED:
          return RpcCode.UNAUTHENTICATED;

         case Code.INVALID_ARGUMENT:
          return RpcCode.INVALID_ARGUMENT;

         case Code.NOT_FOUND:
          return RpcCode.NOT_FOUND;

         case Code.ALREADY_EXISTS:
          return RpcCode.ALREADY_EXISTS;

         case Code.PERMISSION_DENIED:
          return RpcCode.PERMISSION_DENIED;

         case Code.FAILED_PRECONDITION:
          return RpcCode.FAILED_PRECONDITION;

         case Code.ABORTED:
          return RpcCode.ABORTED;

         case Code.OUT_OF_RANGE:
          return RpcCode.OUT_OF_RANGE;

         case Code.UNIMPLEMENTED:
          return RpcCode.UNIMPLEMENTED;

         case Code.DATA_LOSS:
          return RpcCode.DATA_LOSS;

         default:
          return fail("Unknown status code: " + code);
        }
      }
      function mapCodeFromHttpStatus(status) {
        switch (status) {
         case 200:
          return Code.OK;

         case 400:
          return Code.INVALID_ARGUMENT;

         case 401:
          return Code.UNAUTHENTICATED;

         case 403:
          return Code.PERMISSION_DENIED;

         case 404:
          return Code.NOT_FOUND;

         case 409:
          return Code.ABORTED;

         case 416:
          return Code.OUT_OF_RANGE;

         case 429:
          return Code.RESOURCE_EXHAUSTED;

         case 499:
          return Code.CANCELLED;

         case 500:
          return Code.UNKNOWN;

         case 501:
          return Code.UNIMPLEMENTED;

         case 503:
          return Code.UNAVAILABLE;

         case 504:
          return Code.DEADLINE_EXCEEDED;

         default:
          if (status >= 200 && status < 300) return Code.OK;
          if (status >= 400 && status < 500) return Code.FAILED_PRECONDITION;
          if (status >= 500 && status < 600) return Code.INTERNAL;
          return Code.UNKNOWN;
        }
      }
      var SortedSet = function() {
        function SortedSet(comparator) {
          this.comparator = comparator;
          this.data = new SortedMap(this.comparator);
        }
        SortedSet.fromMapKeys = function(map) {
          var keys = new SortedSet(map.comparator);
          map.forEach(function(key) {
            keys = keys.add(key);
          });
          return keys;
        };
        SortedSet.prototype.has = function(elem) {
          return null !== this.data.get(elem);
        };
        SortedSet.prototype.first = function() {
          return this.data.minKey();
        };
        SortedSet.prototype.last = function() {
          return this.data.maxKey();
        };
        Object.defineProperty(SortedSet.prototype, "size", {
          get: function() {
            return this.data.size;
          },
          enumerable: true,
          configurable: true
        });
        SortedSet.prototype.indexOf = function(elem) {
          return this.data.indexOf(elem);
        };
        SortedSet.prototype.forEach = function(cb) {
          this.data.inorderTraversal(function(k, v) {
            cb(k);
            return false;
          });
        };
        SortedSet.prototype.forEachInRange = function(range, cb) {
          var iter = this.data.getIteratorFrom(range[0]);
          while (iter.hasNext()) {
            var elem = iter.getNext();
            if (this.comparator(elem.key, range[1]) >= 0) return;
            cb(elem.key);
          }
        };
        SortedSet.prototype.forEachWhile = function(cb, start) {
          var iter;
          iter = void 0 !== start ? this.data.getIteratorFrom(start) : this.data.getIterator();
          while (iter.hasNext()) {
            var elem = iter.getNext();
            var result = cb(elem.key);
            if (!result) return;
          }
        };
        SortedSet.prototype.firstAfterOrEqual = function(elem) {
          var iter = this.data.getIteratorFrom(elem);
          return iter.hasNext() ? iter.getNext().key : null;
        };
        SortedSet.prototype.add = function(elem) {
          return this.copy(this.data.remove(elem).insert(elem, true));
        };
        SortedSet.prototype.delete = function(elem) {
          if (!this.has(elem)) return this;
          return this.copy(this.data.remove(elem));
        };
        SortedSet.prototype.isEmpty = function() {
          return this.data.isEmpty();
        };
        SortedSet.prototype.unionWith = function(other) {
          var result = this;
          other.forEach(function(elem) {
            result = result.add(elem);
          });
          return result;
        };
        SortedSet.prototype.isEqual = function(other) {
          if (!(other instanceof SortedSet)) return false;
          if (this.size !== other.size) return false;
          var thisIt = this.data.getIterator();
          var otherIt = other.data.getIterator();
          while (thisIt.hasNext()) {
            var thisElem = thisIt.getNext().key;
            var otherElem = otherIt.getNext().key;
            if (0 !== this.comparator(thisElem, otherElem)) return false;
          }
          return true;
        };
        SortedSet.prototype.toString = function() {
          var result = [];
          this.forEach(function(elem) {
            return result.push(elem);
          });
          return "SortedSet(" + result.toString() + ")";
        };
        SortedSet.prototype.copy = function(data) {
          var result = new SortedSet(this.comparator);
          result.data = data;
          return result;
        };
        return SortedSet;
      }();
      var EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
      function maybeDocumentMap() {
        return EMPTY_MAYBE_DOCUMENT_MAP;
      }
      var EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
      function documentMap() {
        return EMPTY_DOCUMENT_MAP;
      }
      var EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);
      function documentVersionMap() {
        return EMPTY_DOCUMENT_VERSION_MAP;
      }
      var EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);
      function documentKeySet() {
        return EMPTY_DOCUMENT_KEY_SET;
      }
      var RemoteEvent = function() {
        function RemoteEvent(snapshotVersion, targetChanges, targetMismatches, documentUpdates, resolvedLimboDocuments) {
          this.snapshotVersion = snapshotVersion;
          this.targetChanges = targetChanges;
          this.targetMismatches = targetMismatches;
          this.documentUpdates = documentUpdates;
          this.resolvedLimboDocuments = resolvedLimboDocuments;
        }
        return RemoteEvent;
      }();
      var TargetChange = function() {
        function TargetChange(resumeToken, current, addedDocuments, modifiedDocuments, removedDocuments) {
          this.resumeToken = resumeToken;
          this.current = current;
          this.addedDocuments = addedDocuments;
          this.modifiedDocuments = modifiedDocuments;
          this.removedDocuments = removedDocuments;
        }
        return TargetChange;
      }();
      var ChangeType;
      (function(ChangeType) {
        ChangeType[ChangeType["Added"] = 0] = "Added";
        ChangeType[ChangeType["Removed"] = 1] = "Removed";
        ChangeType[ChangeType["Modified"] = 2] = "Modified";
        ChangeType[ChangeType["Metadata"] = 3] = "Metadata";
      })(ChangeType || (ChangeType = {}));
      var SyncState;
      (function(SyncState) {
        SyncState[SyncState["Local"] = 0] = "Local";
        SyncState[SyncState["Synced"] = 1] = "Synced";
      })(SyncState || (SyncState = {}));
      var DocumentChangeSet = function() {
        function DocumentChangeSet() {
          this.changeMap = new SortedMap(DocumentKey.comparator);
        }
        DocumentChangeSet.prototype.track = function(change) {
          var key = change.doc.key;
          var oldChange = this.changeMap.get(key);
          if (!oldChange) {
            this.changeMap = this.changeMap.insert(key, change);
            return;
          }
          change.type !== ChangeType.Added && oldChange.type === ChangeType.Metadata ? this.changeMap = this.changeMap.insert(key, change) : change.type === ChangeType.Metadata && oldChange.type !== ChangeType.Removed ? this.changeMap = this.changeMap.insert(key, {
            type: oldChange.type,
            doc: change.doc
          }) : change.type === ChangeType.Modified && oldChange.type === ChangeType.Modified ? this.changeMap = this.changeMap.insert(key, {
            type: ChangeType.Modified,
            doc: change.doc
          }) : change.type === ChangeType.Modified && oldChange.type === ChangeType.Added ? this.changeMap = this.changeMap.insert(key, {
            type: ChangeType.Added,
            doc: change.doc
          }) : change.type === ChangeType.Removed && oldChange.type === ChangeType.Added ? this.changeMap = this.changeMap.remove(key) : change.type === ChangeType.Removed && oldChange.type === ChangeType.Modified ? this.changeMap = this.changeMap.insert(key, {
            type: ChangeType.Removed,
            doc: oldChange.doc
          }) : change.type === ChangeType.Added && oldChange.type === ChangeType.Removed ? this.changeMap = this.changeMap.insert(key, {
            type: ChangeType.Modified,
            doc: change.doc
          }) : fail("unsupported combination of changes: " + JSON.stringify(change) + " after " + JSON.stringify(oldChange));
        };
        DocumentChangeSet.prototype.getChanges = function() {
          var changes = [];
          this.changeMap.inorderTraversal(function(key, change) {
            changes.push(change);
          });
          return changes;
        };
        return DocumentChangeSet;
      }();
      var ViewSnapshot = function() {
        function ViewSnapshot(query, docs, oldDocs, docChanges, fromCache, hasPendingWrites, syncStateChanged, excludesMetadataChanges) {
          this.query = query;
          this.docs = docs;
          this.oldDocs = oldDocs;
          this.docChanges = docChanges;
          this.fromCache = fromCache;
          this.hasPendingWrites = hasPendingWrites;
          this.syncStateChanged = syncStateChanged;
          this.excludesMetadataChanges = excludesMetadataChanges;
        }
        ViewSnapshot.prototype.isEqual = function(other) {
          if (this.fromCache !== other.fromCache || this.hasPendingWrites !== other.hasPendingWrites || this.syncStateChanged !== other.syncStateChanged || !this.query.isEqual(other.query) || !this.docs.isEqual(other.docs) || !this.oldDocs.isEqual(other.oldDocs)) return false;
          var changes = this.docChanges;
          var otherChanges = other.docChanges;
          if (changes.length !== otherChanges.length) return false;
          for (var i = 0; i < changes.length; i++) if (changes[i].type !== otherChanges[i].type || !changes[i].doc.isEqual(otherChanges[i].doc)) return false;
          return true;
        };
        return ViewSnapshot;
      }();
      var DocumentWatchChange = function() {
        function DocumentWatchChange(updatedTargetIds, removedTargetIds, key, newDoc) {
          this.updatedTargetIds = updatedTargetIds;
          this.removedTargetIds = removedTargetIds;
          this.key = key;
          this.newDoc = newDoc;
        }
        return DocumentWatchChange;
      }();
      var ExistenceFilterChange = function() {
        function ExistenceFilterChange(targetId, existenceFilter) {
          this.targetId = targetId;
          this.existenceFilter = existenceFilter;
        }
        return ExistenceFilterChange;
      }();
      var WatchTargetChangeState;
      (function(WatchTargetChangeState) {
        WatchTargetChangeState[WatchTargetChangeState["NoChange"] = 0] = "NoChange";
        WatchTargetChangeState[WatchTargetChangeState["Added"] = 1] = "Added";
        WatchTargetChangeState[WatchTargetChangeState["Removed"] = 2] = "Removed";
        WatchTargetChangeState[WatchTargetChangeState["Current"] = 3] = "Current";
        WatchTargetChangeState[WatchTargetChangeState["Reset"] = 4] = "Reset";
      })(WatchTargetChangeState || (WatchTargetChangeState = {}));
      var WatchTargetChange = function() {
        function WatchTargetChange(state, targetIds, resumeToken, cause) {
          void 0 === resumeToken && (resumeToken = emptyByteString());
          void 0 === cause && (cause = null);
          this.state = state;
          this.targetIds = targetIds;
          this.resumeToken = resumeToken;
          this.cause = cause;
        }
        return WatchTargetChange;
      }();
      var TargetState = function() {
        function TargetState() {
          this.pendingResponses = 0;
          this.documentChanges = snapshotChangesMap();
          this._resumeToken = emptyByteString();
          this._current = false;
          this._hasPendingChanges = true;
        }
        Object.defineProperty(TargetState.prototype, "current", {
          get: function() {
            return this._current;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(TargetState.prototype, "resumeToken", {
          get: function() {
            return this._resumeToken;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(TargetState.prototype, "isPending", {
          get: function() {
            return 0 !== this.pendingResponses;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(TargetState.prototype, "hasPendingChanges", {
          get: function() {
            return this._hasPendingChanges;
          },
          enumerable: true,
          configurable: true
        });
        TargetState.prototype.updateResumeToken = function(resumeToken) {
          if (resumeToken.length > 0) {
            this._hasPendingChanges = true;
            this._resumeToken = resumeToken;
          }
        };
        TargetState.prototype.toTargetChange = function() {
          var addedDocuments = documentKeySet();
          var modifiedDocuments = documentKeySet();
          var removedDocuments = documentKeySet();
          this.documentChanges.forEach(function(key, changeType) {
            switch (changeType) {
             case ChangeType.Added:
              addedDocuments = addedDocuments.add(key);
              break;

             case ChangeType.Modified:
              modifiedDocuments = modifiedDocuments.add(key);
              break;

             case ChangeType.Removed:
              removedDocuments = removedDocuments.add(key);
              break;

             default:
              fail("Encountered invalid change type: " + changeType);
            }
          });
          return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);
        };
        TargetState.prototype.clearPendingChanges = function() {
          this._hasPendingChanges = false;
          this.documentChanges = snapshotChangesMap();
        };
        TargetState.prototype.addDocumentChange = function(key, changeType) {
          this._hasPendingChanges = true;
          this.documentChanges = this.documentChanges.insert(key, changeType);
        };
        TargetState.prototype.removeDocumentChange = function(key) {
          this._hasPendingChanges = true;
          this.documentChanges = this.documentChanges.remove(key);
        };
        TargetState.prototype.recordPendingTargetRequest = function() {
          this.pendingResponses += 1;
        };
        TargetState.prototype.recordTargetResponse = function() {
          this.pendingResponses -= 1;
        };
        TargetState.prototype.markCurrent = function() {
          this._hasPendingChanges = true;
          this._current = true;
        };
        return TargetState;
      }();
      var WatchChangeAggregator = function() {
        function WatchChangeAggregator(metadataProvider) {
          this.metadataProvider = metadataProvider;
          this.targetStates = {};
          this.pendingDocumentUpdates = maybeDocumentMap();
          this.pendingDocumentTargetMapping = documentTargetMap();
          this.pendingTargetResets = new SortedSet(primitiveComparator);
        }
        WatchChangeAggregator.prototype.handleDocumentChange = function(docChange) {
          for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {
            var targetId = _a[_i];
            docChange.newDoc instanceof Document ? this.addDocumentToTarget(targetId, docChange.newDoc) : docChange.newDoc instanceof NoDocument && this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
          }
          for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {
            var targetId = _c[_b];
            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
          }
        };
        WatchChangeAggregator.prototype.handleTargetChange = function(targetChange) {
          var _this = this;
          this.forEachTarget(targetChange, function(targetId) {
            var targetState = _this.ensureTargetState(targetId);
            switch (targetChange.state) {
             case WatchTargetChangeState.NoChange:
              _this.isActiveTarget(targetId) && targetState.updateResumeToken(targetChange.resumeToken);
              break;

             case WatchTargetChangeState.Added:
              targetState.recordTargetResponse();
              targetState.isPending || targetState.clearPendingChanges();
              targetState.updateResumeToken(targetChange.resumeToken);
              break;

             case WatchTargetChangeState.Removed:
              targetState.recordTargetResponse();
              targetState.isPending || _this.removeTarget(targetId);
              assert(!targetChange.cause, "WatchChangeAggregator does not handle errored targets");
              break;

             case WatchTargetChangeState.Current:
              if (_this.isActiveTarget(targetId)) {
                targetState.markCurrent();
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;

             case WatchTargetChangeState.Reset:
              if (_this.isActiveTarget(targetId)) {
                _this.resetTarget(targetId);
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;

             default:
              fail("Unknown target watch change state: " + targetChange.state);
            }
          });
        };
        WatchChangeAggregator.prototype.forEachTarget = function(targetChange, fn) {
          targetChange.targetIds.length > 0 ? targetChange.targetIds.forEach(fn) : forEachNumber(this.targetStates, fn);
        };
        WatchChangeAggregator.prototype.handleExistenceFilter = function(watchChange) {
          var targetId = watchChange.targetId;
          var expectedCount = watchChange.existenceFilter.count;
          var queryData = this.queryDataForActiveTarget(targetId);
          if (queryData) {
            var query = queryData.query;
            if (query.isDocumentQuery()) if (0 === expectedCount) {
              var key = new DocumentKey(query.path);
              this.removeDocumentFromTarget(targetId, key, new NoDocument(key, SnapshotVersion.forDeletedDoc()));
            } else assert(1 === expectedCount, "Single document existence filter with count: " + expectedCount); else {
              var currentSize = this.getCurrentDocumentCountForTarget(targetId);
              if (currentSize !== expectedCount) {
                this.resetTarget(targetId);
                this.pendingTargetResets = this.pendingTargetResets.add(targetId);
              }
            }
          }
        };
        WatchChangeAggregator.prototype.createRemoteEvent = function(snapshotVersion) {
          var _this = this;
          var targetChanges = {};
          forEachNumber(this.targetStates, function(targetId, targetState) {
            var queryData = _this.queryDataForActiveTarget(targetId);
            if (queryData) {
              if (targetState.current && queryData.query.isDocumentQuery()) {
                var key = new DocumentKey(queryData.query.path);
                null !== _this.pendingDocumentUpdates.get(key) || _this.targetContainsDocument(targetId, key) || _this.removeDocumentFromTarget(targetId, key, new NoDocument(key, snapshotVersion));
              }
              if (targetState.hasPendingChanges) {
                targetChanges[targetId] = targetState.toTargetChange();
                targetState.clearPendingChanges();
              }
            }
          });
          var resolvedLimboDocuments = documentKeySet();
          this.pendingDocumentTargetMapping.forEach(function(key, targets) {
            var isOnlyLimboTarget = true;
            targets.forEachWhile(function(targetId) {
              var queryData = _this.queryDataForActiveTarget(targetId);
              if (queryData && queryData.purpose !== QueryPurpose.LimboResolution) {
                isOnlyLimboTarget = false;
                return false;
              }
              return true;
            });
            isOnlyLimboTarget && (resolvedLimboDocuments = resolvedLimboDocuments.add(key));
          });
          var remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);
          this.pendingDocumentUpdates = maybeDocumentMap();
          this.pendingDocumentTargetMapping = documentTargetMap();
          this.pendingTargetResets = new SortedSet(primitiveComparator);
          return remoteEvent;
        };
        WatchChangeAggregator.prototype.addDocumentToTarget = function(targetId, document) {
          if (!this.isActiveTarget(targetId)) return;
          var changeType = this.targetContainsDocument(targetId, document.key) ? ChangeType.Modified : ChangeType.Added;
          var targetState = this.ensureTargetState(targetId);
          targetState.addDocumentChange(document.key, changeType);
          this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);
          this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));
        };
        WatchChangeAggregator.prototype.removeDocumentFromTarget = function(targetId, key, updatedDocument) {
          if (!this.isActiveTarget(targetId)) return;
          var targetState = this.ensureTargetState(targetId);
          this.targetContainsDocument(targetId, key) ? targetState.addDocumentChange(key, ChangeType.Removed) : targetState.removeDocumentChange(key);
          this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));
          updatedDocument && (this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument));
        };
        WatchChangeAggregator.prototype.removeTarget = function(targetId) {
          delete this.targetStates[targetId];
        };
        WatchChangeAggregator.prototype.getCurrentDocumentCountForTarget = function(targetId) {
          var targetState = this.ensureTargetState(targetId);
          var targetChange = targetState.toTargetChange();
          return this.metadataProvider.getRemoteKeysForTarget(targetId).size + targetChange.addedDocuments.size - targetChange.removedDocuments.size;
        };
        WatchChangeAggregator.prototype.recordPendingTargetRequest = function(targetId) {
          var targetState = this.ensureTargetState(targetId);
          targetState.recordPendingTargetRequest();
        };
        WatchChangeAggregator.prototype.ensureTargetState = function(targetId) {
          this.targetStates[targetId] || (this.targetStates[targetId] = new TargetState());
          return this.targetStates[targetId];
        };
        WatchChangeAggregator.prototype.ensureDocumentTargetMapping = function(key) {
          var targetMapping = this.pendingDocumentTargetMapping.get(key);
          if (!targetMapping) {
            targetMapping = new SortedSet(primitiveComparator);
            this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, targetMapping);
          }
          return targetMapping;
        };
        WatchChangeAggregator.prototype.isActiveTarget = function(targetId) {
          return null !== this.queryDataForActiveTarget(targetId);
        };
        WatchChangeAggregator.prototype.queryDataForActiveTarget = function(targetId) {
          var targetState = this.targetStates[targetId];
          return targetState && targetState.isPending ? null : this.metadataProvider.getQueryDataForTarget(targetId);
        };
        WatchChangeAggregator.prototype.resetTarget = function(targetId) {
          var _this = this;
          assert(!this.targetStates[targetId].isPending, "Should only reset active targets");
          this.targetStates[targetId] = new TargetState();
          var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
          existingKeys.forEach(function(key) {
            _this.removeDocumentFromTarget(targetId, key);
          });
        };
        WatchChangeAggregator.prototype.targetContainsDocument = function(targetId, key) {
          var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
          return existingKeys.has(key);
        };
        return WatchChangeAggregator;
      }();
      function documentTargetMap() {
        return new SortedMap(DocumentKey.comparator);
      }
      function snapshotChangesMap() {
        return new SortedMap(DocumentKey.comparator);
      }
      var ServerTimestampTransform = function() {
        function ServerTimestampTransform() {}
        ServerTimestampTransform.prototype.applyToLocalView = function(previousValue, localWriteTime) {
          return new ServerTimestampValue(localWriteTime, previousValue);
        };
        ServerTimestampTransform.prototype.applyToRemoteDocument = function(previousValue, transformResult) {
          return transformResult;
        };
        ServerTimestampTransform.prototype.isEqual = function(other) {
          return other instanceof ServerTimestampTransform;
        };
        ServerTimestampTransform.instance = new ServerTimestampTransform();
        return ServerTimestampTransform;
      }();
      var ArrayUnionTransformOperation = function() {
        function ArrayUnionTransformOperation(elements) {
          this.elements = elements;
        }
        ArrayUnionTransformOperation.prototype.applyToLocalView = function(previousValue, localWriteTime) {
          return this.apply(previousValue);
        };
        ArrayUnionTransformOperation.prototype.applyToRemoteDocument = function(previousValue, transformResult) {
          return this.apply(previousValue);
        };
        ArrayUnionTransformOperation.prototype.apply = function(previousValue) {
          var result = coercedFieldValuesArray(previousValue);
          var _loop_1 = function(toUnion) {
            result.find(function(element) {
              return element.isEqual(toUnion);
            }) || result.push(toUnion);
          };
          for (var _i = 0, _a = this.elements; _i < _a.length; _i++) {
            var toUnion = _a[_i];
            _loop_1(toUnion);
          }
          return new ArrayValue(result);
        };
        ArrayUnionTransformOperation.prototype.isEqual = function(other) {
          return other instanceof ArrayUnionTransformOperation && arrayEquals(other.elements, this.elements);
        };
        return ArrayUnionTransformOperation;
      }();
      var ArrayRemoveTransformOperation = function() {
        function ArrayRemoveTransformOperation(elements) {
          this.elements = elements;
        }
        ArrayRemoveTransformOperation.prototype.applyToLocalView = function(previousValue, localWriteTime) {
          return this.apply(previousValue);
        };
        ArrayRemoveTransformOperation.prototype.applyToRemoteDocument = function(previousValue, transformResult) {
          return this.apply(previousValue);
        };
        ArrayRemoveTransformOperation.prototype.apply = function(previousValue) {
          var result = coercedFieldValuesArray(previousValue);
          var _loop_2 = function(toRemove) {
            result = result.filter(function(element) {
              return !element.isEqual(toRemove);
            });
          };
          for (var _i = 0, _a = this.elements; _i < _a.length; _i++) {
            var toRemove = _a[_i];
            _loop_2(toRemove);
          }
          return new ArrayValue(result);
        };
        ArrayRemoveTransformOperation.prototype.isEqual = function(other) {
          return other instanceof ArrayRemoveTransformOperation && arrayEquals(other.elements, this.elements);
        };
        return ArrayRemoveTransformOperation;
      }();
      function coercedFieldValuesArray(value) {
        return value instanceof ArrayValue ? value.internalValue.slice() : [];
      }
      var DIRECTIONS = function() {
        var dirs = {};
        dirs[Direction.ASCENDING.name] = "ASCENDING";
        dirs[Direction.DESCENDING.name] = "DESCENDING";
        return dirs;
      }();
      var OPERATORS = function() {
        var ops = {};
        ops[RelationOp.LESS_THAN.name] = "LESS_THAN";
        ops[RelationOp.LESS_THAN_OR_EQUAL.name] = "LESS_THAN_OR_EQUAL";
        ops[RelationOp.GREATER_THAN.name] = "GREATER_THAN";
        ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = "GREATER_THAN_OR_EQUAL";
        ops[RelationOp.EQUAL.name] = "EQUAL";
        ops[RelationOp.ARRAY_CONTAINS.name] = "ARRAY_CONTAINS";
        return ops;
      }();
      var ISO_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
      function assertPresent(value, description) {
        assert(!isNullOrUndefined(value), description + " is missing");
      }
      function parseInt64(value) {
        return "number" === typeof value ? value : "string" === typeof value ? Number(value) : fail("can't parse " + value);
      }
      var JsonProtoSerializer = function() {
        function JsonProtoSerializer(databaseId, options) {
          this.databaseId = databaseId;
          this.options = options;
        }
        JsonProtoSerializer.prototype.emptyByteString = function() {
          return this.options.useProto3Json ? "" : new Uint8Array(0);
        };
        JsonProtoSerializer.prototype.unsafeCastProtoByteString = function(byteString) {
          return byteString;
        };
        JsonProtoSerializer.prototype.fromRpcStatus = function(status) {
          var code = void 0 === status.code ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
          return new FirestoreError(code, status.message || "");
        };
        JsonProtoSerializer.prototype.toInt32Value = function(val) {
          return isNullOrUndefined(val) ? void 0 : {
            value: val
          };
        };
        JsonProtoSerializer.prototype.fromInt32Value = function(val) {
          var result;
          result = "object" === typeof val ? val.value : val;
          return isNullOrUndefined(result) ? null : result;
        };
        JsonProtoSerializer.prototype.toTimestamp = function(timestamp) {
          return {
            seconds: timestamp.seconds,
            nanos: timestamp.nanoseconds
          };
        };
        JsonProtoSerializer.prototype.fromTimestamp = function(date) {
          if ("string" === typeof date) return this.fromIso8601String(date);
          assert(!!date, "Cannot deserialize null or undefined timestamp.");
          var seconds = parseInt64(date.seconds || "0");
          var nanos = date.nanos || 0;
          return new Timestamp(seconds, nanos);
        };
        JsonProtoSerializer.prototype.fromIso8601String = function(utc) {
          var nanos = 0;
          var fraction = ISO_REG_EXP.exec(utc);
          assert(!!fraction, "invalid timestamp: " + utc);
          if (fraction[1]) {
            var nanoStr = fraction[1];
            nanoStr = (nanoStr + "000000000").substr(0, 9);
            nanos = Number(nanoStr);
          }
          var date = new Date(utc);
          var seconds = Math.floor(date.getTime() / 1e3);
          return new Timestamp(seconds, nanos);
        };
        JsonProtoSerializer.prototype.toBytes = function(bytes) {
          return this.options.useProto3Json ? bytes.toBase64() : this.unsafeCastProtoByteString(bytes.toUint8Array());
        };
        JsonProtoSerializer.prototype.fromBlob = function(blob) {
          if ("string" === typeof blob) {
            assert(this.options.useProto3Json, "Expected bytes to be passed in as Uint8Array, but got a string instead.");
            return Blob.fromBase64String(blob);
          }
          assert(!this.options.useProto3Json, "Expected bytes to be passed in as string, but got something else instead.");
          return Blob.fromUint8Array(blob);
        };
        JsonProtoSerializer.prototype.toVersion = function(version) {
          return this.toTimestamp(version.toTimestamp());
        };
        JsonProtoSerializer.prototype.fromVersion = function(version) {
          assert(!!version, "Trying to deserialize version that isn't set");
          return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));
        };
        JsonProtoSerializer.prototype.toResourceName = function(databaseId, path) {
          return this.fullyQualifiedPrefixPath(databaseId).child("documents").child(path).canonicalString();
        };
        JsonProtoSerializer.prototype.fromResourceName = function(name) {
          var resource = ResourcePath.fromString(name);
          assert(this.isValidResourceName(resource), "Tried to deserialize invalid key " + resource.toString());
          return resource;
        };
        JsonProtoSerializer.prototype.toName = function(key) {
          return this.toResourceName(this.databaseId, key.path);
        };
        JsonProtoSerializer.prototype.fromName = function(name) {
          var resource = this.fromResourceName(name);
          assert(resource.get(1) === this.databaseId.projectId, "Tried to deserialize key from different project: " + resource.get(1) + " vs " + this.databaseId.projectId);
          assert(!resource.get(3) && !this.databaseId.database || resource.get(3) === this.databaseId.database, "Tried to deserialize key from different database: " + resource.get(3) + " vs " + this.databaseId.database);
          return new DocumentKey(this.extractLocalPathFromResourceName(resource));
        };
        JsonProtoSerializer.prototype.toQueryPath = function(path) {
          if (0 === path.length) return this.encodedDatabaseId;
          return this.toResourceName(this.databaseId, path);
        };
        JsonProtoSerializer.prototype.fromQueryPath = function(name) {
          var resourceName = this.fromResourceName(name);
          if (4 === resourceName.length) return ResourcePath.EMPTY_PATH;
          return this.extractLocalPathFromResourceName(resourceName);
        };
        Object.defineProperty(JsonProtoSerializer.prototype, "encodedDatabaseId", {
          get: function() {
            var path = new ResourcePath([ "projects", this.databaseId.projectId, "databases", this.databaseId.database ]);
            return path.canonicalString();
          },
          enumerable: true,
          configurable: true
        });
        JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function(databaseId) {
          return new ResourcePath([ "projects", databaseId.projectId, "databases", databaseId.database ]);
        };
        JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function(resourceName) {
          assert(resourceName.length > 4 && "documents" === resourceName.get(4), "tried to deserialize invalid key " + resourceName.toString());
          return resourceName.popFirst(5);
        };
        JsonProtoSerializer.prototype.isValidResourceName = function(path) {
          return path.length >= 4 && "projects" === path.get(0) && "databases" === path.get(2);
        };
        JsonProtoSerializer.prototype.toValue = function(val) {
          if (val instanceof NullValue) return {
            nullValue: "NULL_VALUE"
          };
          if (val instanceof BooleanValue) return {
            booleanValue: val.value()
          };
          if (val instanceof IntegerValue) return {
            integerValue: "" + val.value()
          };
          if (val instanceof DoubleValue) {
            var doubleValue = val.value();
            if (this.options.useProto3Json) {
              if (isNaN(doubleValue)) return {
                doubleValue: "NaN"
              };
              if (Infinity === doubleValue) return {
                doubleValue: "Infinity"
              };
              if (-Infinity === doubleValue) return {
                doubleValue: "-Infinity"
              };
            }
            return {
              doubleValue: val.value()
            };
          }
          return val instanceof StringValue ? {
            stringValue: val.value()
          } : val instanceof ObjectValue ? {
            mapValue: this.toMapValue(val)
          } : val instanceof ArrayValue ? {
            arrayValue: this.toArrayValue(val)
          } : val instanceof TimestampValue ? {
            timestampValue: this.toTimestamp(val.internalValue)
          } : val instanceof GeoPointValue ? {
            geoPointValue: {
              latitude: val.value().latitude,
              longitude: val.value().longitude
            }
          } : val instanceof BlobValue ? {
            bytesValue: this.toBytes(val.value())
          } : val instanceof RefValue ? {
            referenceValue: this.toResourceName(val.databaseId, val.key.path)
          } : fail("Unknown FieldValue " + JSON.stringify(val));
        };
        JsonProtoSerializer.prototype.fromValue = function(obj) {
          var _this = this;
          var type = obj["value_type"];
          if (hasTag(obj, type, "nullValue")) return NullValue.INSTANCE;
          if (hasTag(obj, type, "booleanValue")) return BooleanValue.of(obj.booleanValue);
          if (hasTag(obj, type, "integerValue")) return new IntegerValue(parseInt64(obj.integerValue));
          if (hasTag(obj, type, "doubleValue")) {
            if (this.options.useProto3Json) {
              if ("NaN" === obj.doubleValue) return DoubleValue.NAN;
              if ("Infinity" === obj.doubleValue) return DoubleValue.POSITIVE_INFINITY;
              if ("-Infinity" === obj.doubleValue) return DoubleValue.NEGATIVE_INFINITY;
            }
            return new DoubleValue(obj.doubleValue);
          }
          if (hasTag(obj, type, "stringValue")) return new StringValue(obj.stringValue);
          if (hasTag(obj, type, "mapValue")) return this.fromFields(obj.mapValue.fields || {});
          if (hasTag(obj, type, "arrayValue")) {
            assertPresent(obj.arrayValue, "arrayValue");
            var values = obj.arrayValue.values || [];
            return new ArrayValue(values.map(function(v) {
              return _this.fromValue(v);
            }));
          }
          if (hasTag(obj, type, "timestampValue")) {
            assertPresent(obj.timestampValue, "timestampValue");
            return new TimestampValue(this.fromTimestamp(obj.timestampValue));
          }
          if (hasTag(obj, type, "geoPointValue")) {
            assertPresent(obj.geoPointValue, "geoPointValue");
            var latitude = obj.geoPointValue.latitude || 0;
            var longitude = obj.geoPointValue.longitude || 0;
            return new GeoPointValue(new GeoPoint(latitude, longitude));
          }
          if (hasTag(obj, type, "bytesValue")) {
            assertPresent(obj.bytesValue, "bytesValue");
            var blob = this.fromBlob(obj.bytesValue);
            return new BlobValue(blob);
          }
          if (hasTag(obj, type, "referenceValue")) {
            assertPresent(obj.referenceValue, "referenceValue");
            var resourceName = this.fromResourceName(obj.referenceValue);
            var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));
            var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));
            return new RefValue(dbId, key);
          }
          return fail("Unknown Value proto " + JSON.stringify(obj));
        };
        JsonProtoSerializer.prototype.toMutationDocument = function(key, fields) {
          return {
            name: this.toName(key),
            fields: this.toFields(fields)
          };
        };
        JsonProtoSerializer.prototype.toDocument = function(document) {
          assert(!document.hasLocalMutations, "Can't serialize documents with mutations.");
          return {
            name: this.toName(document.key),
            fields: this.toFields(document.data),
            updateTime: this.toTimestamp(document.version.toTimestamp())
          };
        };
        JsonProtoSerializer.prototype.fromDocument = function(document) {
          return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), {
            hasLocalMutations: false
          });
        };
        JsonProtoSerializer.prototype.toFields = function(fields) {
          var _this = this;
          var result = {};
          fields.forEach(function(key, value) {
            result[key] = _this.toValue(value);
          });
          return result;
        };
        JsonProtoSerializer.prototype.fromFields = function(object) {
          var _this = this;
          var map = object;
          var result = ObjectValue.EMPTY;
          forEach(map, function(key, value) {
            result = result.set(new FieldPath([ key ]), _this.fromValue(value));
          });
          return result;
        };
        JsonProtoSerializer.prototype.toMapValue = function(map) {
          return {
            fields: this.toFields(map)
          };
        };
        JsonProtoSerializer.prototype.toArrayValue = function(array) {
          var _this = this;
          var result = [];
          array.forEach(function(value) {
            result.push(_this.toValue(value));
          });
          return {
            values: result
          };
        };
        JsonProtoSerializer.prototype.fromFound = function(doc) {
          assert(!!doc.found, "Tried to deserialize a found document from a missing document.");
          assertPresent(doc.found.name, "doc.found.name");
          assertPresent(doc.found.updateTime, "doc.found.updateTime");
          var key = this.fromName(doc.found.name);
          var version = this.fromVersion(doc.found.updateTime);
          var fields = this.fromFields(doc.found.fields || {});
          return new Document(key, version, fields, {
            hasLocalMutations: false
          });
        };
        JsonProtoSerializer.prototype.fromMissing = function(result) {
          assert(!!result.missing, "Tried to deserialize a missing document from a found document.");
          assert(!!result.readTime, "Tried to deserialize a missing document without a read time.");
          var key = this.fromName(result.missing);
          var version = this.fromVersion(result.readTime);
          return new NoDocument(key, version);
        };
        JsonProtoSerializer.prototype.fromMaybeDocument = function(result) {
          var type = result["result"];
          if (hasTag(result, type, "found")) return this.fromFound(result);
          if (hasTag(result, type, "missing")) return this.fromMissing(result);
          return fail("invalid batch get response: " + JSON.stringify(result));
        };
        JsonProtoSerializer.prototype.toWatchTargetChangeState = function(state) {
          switch (state) {
           case WatchTargetChangeState.Added:
            return "ADD";

           case WatchTargetChangeState.Current:
            return "CURRENT";

           case WatchTargetChangeState.NoChange:
            return "NO_CHANGE";

           case WatchTargetChangeState.Removed:
            return "REMOVE";

           case WatchTargetChangeState.Reset:
            return "RESET";

           default:
            return fail("Unknown WatchTargetChangeState: " + state);
          }
        };
        JsonProtoSerializer.prototype.toTestWatchChange = function(watchChange) {
          if (watchChange instanceof ExistenceFilterChange) return {
            filter: {
              count: watchChange.existenceFilter.count,
              targetId: watchChange.targetId
            }
          };
          if (watchChange instanceof DocumentWatchChange) {
            if (watchChange.newDoc instanceof Document) {
              var doc = watchChange.newDoc;
              return {
                documentChange: {
                  document: {
                    name: this.toName(doc.key),
                    fields: this.toFields(doc.data),
                    updateTime: this.toVersion(doc.version)
                  },
                  targetIds: watchChange.updatedTargetIds,
                  removedTargetIds: watchChange.removedTargetIds
                }
              };
            }
            if (watchChange.newDoc instanceof NoDocument) {
              var doc = watchChange.newDoc;
              return {
                documentDelete: {
                  document: this.toName(doc.key),
                  readTime: this.toVersion(doc.version),
                  removedTargetIds: watchChange.removedTargetIds
                }
              };
            }
            if (null === watchChange.newDoc) return {
              documentRemove: {
                document: this.toName(watchChange.key),
                removedTargetIds: watchChange.removedTargetIds
              }
            };
          }
          if (watchChange instanceof WatchTargetChange) {
            var cause = void 0;
            watchChange.cause && (cause = {
              code: mapRpcCodeFromCode(watchChange.cause.code),
              message: watchChange.cause.message
            });
            return {
              targetChange: {
                targetChangeType: this.toWatchTargetChangeState(watchChange.state),
                targetIds: watchChange.targetIds,
                resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),
                cause: cause
              }
            };
          }
          return fail("Unrecognized watch change: " + JSON.stringify(watchChange));
        };
        JsonProtoSerializer.prototype.fromWatchChange = function(change) {
          var type = change["response_type"];
          var watchChange;
          if (hasTag(change, type, "targetChange")) {
            assertPresent(change.targetChange, "targetChange");
            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || "NO_CHANGE");
            var targetIds = change.targetChange.targetIds || [];
            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();
            var causeProto = change.targetChange.cause;
            var cause = causeProto && this.fromRpcStatus(causeProto);
            watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);
          } else if (hasTag(change, type, "documentChange")) {
            assertPresent(change.documentChange, "documentChange");
            assertPresent(change.documentChange.document, "documentChange.name");
            assertPresent(change.documentChange.document.name, "documentChange.document.name");
            assertPresent(change.documentChange.document.updateTime, "documentChange.document.updateTime");
            var entityChange = change.documentChange;
            var key = this.fromName(entityChange.document.name);
            var version = this.fromVersion(entityChange.document.updateTime);
            var fields = this.fromFields(entityChange.document.fields || {});
            var doc = new Document(key, version, fields, {
              hasLocalMutations: false
            });
            var updatedTargetIds = entityChange.targetIds || [];
            var removedTargetIds = entityChange.removedTargetIds || [];
            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);
          } else if (hasTag(change, type, "documentDelete")) {
            assertPresent(change.documentDelete, "documentDelete");
            assertPresent(change.documentDelete.document, "documentDelete.document");
            var docDelete = change.documentDelete;
            var key = this.fromName(docDelete.document);
            var version = docDelete.readTime ? this.fromVersion(docDelete.readTime) : SnapshotVersion.forDeletedDoc();
            var doc = new NoDocument(key, version);
            var removedTargetIds = docDelete.removedTargetIds || [];
            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);
          } else if (hasTag(change, type, "documentRemove")) {
            assertPresent(change.documentRemove, "documentRemove");
            assertPresent(change.documentRemove.document, "documentRemove");
            var docRemove = change.documentRemove;
            var key = this.fromName(docRemove.document);
            var removedTargetIds = docRemove.removedTargetIds || [];
            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
          } else {
            if (!hasTag(change, type, "filter")) return fail("Unknown change type " + JSON.stringify(change));
            assertPresent(change.filter, "filter");
            assertPresent(change.filter.targetId, "filter.targetId");
            var filter = change.filter;
            var count = filter.count || 0;
            var existenceFilter = new ExistenceFilter(count);
            var targetId = filter.targetId;
            watchChange = new ExistenceFilterChange(targetId, existenceFilter);
          }
          return watchChange;
        };
        JsonProtoSerializer.prototype.fromWatchTargetChangeState = function(state) {
          return "NO_CHANGE" === state ? WatchTargetChangeState.NoChange : "ADD" === state ? WatchTargetChangeState.Added : "REMOVE" === state ? WatchTargetChangeState.Removed : "CURRENT" === state ? WatchTargetChangeState.Current : "RESET" === state ? WatchTargetChangeState.Reset : fail("Got unexpected TargetChange.state: " + state);
        };
        JsonProtoSerializer.prototype.versionFromListenResponse = function(change) {
          var type = change["response_type"];
          if (!hasTag(change, type, "targetChange")) return SnapshotVersion.MIN;
          var targetChange = change.targetChange;
          if (targetChange.targetIds && targetChange.targetIds.length) return SnapshotVersion.MIN;
          if (!targetChange.readTime) return SnapshotVersion.MIN;
          return this.fromVersion(targetChange.readTime);
        };
        JsonProtoSerializer.prototype.toMutation = function(mutation) {
          var _this = this;
          var result;
          if (mutation instanceof SetMutation) result = {
            update: this.toMutationDocument(mutation.key, mutation.value)
          }; else if (mutation instanceof DeleteMutation) result = {
            delete: this.toName(mutation.key)
          }; else if (mutation instanceof PatchMutation) result = {
            update: this.toMutationDocument(mutation.key, mutation.data),
            updateMask: this.toDocumentMask(mutation.fieldMask)
          }; else {
            if (!(mutation instanceof TransformMutation)) return fail("Unknown mutation type " + mutation.type);
            result = {
              transform: {
                document: this.toName(mutation.key),
                fieldTransforms: mutation.fieldTransforms.map(function(transform) {
                  return _this.toFieldTransform(transform);
                })
              }
            };
          }
          mutation.precondition.isNone || (result.currentDocument = this.toPrecondition(mutation.precondition));
          return result;
        };
        JsonProtoSerializer.prototype.fromMutation = function(proto) {
          var _this = this;
          var precondition = proto.currentDocument ? this.fromPrecondition(proto.currentDocument) : Precondition.NONE;
          if (proto.update) {
            assertPresent(proto.update.name, "name");
            var key = this.fromName(proto.update.name);
            var value = this.fromFields(proto.update.fields || {});
            if (proto.updateMask) {
              var fieldMask = this.fromDocumentMask(proto.updateMask);
              return new PatchMutation(key, value, fieldMask, precondition);
            }
            return new SetMutation(key, value, precondition);
          }
          if (proto.delete) {
            var key = this.fromName(proto.delete);
            return new DeleteMutation(key, precondition);
          }
          if (proto.transform) {
            var key = this.fromName(proto.transform.document);
            var fieldTransforms = proto.transform.fieldTransforms.map(function(transform) {
              return _this.fromFieldTransform(transform);
            });
            assert(true === precondition.exists, 'Transforms only support precondition "exists == true"');
            return new TransformMutation(key, fieldTransforms);
          }
          return fail("unknown mutation proto: " + JSON.stringify(proto));
        };
        JsonProtoSerializer.prototype.toPrecondition = function(precondition) {
          assert(!precondition.isNone, "Can't serialize an empty precondition");
          return void 0 !== precondition.updateTime ? {
            updateTime: this.toVersion(precondition.updateTime)
          } : void 0 !== precondition.exists ? {
            exists: precondition.exists
          } : fail("Unknown precondition");
        };
        JsonProtoSerializer.prototype.fromPrecondition = function(precondition) {
          return void 0 !== precondition.updateTime ? Precondition.updateTime(this.fromVersion(precondition.updateTime)) : void 0 !== precondition.exists ? Precondition.exists(precondition.exists) : Precondition.NONE;
        };
        JsonProtoSerializer.prototype.fromWriteResult = function(proto) {
          var _this = this;
          var version = proto.updateTime ? this.fromVersion(proto.updateTime) : null;
          var transformResults = null;
          proto.transformResults && proto.transformResults.length > 0 && (transformResults = proto.transformResults.map(function(result) {
            return _this.fromValue(result);
          }));
          return new MutationResult(version, transformResults);
        };
        JsonProtoSerializer.prototype.fromWriteResults = function(protos) {
          var _this = this;
          return (protos || []).map(function(proto) {
            return _this.fromWriteResult(proto);
          });
        };
        JsonProtoSerializer.prototype.toFieldTransform = function(fieldTransform) {
          var _this = this;
          var transform = fieldTransform.transform;
          if (transform instanceof ServerTimestampTransform) return {
            fieldPath: fieldTransform.field.canonicalString(),
            setToServerValue: "REQUEST_TIME"
          };
          if (transform instanceof ArrayUnionTransformOperation) return {
            fieldPath: fieldTransform.field.canonicalString(),
            appendMissingElements: {
              values: transform.elements.map(function(v) {
                return _this.toValue(v);
              })
            }
          };
          if (transform instanceof ArrayRemoveTransformOperation) return {
            fieldPath: fieldTransform.field.canonicalString(),
            removeAllFromArray: {
              values: transform.elements.map(function(v) {
                return _this.toValue(v);
              })
            }
          };
          fail("Unknown transform: " + fieldTransform.transform);
        };
        JsonProtoSerializer.prototype.fromFieldTransform = function(proto) {
          var _this = this;
          var type = proto["transform_type"];
          var transform = null;
          if (hasTag(proto, type, "setToServerValue")) {
            assert("REQUEST_TIME" === proto.setToServerValue, "Unknown server value transform proto: " + JSON.stringify(proto));
            transform = ServerTimestampTransform.instance;
          } else if (hasTag(proto, type, "appendMissingElements")) {
            var values = proto.appendMissingElements.values || [];
            transform = new ArrayUnionTransformOperation(values.map(function(v) {
              return _this.fromValue(v);
            }));
          } else if (hasTag(proto, type, "removeAllFromArray")) {
            var values = proto.removeAllFromArray.values || [];
            transform = new ArrayRemoveTransformOperation(values.map(function(v) {
              return _this.fromValue(v);
            }));
          } else fail("Unknown transform proto: " + JSON.stringify(proto));
          var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);
          return new FieldTransform(fieldPath, transform);
        };
        JsonProtoSerializer.prototype.toDocumentsTarget = function(query) {
          return {
            documents: [ this.toQueryPath(query.path) ]
          };
        };
        JsonProtoSerializer.prototype.fromDocumentsTarget = function(documentsTarget) {
          var count = documentsTarget.documents.length;
          assert(1 === count, "DocumentsTarget contained other than 1 document: " + count);
          var name = documentsTarget.documents[0];
          return Query.atPath(this.fromQueryPath(name));
        };
        JsonProtoSerializer.prototype.toQueryTarget = function(query) {
          var result = {
            structuredQuery: {}
          };
          if (query.path.isEmpty()) result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH); else {
            var path = query.path;
            assert(path.length % 2 !== 0, "Document queries with filters are not supported.");
            result.parent = this.toQueryPath(path.popLast());
            result.structuredQuery.from = [ {
              collectionId: path.lastSegment()
            } ];
          }
          var where = this.toFilter(query.filters);
          where && (result.structuredQuery.where = where);
          var orderBy = this.toOrder(query.orderBy);
          orderBy && (result.structuredQuery.orderBy = orderBy);
          var limit = this.toInt32Value(query.limit);
          void 0 !== limit && (result.structuredQuery.limit = limit);
          query.startAt && (result.structuredQuery.startAt = this.toCursor(query.startAt));
          query.endAt && (result.structuredQuery.endAt = this.toCursor(query.endAt));
          return result;
        };
        JsonProtoSerializer.prototype.fromQueryTarget = function(target) {
          var path = this.fromQueryPath(target.parent);
          var query = target.structuredQuery;
          var fromCount = query.from ? query.from.length : 0;
          if (fromCount > 0) {
            assert(1 === fromCount, "StructuredQuery.from with more than one collection is not supported.");
            var from = query.from[0];
            path = path.child(from.collectionId);
          }
          var filterBy = [];
          query.where && (filterBy = this.fromFilter(query.where));
          var orderBy = [];
          query.orderBy && (orderBy = this.fromOrder(query.orderBy));
          var limit = null;
          query.limit && (limit = this.fromInt32Value(query.limit));
          var startAt = null;
          query.startAt && (startAt = this.fromCursor(query.startAt));
          var endAt = null;
          query.endAt && (endAt = this.fromCursor(query.endAt));
          return new Query(path, orderBy, filterBy, limit, startAt, endAt);
        };
        JsonProtoSerializer.prototype.toListenRequestLabels = function(queryData) {
          var value = this.toLabel(queryData.purpose);
          return null == value ? null : {
            "goog-listen-tags": value
          };
        };
        JsonProtoSerializer.prototype.toLabel = function(purpose) {
          switch (purpose) {
           case QueryPurpose.Listen:
            return null;

           case QueryPurpose.ExistenceFilterMismatch:
            return "existence-filter-mismatch";

           case QueryPurpose.LimboResolution:
            return "limbo-document";

           default:
            return fail("Unrecognized query purpose: " + purpose);
          }
        };
        JsonProtoSerializer.prototype.toTarget = function(queryData) {
          var result;
          var query = queryData.query;
          result = query.isDocumentQuery() ? {
            documents: this.toDocumentsTarget(query)
          } : {
            query: this.toQueryTarget(query)
          };
          result.targetId = queryData.targetId;
          queryData.resumeToken.length > 0 && (result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken));
          return result;
        };
        JsonProtoSerializer.prototype.toFilter = function(filters) {
          var _this = this;
          if (0 === filters.length) return;
          var protos = filters.map(function(filter) {
            return filter instanceof RelationFilter ? _this.toRelationFilter(filter) : _this.toUnaryFilter(filter);
          });
          if (1 === protos.length) return protos[0];
          return {
            compositeFilter: {
              op: "AND",
              filters: protos
            }
          };
        };
        JsonProtoSerializer.prototype.fromFilter = function(filter) {
          var _this = this;
          return filter ? void 0 !== filter.unaryFilter ? [ this.fromUnaryFilter(filter) ] : void 0 !== filter.fieldFilter ? [ this.fromRelationFilter(filter) ] : void 0 !== filter.compositeFilter ? filter.compositeFilter.filters.map(function(f) {
            return _this.fromFilter(f);
          }).reduce(function(accum, current) {
            return accum.concat(current);
          }) : fail("Unknown filter: " + JSON.stringify(filter)) : [];
        };
        JsonProtoSerializer.prototype.toOrder = function(orderBys) {
          var _this = this;
          if (0 === orderBys.length) return;
          return orderBys.map(function(order) {
            return _this.toPropertyOrder(order);
          });
        };
        JsonProtoSerializer.prototype.fromOrder = function(orderBys) {
          var _this = this;
          return orderBys.map(function(order) {
            return _this.fromPropertyOrder(order);
          });
        };
        JsonProtoSerializer.prototype.toCursor = function(cursor) {
          var _this = this;
          return {
            before: cursor.before,
            values: cursor.position.map(function(component) {
              return _this.toValue(component);
            })
          };
        };
        JsonProtoSerializer.prototype.fromCursor = function(cursor) {
          var _this = this;
          var before = !!cursor.before;
          var position = cursor.values.map(function(component) {
            return _this.fromValue(component);
          });
          return new Bound(position, before);
        };
        JsonProtoSerializer.prototype.toDirection = function(dir) {
          return DIRECTIONS[dir.name];
        };
        JsonProtoSerializer.prototype.fromDirection = function(dir) {
          switch (dir) {
           case "ASCENDING":
            return Direction.ASCENDING;

           case "DESCENDING":
            return Direction.DESCENDING;

           default:
            return;
          }
        };
        JsonProtoSerializer.prototype.toOperatorName = function(op) {
          return OPERATORS[op.name];
        };
        JsonProtoSerializer.prototype.fromOperatorName = function(op) {
          switch (op) {
           case "EQUAL":
            return RelationOp.EQUAL;

           case "GREATER_THAN":
            return RelationOp.GREATER_THAN;

           case "GREATER_THAN_OR_EQUAL":
            return RelationOp.GREATER_THAN_OR_EQUAL;

           case "LESS_THAN":
            return RelationOp.LESS_THAN;

           case "LESS_THAN_OR_EQUAL":
            return RelationOp.LESS_THAN_OR_EQUAL;

           case "ARRAY_CONTAINS":
            return RelationOp.ARRAY_CONTAINS;

           case "OPERATOR_UNSPECIFIED":
            return fail("Unspecified relation");

           default:
            return fail("Unknown relation");
          }
        };
        JsonProtoSerializer.prototype.toFieldPathReference = function(path) {
          return {
            fieldPath: path.canonicalString()
          };
        };
        JsonProtoSerializer.prototype.fromFieldPathReference = function(fieldReference) {
          return FieldPath.fromServerFormat(fieldReference.fieldPath);
        };
        JsonProtoSerializer.prototype.toPropertyOrder = function(orderBy) {
          return {
            field: this.toFieldPathReference(orderBy.field),
            direction: this.toDirection(orderBy.dir)
          };
        };
        JsonProtoSerializer.prototype.fromPropertyOrder = function(orderBy) {
          return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));
        };
        JsonProtoSerializer.prototype.toRelationFilter = function(filter) {
          return filter instanceof RelationFilter ? {
            fieldFilter: {
              field: this.toFieldPathReference(filter.field),
              op: this.toOperatorName(filter.op),
              value: this.toValue(filter.value)
            }
          } : fail("Unrecognized filter: " + JSON.stringify(filter));
        };
        JsonProtoSerializer.prototype.fromRelationFilter = function(filter) {
          return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));
        };
        JsonProtoSerializer.prototype.toUnaryFilter = function(filter) {
          return filter instanceof NanFilter ? {
            unaryFilter: {
              field: this.toFieldPathReference(filter.field),
              op: "IS_NAN"
            }
          } : filter instanceof NullFilter ? {
            unaryFilter: {
              field: this.toFieldPathReference(filter.field),
              op: "IS_NULL"
            }
          } : fail("Unrecognized filter: " + JSON.stringify(filter));
        };
        JsonProtoSerializer.prototype.fromUnaryFilter = function(filter) {
          switch (filter.unaryFilter.op) {
           case "IS_NAN":
            var nanField = this.fromFieldPathReference(filter.unaryFilter.field);
            return new NanFilter(nanField);

           case "IS_NULL":
            var nullField = this.fromFieldPathReference(filter.unaryFilter.field);
            return new NullFilter(nullField);

           case "OPERATOR_UNSPECIFIED":
            return fail("Unspecified filter");

           default:
            return fail("Unknown filter");
          }
        };
        JsonProtoSerializer.prototype.toDocumentMask = function(fieldMask) {
          return {
            fieldPaths: fieldMask.fields.map(function(field) {
              return field.canonicalString();
            })
          };
        };
        JsonProtoSerializer.prototype.fromDocumentMask = function(proto) {
          var paths = proto.fieldPaths || [];
          var fields = paths.map(function(path) {
            return FieldPath.fromServerFormat(path);
          });
          return new FieldMask(fields);
        };
        return JsonProtoSerializer;
      }();
      function hasTag(obj, type, tag) {
        return type === tag || !type && tag in obj;
      }
      var isReactNative = function() {
        return "object" === typeof navigator && "ReactNative" === navigator["product"];
      };
      var ERROR_NAME = "FirebaseError";
      var captureStackTrace = Error.captureStackTrace;
      var FirebaseError = function() {
        function FirebaseError(code, message) {
          this.code = code;
          this.message = message;
          if (captureStackTrace) captureStackTrace(this, ErrorFactory.prototype.create); else try {
            throw Error.apply(this, arguments);
          } catch (err) {
            this.name = ERROR_NAME;
            Object.defineProperty(this, "stack", {
              get: function() {
                return err.stack;
              }
            });
          }
        }
        return FirebaseError;
      }();
      FirebaseError.prototype = Object.create(Error.prototype);
      FirebaseError.prototype.constructor = FirebaseError;
      FirebaseError.prototype.name = ERROR_NAME;
      var ErrorFactory = function() {
        function ErrorFactory(service, serviceName, errors) {
          this.service = service;
          this.serviceName = serviceName;
          this.errors = errors;
          this.pattern = /\{\$([^}]+)}/g;
        }
        ErrorFactory.prototype.create = function(code, data) {
          void 0 === data && (data = {});
          var template = this.errors[code];
          var fullCode = this.service + "/" + code;
          var message;
          message = void 0 === template ? "Error" : template.replace(this.pattern, function(match, key) {
            var value = data[key];
            return void 0 !== value ? value.toString() : "<" + key + "?>";
          });
          message = this.serviceName + ": " + message + " (" + fullCode + ").";
          var err = new FirebaseError(fullCode, message);
          for (var prop in data) {
            if (!data.hasOwnProperty(prop) || "_" === prop.slice(-1)) continue;
            err[prop] = data[prop];
          }
          return err;
        };
        return ErrorFactory;
      }();
      var Hash = function() {
        function Hash() {
          this.blockSize = -1;
        }
        return Hash;
      }();
      var Sha1 = function(_super) {
        tslib_1.__extends(Sha1, _super);
        function Sha1() {
          var _this = _super.call(this) || this;
          _this.chain_ = [];
          _this.buf_ = [];
          _this.W_ = [];
          _this.pad_ = [];
          _this.inbuf_ = 0;
          _this.total_ = 0;
          _this.blockSize = 64;
          _this.pad_[0] = 128;
          for (var i = 1; i < _this.blockSize; ++i) _this.pad_[i] = 0;
          _this.reset();
          return _this;
        }
        Sha1.prototype.reset = function() {
          this.chain_[0] = 1732584193;
          this.chain_[1] = 4023233417;
          this.chain_[2] = 2562383102;
          this.chain_[3] = 271733878;
          this.chain_[4] = 3285377520;
          this.inbuf_ = 0;
          this.total_ = 0;
        };
        Sha1.prototype.compress_ = function(buf, opt_offset) {
          opt_offset || (opt_offset = 0);
          var W = this.W_;
          if ("string" === typeof buf) for (var i = 0; i < 16; i++) {
            W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
            opt_offset += 4;
          } else for (var i = 0; i < 16; i++) {
            W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
            opt_offset += 4;
          }
          for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = 4294967295 & (t << 1 | t >>> 31);
          }
          var a = this.chain_[0];
          var b = this.chain_[1];
          var c = this.chain_[2];
          var d = this.chain_[3];
          var e = this.chain_[4];
          var f, k;
          for (var i = 0; i < 80; i++) {
            if (i < 40) if (i < 20) {
              f = d ^ b & (c ^ d);
              k = 1518500249;
            } else {
              f = b ^ c ^ d;
              k = 1859775393;
            } else if (i < 60) {
              f = b & c | d & (b | c);
              k = 2400959708;
            } else {
              f = b ^ c ^ d;
              k = 3395469782;
            }
            var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
            e = d;
            d = c;
            c = 4294967295 & (b << 30 | b >>> 2);
            b = a;
            a = t;
          }
          this.chain_[0] = this.chain_[0] + a & 4294967295;
          this.chain_[1] = this.chain_[1] + b & 4294967295;
          this.chain_[2] = this.chain_[2] + c & 4294967295;
          this.chain_[3] = this.chain_[3] + d & 4294967295;
          this.chain_[4] = this.chain_[4] + e & 4294967295;
        };
        Sha1.prototype.update = function(bytes, opt_length) {
          if (null == bytes) return;
          void 0 === opt_length && (opt_length = bytes.length);
          var lengthMinusBlock = opt_length - this.blockSize;
          var n = 0;
          var buf = this.buf_;
          var inbuf = this.inbuf_;
          while (n < opt_length) {
            if (0 == inbuf) while (n <= lengthMinusBlock) {
              this.compress_(bytes, n);
              n += this.blockSize;
            }
            if ("string" === typeof bytes) while (n < opt_length) {
              buf[inbuf] = bytes.charCodeAt(n);
              ++inbuf;
              ++n;
              if (inbuf == this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            } else while (n < opt_length) {
              buf[inbuf] = bytes[n];
              ++inbuf;
              ++n;
              if (inbuf == this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          }
          this.inbuf_ = inbuf;
          this.total_ += opt_length;
        };
        Sha1.prototype.digest = function() {
          var digest = [];
          var totalBits = 8 * this.total_;
          this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
          for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = 255 & totalBits;
            totalBits /= 256;
          }
          this.compress_(this.buf_);
          var n = 0;
          for (var i = 0; i < 5; i++) for (var j = 24; j >= 0; j -= 8) {
            digest[n] = this.chain_[i] >> j & 255;
            ++n;
          }
          return digest;
        };
        return Sha1;
      }(Hash);
      var StreamBridge = function() {
        function StreamBridge(args) {
          this.sendFn = args.sendFn;
          this.closeFn = args.closeFn;
        }
        StreamBridge.prototype.onOpen = function(callback) {
          assert(!this.wrappedOnOpen, "Called onOpen on stream twice!");
          this.wrappedOnOpen = callback;
        };
        StreamBridge.prototype.onClose = function(callback) {
          assert(!this.wrappedOnClose, "Called onClose on stream twice!");
          this.wrappedOnClose = callback;
        };
        StreamBridge.prototype.onMessage = function(callback) {
          assert(!this.wrappedOnMessage, "Called onMessage on stream twice!");
          this.wrappedOnMessage = callback;
        };
        StreamBridge.prototype.close = function() {
          this.closeFn();
        };
        StreamBridge.prototype.send = function(msg) {
          this.sendFn(msg);
        };
        StreamBridge.prototype.callOnOpen = function() {
          assert(void 0 !== this.wrappedOnOpen, "Cannot call onOpen because no callback was set");
          this.wrappedOnOpen();
        };
        StreamBridge.prototype.callOnClose = function(err) {
          assert(void 0 !== this.wrappedOnClose, "Cannot call onClose because no callback was set");
          this.wrappedOnClose(err);
        };
        StreamBridge.prototype.callOnMessage = function(msg) {
          assert(void 0 !== this.wrappedOnMessage, "Cannot call onMessage because no callback was set");
          this.wrappedOnMessage(msg);
        };
        return StreamBridge;
      }();
      var LOG_TAG = "Connection";
      var RPC_STREAM_SERVICE = "google.firestore.v1beta1.Firestore";
      var RPC_URL_VERSION = "v1beta1";
      var RPC_NAME_REST_MAPPING = {
        BatchGetDocuments: "batchGet",
        Commit: "commit"
      };
      var X_GOOG_API_CLIENT_VALUE = "gl-js/ fire/" + SDK_VERSION;
      var XHR_TIMEOUT_SECS = 15;
      var WebChannelConnection = function() {
        function WebChannelConnection(info) {
          this.databaseId = info.databaseId;
          this.pool = new webchannelWrapper.XhrIoPool();
          var proto = info.ssl ? "https" : "http";
          this.baseUrl = proto + "://" + info.host;
        }
        WebChannelConnection.prototype.modifyHeadersForRequest = function(headers, token) {
          if (token) for (var header in token.authHeaders) token.authHeaders.hasOwnProperty(header) && (headers[header] = token.authHeaders[header]);
          headers["X-Goog-Api-Client"] = X_GOOG_API_CLIENT_VALUE;
        };
        WebChannelConnection.prototype.invokeRPC = function(rpcName, request, token) {
          var _this = this;
          var url = this.makeUrl(rpcName);
          return new Promise(function(resolve, reject) {
            _this.pool.getObject(function(xhr) {
              xhr.listenOnce(webchannelWrapper.EventType.COMPLETE, function() {
                try {
                  switch (xhr.getLastErrorCode()) {
                   case webchannelWrapper.ErrorCode.NO_ERROR:
                    var json = xhr.getResponseJson();
                    debug(LOG_TAG, "XHR received:", JSON.stringify(json));
                    resolve(json);
                    break;

                   case webchannelWrapper.ErrorCode.TIMEOUT:
                    debug(LOG_TAG, 'RPC "' + rpcName + '" timed out');
                    reject(new FirestoreError(Code.DEADLINE_EXCEEDED, "Request time out"));
                    break;

                   case webchannelWrapper.ErrorCode.HTTP_ERROR:
                    var status_1 = xhr.getStatus();
                    debug(LOG_TAG, 'RPC "' + rpcName + '" failed with status:', status_1, "response text:", xhr.getResponseText());
                    if (status_1 > 0) reject(new FirestoreError(mapCodeFromHttpStatus(status_1), "Server responded with status " + xhr.getStatusText())); else {
                      debug(LOG_TAG, 'RPC "' + rpcName + '" failed');
                      reject(new FirestoreError(Code.UNAVAILABLE, "Connection failed."));
                    }
                    break;

                   default:
                    fail('RPC "' + rpcName + '" failed with unanticipated webchannel error ' + xhr.getLastErrorCode() + ": " + xhr.getLastError() + ", giving up.");
                  }
                } finally {
                  debug(LOG_TAG, 'RPC "' + rpcName + '" completed.');
                  _this.pool.releaseObject(xhr);
                }
              });
              var requestString = JSON.stringify(request);
              debug(LOG_TAG, "XHR sending: ", url + " " + requestString);
              var headers = {
                "Content-Type": "text/plain"
              };
              _this.modifyHeadersForRequest(headers, token);
              xhr.send(url, "POST", requestString, headers, XHR_TIMEOUT_SECS);
            });
          });
        };
        WebChannelConnection.prototype.invokeStreamingRPC = function(rpcName, request, token) {
          return this.invokeRPC(rpcName, request, token);
        };
        WebChannelConnection.prototype.openStream = function(rpcName, token) {
          var urlParts = [ this.baseUrl, "/", RPC_STREAM_SERVICE, "/", rpcName, "/channel" ];
          var webchannelTransport = webchannelWrapper.createWebChannelTransport();
          var request = {
            backgroundChannelTest: true,
            httpSessionIdParam: "gsessionid",
            initMessageHeaders: {},
            messageUrlParams: {
              database: "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database
            },
            sendRawJson: true,
            supportsCrossDomainXhr: true
          };
          this.modifyHeadersForRequest(request.initMessageHeaders, token);
          isReactNative() || (request["httpHeadersOverwriteParam"] = "$httpHeaders");
          var url = urlParts.join("");
          debug(LOG_TAG, "Creating WebChannel: " + url + " " + request);
          var channel = webchannelTransport.createWebChannel(url, request);
          var opened = false;
          var closed = false;
          var streamBridge = new StreamBridge({
            sendFn: function(msg) {
              if (closed) debug(LOG_TAG, "Not sending because WebChannel is closed:", msg); else {
                if (!opened) {
                  debug(LOG_TAG, "Opening WebChannel transport.");
                  channel.open();
                  opened = true;
                }
                debug(LOG_TAG, "WebChannel sending:", msg);
                channel.send(msg);
              }
            },
            closeFn: function() {
              return channel.close();
            }
          });
          var unguardedEventListen = function(type, fn) {
            channel.listen(type, function(param) {
              try {
                fn(param);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 0);
              }
            });
          };
          unguardedEventListen(webchannelWrapper.WebChannel.EventType.OPEN, function() {
            closed || debug(LOG_TAG, "WebChannel transport opened.");
          });
          unguardedEventListen(webchannelWrapper.WebChannel.EventType.CLOSE, function() {
            if (!closed) {
              closed = true;
              debug(LOG_TAG, "WebChannel transport closed");
              streamBridge.callOnClose();
            }
          });
          unguardedEventListen(webchannelWrapper.WebChannel.EventType.ERROR, function(err) {
            if (!closed) {
              closed = true;
              debug(LOG_TAG, "WebChannel transport errored:", err);
              streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, "The operation could not be completed"));
            }
          });
          unguardedEventListen(webchannelWrapper.WebChannel.EventType.MESSAGE, function(msg) {
            if (!closed) {
              var msgData = msg.data[0];
              assert(!!msgData, "Got a webchannel message without data.");
              var error$$1 = msgData.error || msgData[0] && msgData[0].error;
              if (error$$1) {
                debug(LOG_TAG, "WebChannel received error:", error$$1);
                var status_2 = error$$1.status;
                var code = mapCodeFromRpcStatus(status_2);
                var message = error$$1.message;
                if (void 0 === code) {
                  code = Code.INTERNAL;
                  message = "Unknown error status: " + status_2 + " with message " + error$$1.message;
                }
                closed = true;
                streamBridge.callOnClose(new FirestoreError(code, message));
                channel.close();
              } else {
                debug(LOG_TAG, "WebChannel received:", msgData);
                streamBridge.callOnMessage(msgData);
              }
            }
          });
          setTimeout(function() {
            streamBridge.callOnOpen();
          }, 0);
          return streamBridge;
        };
        WebChannelConnection.prototype.makeUrl = function(rpcName) {
          var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];
          assert(void 0 !== urlRpcName, "Unknown REST mapping for: " + rpcName);
          var url = [ this.baseUrl, "/", RPC_URL_VERSION ];
          url.push("/projects/");
          url.push(this.databaseId.projectId);
          url.push("/databases/");
          url.push(this.databaseId.database);
          url.push("/documents");
          url.push(":");
          url.push(urlRpcName);
          return url.join("");
        };
        return WebChannelConnection;
      }();
      var BrowserPlatform = function() {
        function BrowserPlatform() {
          this.emptyByteString = "";
          this.base64Available = "undefined" !== typeof atob;
        }
        BrowserPlatform.prototype.loadConnection = function(databaseInfo) {
          return Promise.resolve(new WebChannelConnection(databaseInfo));
        };
        BrowserPlatform.prototype.newSerializer = function(databaseId) {
          return new JsonProtoSerializer(databaseId, {
            useProto3Json: true
          });
        };
        BrowserPlatform.prototype.formatJSON = function(value) {
          return JSON.stringify(value);
        };
        BrowserPlatform.prototype.atob = function(encoded) {
          return atob(encoded);
        };
        BrowserPlatform.prototype.btoa = function(raw) {
          return btoa(raw);
        };
        return BrowserPlatform;
      }();
      PlatformSupport.setPlatform(new BrowserPlatform());
      var FieldPath$1 = function() {
        function FieldPath$$1() {
          var fieldNames = [];
          for (var _i = 0; _i < arguments.length; _i++) fieldNames[_i] = arguments[_i];
          validateNamedArrayAtLeastNumberOfElements("FieldPath", fieldNames, "fieldNames", 1);
          for (var i = 0; i < fieldNames.length; ++i) {
            validateArgType("FieldPath", "string", i, fieldNames[i]);
            if (0 === fieldNames[i].length) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
          }
          this._internalPath = new FieldPath(fieldNames);
        }
        FieldPath$$1.documentId = function() {
          return FieldPath$$1._DOCUMENT_ID;
        };
        FieldPath$$1.prototype.isEqual = function(other) {
          if (!(other instanceof FieldPath$$1)) throw invalidClassError("isEqual", "FieldPath", 1, other);
          return this._internalPath.isEqual(other._internalPath);
        };
        FieldPath$$1._DOCUMENT_ID = new FieldPath$$1(FieldPath.keyField().canonicalString());
        return FieldPath$$1;
      }();
      var RESERVED = new RegExp("[~\\*/\\[\\]]");
      function fromDotSeparatedString(path) {
        var found = path.search(RESERVED);
        if (found >= 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not contain '~', '*', '/', '[', or ']'");
        try {
          return new (FieldPath$1.bind.apply(FieldPath$1, [ void 0 ].concat(path.split("."))))();
        } catch (e) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
        }
      }
      var OnlineState;
      (function(OnlineState) {
        OnlineState[OnlineState["Unknown"] = 0] = "Unknown";
        OnlineState[OnlineState["Online"] = 1] = "Online";
        OnlineState[OnlineState["Offline"] = 2] = "Offline";
      })(OnlineState || (OnlineState = {}));
      var DocumentSet = function() {
        function DocumentSet(comp) {
          this.comparator = comp ? function(d1, d2) {
            return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);
          } : function(d1, d2) {
            return DocumentKey.comparator(d1.key, d2.key);
          };
          this.keyedMap = documentMap();
          this.sortedSet = new SortedMap(this.comparator);
        }
        DocumentSet.emptySet = function(oldSet) {
          return new DocumentSet(oldSet.comparator);
        };
        DocumentSet.prototype.has = function(key) {
          return null != this.keyedMap.get(key);
        };
        DocumentSet.prototype.get = function(key) {
          return this.keyedMap.get(key);
        };
        DocumentSet.prototype.first = function() {
          return this.sortedSet.minKey();
        };
        DocumentSet.prototype.last = function() {
          return this.sortedSet.maxKey();
        };
        DocumentSet.prototype.isEmpty = function() {
          return this.sortedSet.isEmpty();
        };
        DocumentSet.prototype.indexOf = function(key) {
          var doc = this.keyedMap.get(key);
          return doc ? this.sortedSet.indexOf(doc) : -1;
        };
        Object.defineProperty(DocumentSet.prototype, "size", {
          get: function() {
            return this.sortedSet.size;
          },
          enumerable: true,
          configurable: true
        });
        DocumentSet.prototype.forEach = function(cb) {
          this.sortedSet.inorderTraversal(function(k, v) {
            cb(k);
            return false;
          });
        };
        DocumentSet.prototype.add = function(doc) {
          var set = this.delete(doc.key);
          return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));
        };
        DocumentSet.prototype.delete = function(key) {
          var doc = this.get(key);
          if (!doc) return this;
          return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));
        };
        DocumentSet.prototype.isEqual = function(other) {
          if (!(other instanceof DocumentSet)) return false;
          if (this.size !== other.size) return false;
          var thisIt = this.sortedSet.getIterator();
          var otherIt = other.sortedSet.getIterator();
          while (thisIt.hasNext()) {
            var thisDoc = thisIt.getNext().key;
            var otherDoc = otherIt.getNext().key;
            if (!thisDoc.isEqual(otherDoc)) return false;
          }
          return true;
        };
        DocumentSet.prototype.toString = function() {
          var docStrings = [];
          this.forEach(function(doc) {
            docStrings.push(doc.toString());
          });
          return 0 === docStrings.length ? "DocumentSet ()" : "DocumentSet (\n  " + docStrings.join("  \n") + "\n)";
        };
        DocumentSet.prototype.copy = function(keyedMap, sortedSet) {
          var newSet = new DocumentSet();
          newSet.comparator = this.comparator;
          newSet.keyedMap = keyedMap;
          newSet.sortedSet = sortedSet;
          return newSet;
        };
        return DocumentSet;
      }();
      var ObjectMap = function() {
        function ObjectMap(mapKeyFn) {
          this.mapKeyFn = mapKeyFn;
          this.inner = {};
        }
        ObjectMap.prototype.get = function(key) {
          var id = this.mapKeyFn(key);
          var matches = this.inner[id];
          if (void 0 === matches) return;
          for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];
            if (otherKey.isEqual(key)) return value;
          }
          return;
        };
        ObjectMap.prototype.has = function(key) {
          return void 0 !== this.get(key);
        };
        ObjectMap.prototype.set = function(key, value) {
          var id = this.mapKeyFn(key);
          var matches = this.inner[id];
          if (void 0 === matches) {
            this.inner[id] = [ [ key, value ] ];
            return;
          }
          for (var i = 0; i < matches.length; i++) if (matches[i][0].isEqual(key)) {
            matches[i] = [ key, value ];
            return;
          }
          matches.push([ key, value ]);
        };
        ObjectMap.prototype.delete = function(key) {
          var id = this.mapKeyFn(key);
          var matches = this.inner[id];
          if (void 0 === matches) return false;
          for (var i = 0; i < matches.length; i++) if (matches[i][0].isEqual(key)) {
            1 === matches.length ? delete this.inner[id] : matches.splice(i, 1);
            return true;
          }
          return false;
        };
        ObjectMap.prototype.forEach = function(fn) {
          forEach(this.inner, function(_, entries) {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
              var _a = entries_1[_i], k = _a[0], v = _a[1];
              fn(k, v);
            }
          });
        };
        ObjectMap.prototype.isEmpty = function() {
          return isEmpty(this.inner);
        };
        return ObjectMap;
      }();
      var QueryListenersInfo = function() {
        function QueryListenersInfo() {
          this.listeners = [];
        }
        return QueryListenersInfo;
      }();
      var EventManager = function() {
        function EventManager(syncEngine) {
          this.syncEngine = syncEngine;
          this.queries = new ObjectMap(function(q) {
            return q.canonicalId();
          });
          this.onlineState = OnlineState.Unknown;
          this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));
        }
        EventManager.prototype.listen = function(listener) {
          var query = listener.query;
          var firstListen = false;
          var queryInfo = this.queries.get(query);
          if (!queryInfo) {
            firstListen = true;
            queryInfo = new QueryListenersInfo();
            this.queries.set(query, queryInfo);
          }
          queryInfo.listeners.push(listener);
          listener.applyOnlineStateChange(this.onlineState);
          queryInfo.viewSnap && listener.onViewSnapshot(queryInfo.viewSnap);
          return firstListen ? this.syncEngine.listen(query).then(function(targetId) {
            queryInfo.targetId = targetId;
            return targetId;
          }) : Promise.resolve(queryInfo.targetId);
        };
        EventManager.prototype.unlisten = function(listener) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var query, lastListen, queryInfo, i;
            return tslib_1.__generator(this, function(_a) {
              query = listener.query;
              lastListen = false;
              queryInfo = this.queries.get(query);
              if (queryInfo) {
                i = queryInfo.listeners.indexOf(listener);
                if (i >= 0) {
                  queryInfo.listeners.splice(i, 1);
                  lastListen = 0 === queryInfo.listeners.length;
                }
              }
              if (lastListen) {
                this.queries.delete(query);
                return [ 2, this.syncEngine.unlisten(query) ];
              }
              return [ 2 ];
            });
          });
        };
        EventManager.prototype.onChange = function(viewSnaps) {
          for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
            var viewSnap = viewSnaps_1[_i];
            var query = viewSnap.query;
            var queryInfo = this.queries.get(query);
            if (queryInfo) {
              for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {
                var listener = _b[_a];
                listener.onViewSnapshot(viewSnap);
              }
              queryInfo.viewSnap = viewSnap;
            }
          }
        };
        EventManager.prototype.onError = function(query, error) {
          var queryInfo = this.queries.get(query);
          if (queryInfo) for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener.onError(error);
          }
          this.queries.delete(query);
        };
        EventManager.prototype.applyOnlineStateChange = function(onlineState) {
          this.onlineState = onlineState;
          this.queries.forEach(function(_, queryInfo) {
            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
              var listener = _a[_i];
              listener.applyOnlineStateChange(onlineState);
            }
          });
        };
        return EventManager;
      }();
      var QueryListener = function() {
        function QueryListener(query, queryObserver, options) {
          this.query = query;
          this.queryObserver = queryObserver;
          this.raisedInitialEvent = false;
          this.onlineState = OnlineState.Unknown;
          this.options = options || {};
        }
        QueryListener.prototype.onViewSnapshot = function(snap) {
          assert(snap.docChanges.length > 0 || snap.syncStateChanged, "We got a new snapshot with no changes?");
          if (!this.options.includeMetadataChanges) {
            var docChanges = [];
            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {
              var docChange = _a[_i];
              docChange.type !== ChangeType.Metadata && docChanges.push(docChange);
            }
            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.fromCache, snap.hasPendingWrites, snap.syncStateChanged, true);
          }
          this.raisedInitialEvent ? this.shouldRaiseEvent(snap) && this.queryObserver.next(snap) : this.shouldRaiseInitialEvent(snap, this.onlineState) && this.raiseInitialEvent(snap);
          this.snap = snap;
        };
        QueryListener.prototype.onError = function(error) {
          this.queryObserver.error(error);
        };
        QueryListener.prototype.applyOnlineStateChange = function(onlineState) {
          this.onlineState = onlineState;
          this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState) && this.raiseInitialEvent(this.snap);
        };
        QueryListener.prototype.shouldRaiseInitialEvent = function(snap, onlineState) {
          assert(!this.raisedInitialEvent, "Determining whether to raise first event but already had first event");
          if (!snap.fromCache) return true;
          var maybeOnline = onlineState !== OnlineState.Offline;
          if (this.options.waitForSyncWhenOnline && maybeOnline) {
            assert(snap.fromCache, "Waiting for sync, but snapshot is not from cache");
            return false;
          }
          return !snap.docs.isEmpty() || onlineState === OnlineState.Offline;
        };
        QueryListener.prototype.shouldRaiseEvent = function(snap) {
          if (snap.docChanges.length > 0) return true;
          var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
          if (snap.syncStateChanged || hasPendingWritesChanged) return true === this.options.includeMetadataChanges;
          return false;
        };
        QueryListener.prototype.raiseInitialEvent = function(snap) {
          assert(!this.raisedInitialEvent, "Trying to raise initial events for second time");
          snap = new ViewSnapshot(snap.query, snap.docs, DocumentSet.emptySet(snap.docs), QueryListener.getInitialViewChanges(snap), snap.fromCache, snap.hasPendingWrites, true, false);
          this.raisedInitialEvent = true;
          this.queryObserver.next(snap);
        };
        QueryListener.getInitialViewChanges = function(snap) {
          var result = [];
          snap.docs.forEach(function(doc) {
            result.push({
              type: ChangeType.Added,
              doc: doc
            });
          });
          return result;
        };
        return QueryListener;
      }();
      var PersistencePromise = function() {
        function PersistencePromise(callback) {
          var _this = this;
          this.nextCallback = null;
          this.catchCallback = null;
          this.result = void 0;
          this.error = void 0;
          this.isDone = false;
          this.callbackAttached = false;
          callback(function(value) {
            _this.isDone = true;
            _this.result = value;
            _this.nextCallback && _this.nextCallback(value);
          }, function(error) {
            _this.isDone = true;
            _this.error = error;
            _this.catchCallback && _this.catchCallback(error);
          });
        }
        PersistencePromise.prototype.catch = function(fn) {
          return this.next(void 0, fn);
        };
        PersistencePromise.prototype.next = function(nextFn, catchFn) {
          var _this = this;
          this.callbackAttached && fail("Called next() or catch() twice for PersistencePromise");
          this.callbackAttached = true;
          return this.isDone ? this.error ? this.wrapFailure(catchFn, this.error) : this.wrapSuccess(nextFn, this.result) : new PersistencePromise(function(resolve, reject) {
            _this.nextCallback = function(value) {
              _this.wrapSuccess(nextFn, value).next(resolve, reject);
            };
            _this.catchCallback = function(error) {
              _this.wrapFailure(catchFn, error).next(resolve, reject);
            };
          });
        };
        PersistencePromise.prototype.toPromise = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.next(resolve, reject);
          });
        };
        PersistencePromise.prototype.wrapUserFunction = function(fn) {
          try {
            var result = fn();
            return result instanceof PersistencePromise ? result : PersistencePromise.resolve(result);
          } catch (e) {
            return PersistencePromise.reject(e);
          }
        };
        PersistencePromise.prototype.wrapSuccess = function(nextFn, value) {
          return nextFn ? this.wrapUserFunction(function() {
            return nextFn(value);
          }) : PersistencePromise.resolve(value);
        };
        PersistencePromise.prototype.wrapFailure = function(catchFn, error) {
          return catchFn ? this.wrapUserFunction(function() {
            return catchFn(error);
          }) : PersistencePromise.reject(error);
        };
        PersistencePromise.resolve = function(result) {
          return new PersistencePromise(function(resolve, reject) {
            resolve(result);
          });
        };
        PersistencePromise.reject = function(error) {
          return new PersistencePromise(function(resolve, reject) {
            reject(error);
          });
        };
        PersistencePromise.waitFor = function(all) {
          var expectedCount = all.length;
          if (0 === expectedCount) return PersistencePromise.resolve();
          var resolvedCount = 0;
          return new PersistencePromise(function(resolve, reject) {
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
              var promise = all_1[_i];
              promise.next(function() {
                ++resolvedCount;
                resolvedCount === expectedCount && resolve();
              }, function(err) {
                return reject(err);
              });
            }
          });
        };
        PersistencePromise.map = function(all) {
          var results = [];
          var promises = [];
          var _loop_1 = function(i) {
            promises[i] = all[i].next(function(result) {
              results[i] = result;
            });
          };
          for (var i = 0; i < all.length; ++i) _loop_1(i);
          return PersistencePromise.waitFor(promises).next(function() {
            return results;
          });
        };
        return PersistencePromise;
      }();
      var EagerGarbageCollector = function() {
        function EagerGarbageCollector() {
          this.isEager = true;
          this.sources = [];
          this.potentialGarbage = documentKeySet();
        }
        EagerGarbageCollector.prototype.addGarbageSource = function(garbageSource) {
          this.sources.push(garbageSource);
          garbageSource.setGarbageCollector(this);
        };
        EagerGarbageCollector.prototype.removeGarbageSource = function(garbageSource) {
          this.sources.splice(this.sources.indexOf(garbageSource), 1);
          garbageSource.setGarbageCollector(null);
        };
        EagerGarbageCollector.prototype.addPotentialGarbageKey = function(key) {
          this.potentialGarbage = this.potentialGarbage.add(key);
        };
        EagerGarbageCollector.prototype.collectGarbage = function(txn) {
          var _this = this;
          var promises = [];
          var garbageKeys = documentKeySet();
          this.potentialGarbage.forEach(function(key) {
            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);
            promises.push(hasRefsPromise.next(function(hasRefs) {
              hasRefs || (garbageKeys = garbageKeys.add(key));
              return PersistencePromise.resolve();
            }));
          });
          this.potentialGarbage = documentKeySet();
          return PersistencePromise.waitFor(promises).next(function() {
            return garbageKeys;
          });
        };
        EagerGarbageCollector.prototype.documentHasAnyReferences = function(txn, key) {
          var initial = PersistencePromise.resolve(false);
          return this.sources.map(function(source) {
            return function() {
              return source.containsKey(txn, key);
            };
          }).reduce(function(promise, nextPromise) {
            return promise.next(function(result) {
              return result ? PersistencePromise.resolve(true) : nextPromise();
            });
          }, initial);
        };
        return EagerGarbageCollector;
      }();
      var LocalViewChanges = function() {
        function LocalViewChanges(targetId, addedKeys, removedKeys) {
          this.targetId = targetId;
          this.addedKeys = addedKeys;
          this.removedKeys = removedKeys;
        }
        LocalViewChanges.fromSnapshot = function(targetId, viewSnapshot) {
          var addedKeys = documentKeySet();
          var removedKeys = documentKeySet();
          for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {
            var docChange = _a[_i];
            switch (docChange.type) {
             case ChangeType.Added:
              addedKeys = addedKeys.add(docChange.doc.key);
              break;

             case ChangeType.Removed:
              removedKeys = removedKeys.add(docChange.doc.key);
            }
          }
          return new LocalViewChanges(targetId, addedKeys, removedKeys);
        };
        return LocalViewChanges;
      }();
      var ReferenceSet = function() {
        function ReferenceSet() {
          this.refsByKey = new SortedSet(DocReference.compareByKey);
          this.refsByTarget = new SortedSet(DocReference.compareByTargetId);
          this.garbageCollector = null;
        }
        ReferenceSet.prototype.isEmpty = function() {
          return this.refsByKey.isEmpty();
        };
        ReferenceSet.prototype.addReference = function(key, id) {
          var ref = new DocReference(key, id);
          this.refsByKey = this.refsByKey.add(ref);
          this.refsByTarget = this.refsByTarget.add(ref);
        };
        ReferenceSet.prototype.addReferences = function(keys, id) {
          var _this = this;
          keys.forEach(function(key) {
            return _this.addReference(key, id);
          });
        };
        ReferenceSet.prototype.removeReference = function(key, id) {
          this.removeRef(new DocReference(key, id));
        };
        ReferenceSet.prototype.removeReferences = function(keys, id) {
          var _this = this;
          keys.forEach(function(key) {
            return _this.removeReference(key, id);
          });
        };
        ReferenceSet.prototype.removeReferencesForId = function(id) {
          var _this = this;
          var emptyKey = DocumentKey.EMPTY;
          var startRef = new DocReference(emptyKey, id);
          var endRef = new DocReference(emptyKey, id + 1);
          this.refsByTarget.forEachInRange([ startRef, endRef ], function(ref) {
            _this.removeRef(ref);
          });
        };
        ReferenceSet.prototype.removeAllReferences = function() {
          var _this = this;
          this.refsByKey.forEach(function(ref) {
            return _this.removeRef(ref);
          });
        };
        ReferenceSet.prototype.removeRef = function(ref) {
          this.refsByKey = this.refsByKey.delete(ref);
          this.refsByTarget = this.refsByTarget.delete(ref);
          null !== this.garbageCollector && this.garbageCollector.addPotentialGarbageKey(ref.key);
        };
        ReferenceSet.prototype.referencesForId = function(id) {
          var emptyKey = DocumentKey.EMPTY;
          var startRef = new DocReference(emptyKey, id);
          var endRef = new DocReference(emptyKey, id + 1);
          var keys = documentKeySet();
          this.refsByTarget.forEachInRange([ startRef, endRef ], function(ref) {
            keys = keys.add(ref.key);
          });
          return keys;
        };
        ReferenceSet.prototype.setGarbageCollector = function(garbageCollector) {
          this.garbageCollector = garbageCollector;
        };
        ReferenceSet.prototype.containsKey = function(txn, key) {
          var ref = new DocReference(key, 0);
          var firstRef = this.refsByKey.firstAfterOrEqual(ref);
          return PersistencePromise.resolve(null !== firstRef && key.isEqual(firstRef.key));
        };
        return ReferenceSet;
      }();
      var DocReference = function() {
        function DocReference(key, targetOrBatchId) {
          this.key = key;
          this.targetOrBatchId = targetOrBatchId;
        }
        DocReference.compareByKey = function(left, right) {
          return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
        };
        DocReference.compareByTargetId = function(left, right) {
          return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);
        };
        return DocReference;
      }();
      var RESERVED_BITS = 1;
      var GeneratorIds;
      (function(GeneratorIds) {
        GeneratorIds[GeneratorIds["LocalStore"] = 0] = "LocalStore";
        GeneratorIds[GeneratorIds["SyncEngine"] = 1] = "SyncEngine";
      })(GeneratorIds || (GeneratorIds = {}));
      var TargetIdGenerator = function() {
        function TargetIdGenerator(generatorId, initAfter) {
          void 0 === initAfter && (initAfter = 0);
          this.generatorId = generatorId;
          var afterWithoutGenerator = initAfter >> RESERVED_BITS << RESERVED_BITS;
          var afterGenerator = initAfter - afterWithoutGenerator;
          this.previousId = afterGenerator >= generatorId ? afterWithoutGenerator | this.generatorId : (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);
        }
        TargetIdGenerator.prototype.next = function() {
          this.previousId += 1 << RESERVED_BITS;
          return this.previousId;
        };
        TargetIdGenerator.forLocalStore = function(initAfter) {
          void 0 === initAfter && (initAfter = 0);
          return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);
        };
        TargetIdGenerator.forSyncEngine = function() {
          return new TargetIdGenerator(GeneratorIds.SyncEngine);
        };
        return TargetIdGenerator;
      }();
      var AddedLimboDocument = function() {
        function AddedLimboDocument(key) {
          this.key = key;
        }
        return AddedLimboDocument;
      }();
      var RemovedLimboDocument = function() {
        function RemovedLimboDocument(key) {
          this.key = key;
        }
        return RemovedLimboDocument;
      }();
      var View = function() {
        function View(query, _syncedDocuments) {
          this.query = query;
          this._syncedDocuments = _syncedDocuments;
          this.syncState = null;
          this.current = false;
          this.limboDocuments = documentKeySet();
          this.mutatedKeys = documentKeySet();
          this.documentSet = new DocumentSet(query.docComparator.bind(query));
        }
        Object.defineProperty(View.prototype, "syncedDocuments", {
          get: function() {
            return this._syncedDocuments;
          },
          enumerable: true,
          configurable: true
        });
        View.prototype.computeDocChanges = function(docChanges, previousChanges) {
          var _this = this;
          var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();
          var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
          var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
          var newDocumentSet = oldDocumentSet;
          var needsRefill = false;
          var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
          docChanges.inorderTraversal(function(key, newMaybeDoc) {
            var oldDoc = oldDocumentSet.get(key);
            var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;
            if (newDoc) {
              assert(key.isEqual(newDoc.key), "Mismatching keys found in document changes: " + key + " != " + newDoc.key);
              newDoc = _this.query.matches(newDoc) ? newDoc : null;
            }
            if (newDoc) {
              newDocumentSet = newDocumentSet.add(newDoc);
              newMutatedKeys = newDoc.hasLocalMutations ? newMutatedKeys.add(key) : newMutatedKeys.delete(key);
            } else {
              newDocumentSet = newDocumentSet.delete(key);
              newMutatedKeys = newMutatedKeys.delete(key);
            }
            if (oldDoc && newDoc) {
              var docsEqual = oldDoc.data.isEqual(newDoc.data);
              if (!docsEqual || oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {
                docsEqual ? changeSet.track({
                  type: ChangeType.Metadata,
                  doc: newDoc
                }) : changeSet.track({
                  type: ChangeType.Modified,
                  doc: newDoc
                });
                lastDocInLimit && _this.query.docComparator(newDoc, lastDocInLimit) > 0 && (needsRefill = true);
              }
            } else if (!oldDoc && newDoc) changeSet.track({
              type: ChangeType.Added,
              doc: newDoc
            }); else if (oldDoc && !newDoc) {
              changeSet.track({
                type: ChangeType.Removed,
                doc: oldDoc
              });
              lastDocInLimit && (needsRefill = true);
            }
          });
          if (this.query.hasLimit()) while (newDocumentSet.size > this.query.limit) {
            var oldDoc = newDocumentSet.last();
            newDocumentSet = newDocumentSet.delete(oldDoc.key);
            changeSet.track({
              type: ChangeType.Removed,
              doc: oldDoc
            });
          }
          assert(!needsRefill || !previousChanges, "View was refilled using docs that themselves needed refilling.");
          return {
            documentSet: newDocumentSet,
            changeSet: changeSet,
            needsRefill: needsRefill,
            mutatedKeys: newMutatedKeys
          };
        };
        View.prototype.applyChanges = function(docChanges, targetChange) {
          var _this = this;
          assert(!docChanges.needsRefill, "Cannot apply changes that need a refill");
          var oldDocs = this.documentSet;
          this.documentSet = docChanges.documentSet;
          this.mutatedKeys = docChanges.mutatedKeys;
          var changes = docChanges.changeSet.getChanges();
          changes.sort(function(c1, c2) {
            return compareChangeType(c1.type, c2.type) || _this.query.docComparator(c1.doc, c2.doc);
          });
          this.applyTargetChange(targetChange);
          var limboChanges = this.updateLimboDocuments();
          var synced = 0 === this.limboDocuments.size && this.current;
          var newSyncState = synced ? SyncState.Synced : SyncState.Local;
          var syncStateChanged = newSyncState !== this.syncState;
          this.syncState = newSyncState;
          if (0 !== changes.length || syncStateChanged) {
            var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, newSyncState === SyncState.Local, !docChanges.mutatedKeys.isEmpty(), syncStateChanged, false);
            return {
              snapshot: snap,
              limboChanges: limboChanges
            };
          }
          return {
            limboChanges: limboChanges
          };
        };
        View.prototype.applyOnlineStateChange = function(onlineState) {
          if (this.current && onlineState === OnlineState.Offline) {
            this.current = false;
            return this.applyChanges({
              documentSet: this.documentSet,
              changeSet: new DocumentChangeSet(),
              mutatedKeys: this.mutatedKeys,
              needsRefill: false
            });
          }
          return {
            limboChanges: []
          };
        };
        View.prototype.shouldBeInLimbo = function(key) {
          if (this._syncedDocuments.has(key)) return false;
          if (!this.documentSet.has(key)) return false;
          if (this.documentSet.get(key).hasLocalMutations) return false;
          return true;
        };
        View.prototype.applyTargetChange = function(targetChange) {
          var _this = this;
          if (targetChange) {
            targetChange.addedDocuments.forEach(function(key) {
              return _this._syncedDocuments = _this._syncedDocuments.add(key);
            });
            targetChange.modifiedDocuments.forEach(function(key) {
              return assert(_this._syncedDocuments.has(key), "Modified document " + key + " not found in view.");
            });
            targetChange.removedDocuments.forEach(function(key) {
              return _this._syncedDocuments = _this._syncedDocuments.delete(key);
            });
            this.current = targetChange.current;
          }
        };
        View.prototype.updateLimboDocuments = function() {
          var _this = this;
          if (!this.current) return [];
          var oldLimboDocuments = this.limboDocuments;
          this.limboDocuments = documentKeySet();
          this.documentSet.forEach(function(doc) {
            _this.shouldBeInLimbo(doc.key) && (_this.limboDocuments = _this.limboDocuments.add(doc.key));
          });
          var changes = [];
          oldLimboDocuments.forEach(function(key) {
            _this.limboDocuments.has(key) || changes.push(new RemovedLimboDocument(key));
          });
          this.limboDocuments.forEach(function(key) {
            oldLimboDocuments.has(key) || changes.push(new AddedLimboDocument(key));
          });
          return changes;
        };
        return View;
      }();
      function compareChangeType(c1, c2) {
        var order = function(change) {
          switch (change) {
           case ChangeType.Added:
            return 1;

           case ChangeType.Modified:
           case ChangeType.Metadata:
            return 2;

           case ChangeType.Removed:
            return 0;

           default:
            return fail("Unknown ChangeType: " + change);
          }
        };
        return order(c1) - order(c2);
      }
      var LOG_TAG$1 = "SyncEngine";
      var QueryView = function() {
        function QueryView(query, targetId, view) {
          this.query = query;
          this.targetId = targetId;
          this.view = view;
        }
        return QueryView;
      }();
      var LimboResolution = function() {
        function LimboResolution(key) {
          this.key = key;
        }
        return LimboResolution;
      }();
      var SyncEngine = function() {
        function SyncEngine(localStore, remoteStore, currentUser) {
          this.localStore = localStore;
          this.remoteStore = remoteStore;
          this.currentUser = currentUser;
          this.viewHandler = null;
          this.errorHandler = null;
          this.queryViewsByQuery = new ObjectMap(function(q) {
            return q.canonicalId();
          });
          this.queryViewsByTarget = {};
          this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);
          this.limboResolutionsByTarget = {};
          this.limboDocumentRefs = new ReferenceSet();
          this.limboCollector = new EagerGarbageCollector();
          this.mutationUserCallbacks = {};
          this.targetIdGenerator = TargetIdGenerator.forSyncEngine();
          this.limboCollector.addGarbageSource(this.limboDocumentRefs);
        }
        SyncEngine.prototype.subscribe = function(viewHandler, errorHandler) {
          assert(null !== viewHandler && null !== errorHandler, "View and error handlers cannot be null");
          assert(null === this.viewHandler && null === this.errorHandler, "SyncEngine already has a subscriber.");
          this.viewHandler = viewHandler;
          this.errorHandler = errorHandler;
        };
        SyncEngine.prototype.listen = function(query) {
          var _this = this;
          this.assertSubscribed("listen()");
          assert(!this.queryViewsByQuery.has(query), "We already listen to the query: " + query);
          return this.localStore.allocateQuery(query).then(function(queryData) {
            return _this.localStore.executeQuery(query).then(function(docs) {
              return _this.localStore.remoteDocumentKeys(queryData.targetId).then(function(remoteKeys) {
                var view = new View(query, remoteKeys);
                var viewDocChanges = view.computeDocChanges(docs);
                var viewChange = view.applyChanges(viewDocChanges);
                assert(0 === viewChange.limboChanges.length, "View returned limbo docs before target ack from the server.");
                assert(!!viewChange.snapshot, "applyChanges for new view should always return a snapshot");
                var data = new QueryView(query, queryData.targetId, view);
                _this.queryViewsByQuery.set(query, data);
                _this.queryViewsByTarget[queryData.targetId] = data;
                _this.viewHandler([ viewChange.snapshot ]);
                _this.remoteStore.listen(queryData);
              });
            }).then(function() {
              return queryData.targetId;
            });
          });
        };
        SyncEngine.prototype.unlisten = function(query) {
          var _this = this;
          this.assertSubscribed("unlisten()");
          var queryView = this.queryViewsByQuery.get(query);
          assert(!!queryView, "Trying to unlisten on query not found:" + query);
          return this.localStore.releaseQuery(query).then(function() {
            _this.remoteStore.unlisten(queryView.targetId);
            return _this.removeAndCleanupQuery(queryView).then(function() {
              return _this.localStore.collectGarbage();
            });
          });
        };
        SyncEngine.prototype.write = function(batch, userCallback) {
          var _this = this;
          this.assertSubscribed("write()");
          return this.localStore.localWrite(batch).then(function(result) {
            _this.addMutationCallback(result.batchId, userCallback);
            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);
          }).then(function() {
            return _this.remoteStore.fillWritePipeline();
          });
        };
        SyncEngine.prototype.wrapUpdateFunctionError = function(error$$1) {
          return error$$1;
        };
        SyncEngine.prototype.runTransaction = function(updateFunction, retries) {
          var _this = this;
          void 0 === retries && (retries = 5);
          assert(retries >= 0, "Got negative number of retries for transaction.");
          var transaction = this.remoteStore.createTransaction();
          var wrappedUpdateFunction = function() {
            try {
              var userPromise = updateFunction(transaction);
              if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) return Promise.reject(Error("Transaction callback must return a Promise"));
              return userPromise.catch(function(e) {
                return Promise.reject(_this.wrapUpdateFunctionError(e));
              });
            } catch (e) {
              return Promise.reject(_this.wrapUpdateFunctionError(e));
            }
          };
          return wrappedUpdateFunction().then(function(result) {
            return transaction.commit().then(function() {
              return result;
            }).catch(function(error$$1) {
              if (0 === retries) return Promise.reject(error$$1);
              return _this.runTransaction(updateFunction, retries - 1);
            });
          });
        };
        SyncEngine.prototype.applyRemoteEvent = function(remoteEvent) {
          var _this = this;
          this.assertSubscribed("applyRemoteEvent()");
          forEach(remoteEvent.targetChanges, function(targetId, targetChange) {
            var limboResolution = _this.limboResolutionsByTarget[targetId];
            if (limboResolution) {
              assert(targetChange.addedDocuments.size + targetChange.modifiedDocuments.size + targetChange.removedDocuments.size <= 1, "Limbo resolution for single document contains multiple changes.");
              if (targetChange.addedDocuments.size > 0) limboResolution.receivedDocument = true; else if (targetChange.modifiedDocuments.size > 0) assert(limboResolution.receivedDocument, "Received change for limbo target document without add."); else if (targetChange.removedDocuments.size > 0) {
                assert(limboResolution.receivedDocument, "Received remove for limbo target document without add.");
                limboResolution.receivedDocument = false;
              }
            }
          });
          return this.localStore.applyRemoteEvent(remoteEvent).then(function(changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);
          });
        };
        SyncEngine.prototype.applyOnlineStateChange = function(onlineState) {
          var newViewSnapshots = [];
          this.queryViewsByQuery.forEach(function(query, queryView) {
            var viewChange = queryView.view.applyOnlineStateChange(onlineState);
            assert(0 === viewChange.limboChanges.length, "OnlineState should not affect limbo documents.");
            viewChange.snapshot && newViewSnapshots.push(viewChange.snapshot);
          });
          this.viewHandler(newViewSnapshots);
        };
        SyncEngine.prototype.rejectListen = function(targetId, err) {
          var _this = this;
          this.assertSubscribed("rejectListens()");
          var limboResolution = this.limboResolutionsByTarget[targetId];
          var limboKey = limboResolution && limboResolution.key;
          if (limboKey) {
            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);
            delete this.limboResolutionsByTarget[targetId];
            var documentUpdates = new SortedMap(DocumentKey.comparator);
            documentUpdates = documentUpdates.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));
            var resolvedLimboDocuments = documentKeySet().add(limboKey);
            var event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);
            return this.applyRemoteEvent(event_1);
          }
          var queryView_1 = this.queryViewsByTarget[targetId];
          assert(!!queryView_1, "Unknown targetId: " + targetId);
          return this.localStore.releaseQuery(queryView_1.query).then(function() {
            return _this.removeAndCleanupQuery(queryView_1).then(function() {
              _this.errorHandler(queryView_1.query, err);
            });
          });
        };
        SyncEngine.prototype.applySuccessfulWrite = function(mutationBatchResult) {
          var _this = this;
          this.assertSubscribed("applySuccessfulWrite()");
          this.processUserCallback(mutationBatchResult.batch.batchId, null);
          return this.localStore.acknowledgeBatch(mutationBatchResult).then(function(changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
          });
        };
        SyncEngine.prototype.rejectFailedWrite = function(batchId, error$$1) {
          var _this = this;
          this.assertSubscribed("rejectFailedWrite()");
          this.processUserCallback(batchId, error$$1);
          return this.localStore.rejectBatch(batchId).then(function(changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
          });
        };
        SyncEngine.prototype.addMutationCallback = function(batchId, callback) {
          var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];
          newCallbacks || (newCallbacks = new SortedMap(primitiveComparator));
          newCallbacks = newCallbacks.insert(batchId, callback);
          this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
        };
        SyncEngine.prototype.processUserCallback = function(batchId, error$$1) {
          var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];
          if (newCallbacks) {
            var callback = newCallbacks.get(batchId);
            if (callback) {
              assert(batchId === newCallbacks.minKey(), "Mutation callbacks processed out-of-order?");
              error$$1 ? callback.reject(error$$1) : callback.resolve();
              newCallbacks = newCallbacks.remove(batchId);
            }
            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
          }
        };
        SyncEngine.prototype.removeAndCleanupQuery = function(queryView) {
          this.queryViewsByQuery.delete(queryView.query);
          delete this.queryViewsByTarget[queryView.targetId];
          this.limboDocumentRefs.removeReferencesForId(queryView.targetId);
          return this.gcLimboDocuments();
        };
        SyncEngine.prototype.updateTrackedLimbos = function(targetId, limboChanges) {
          for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
            var limboChange = limboChanges_1[_i];
            if (limboChange instanceof AddedLimboDocument) {
              this.limboDocumentRefs.addReference(limboChange.key, targetId);
              this.trackLimboChange(limboChange);
            } else if (limboChange instanceof RemovedLimboDocument) {
              debug(LOG_TAG$1, "Document no longer in limbo: " + limboChange.key);
              this.limboDocumentRefs.removeReference(limboChange.key, targetId);
            } else fail("Unknown limbo change: " + JSON.stringify(limboChange));
          }
          return this.gcLimboDocuments();
        };
        SyncEngine.prototype.trackLimboChange = function(limboChange) {
          var key = limboChange.key;
          if (!this.limboTargetsByKey.get(key)) {
            debug(LOG_TAG$1, "New document in limbo: " + key);
            var limboTargetId = this.targetIdGenerator.next();
            var query = Query.atPath(key.path);
            this.limboResolutionsByTarget[limboTargetId] = new LimboResolution(key);
            this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.LimboResolution));
            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);
          }
        };
        SyncEngine.prototype.gcLimboDocuments = function() {
          var _this = this;
          return this.limboCollector.collectGarbage(null).next(function(keys) {
            keys.forEach(function(key) {
              var limboTargetId = _this.limboTargetsByKey.get(key);
              if (null === limboTargetId) return;
              _this.remoteStore.unlisten(limboTargetId);
              _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);
              delete _this.limboResolutionsByTarget[limboTargetId];
            });
          }).toPromise();
        };
        SyncEngine.prototype.currentLimboDocs = function() {
          return this.limboTargetsByKey;
        };
        SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function(changes, remoteEvent) {
          var _this = this;
          var newSnaps = [];
          var docChangesInAllViews = [];
          var queriesProcessed = [];
          this.queryViewsByQuery.forEach(function(_, queryView) {
            queriesProcessed.push(Promise.resolve().then(function() {
              var viewDocChanges = queryView.view.computeDocChanges(changes);
              if (!viewDocChanges.needsRefill) return viewDocChanges;
              return _this.localStore.executeQuery(queryView.query).then(function(docs) {
                return queryView.view.computeDocChanges(docs, viewDocChanges);
              });
            }).then(function(viewDocChanges) {
              var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];
              var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);
              return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function() {
                if (viewChange.snapshot) {
                  newSnaps.push(viewChange.snapshot);
                  var docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewChange.snapshot);
                  docChangesInAllViews.push(docChanges);
                }
              });
            }));
          });
          return Promise.all(queriesProcessed).then(function() {
            _this.viewHandler(newSnaps);
            _this.localStore.notifyLocalViewChanges(docChangesInAllViews);
            return _this.localStore.collectGarbage();
          });
        };
        SyncEngine.prototype.assertSubscribed = function(fnName) {
          assert(null !== this.viewHandler && null !== this.errorHandler, "Trying to call " + fnName + " before calling subscribe().");
        };
        SyncEngine.prototype.handleUserChange = function(user) {
          var _this = this;
          this.currentUser = user;
          return this.localStore.handleUserChange(user).then(function(changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
          }).then(function() {
            return _this.remoteStore.handleUserChange(user);
          });
        };
        SyncEngine.prototype.getRemoteKeysForTarget = function(targetId) {
          var limboResolution = this.limboResolutionsByTarget[targetId];
          return limboResolution && limboResolution.receivedDocument ? documentKeySet().add(limboResolution.key) : this.queryViewsByTarget[targetId] ? this.queryViewsByTarget[targetId].view.syncedDocuments : documentKeySet();
        };
        return SyncEngine;
      }();
      var BATCHID_UNKNOWN = -1;
      var MutationBatch = function() {
        function MutationBatch(batchId, localWriteTime, mutations) {
          this.batchId = batchId;
          this.localWriteTime = localWriteTime;
          this.mutations = mutations;
        }
        MutationBatch.prototype.applyToRemoteDocument = function(docKey, maybeDoc, batchResult) {
          maybeDoc && assert(maybeDoc.key.isEqual(docKey), "applyToRemoteDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
          var mutationResults = batchResult.mutationResults;
          assert(mutationResults.length === this.mutations.length, "Mismatch between mutations length\n      (" + this.mutations.length + ") and mutation results length\n      (" + mutationResults.length + ").");
          for (var i = 0; i < this.mutations.length; i++) {
            var mutation = this.mutations[i];
            if (mutation.key.isEqual(docKey)) {
              var mutationResult = mutationResults[i];
              maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);
            }
          }
          return maybeDoc;
        };
        MutationBatch.prototype.applyToLocalView = function(docKey, maybeDoc) {
          maybeDoc && assert(maybeDoc.key.isEqual(docKey), "applyToLocalDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
          var baseDoc = maybeDoc;
          for (var i = 0; i < this.mutations.length; i++) {
            var mutation = this.mutations[i];
            mutation.key.isEqual(docKey) && (maybeDoc = mutation.applyToLocalView(maybeDoc, baseDoc, this.localWriteTime));
          }
          return maybeDoc;
        };
        MutationBatch.prototype.keys = function() {
          var keySet = documentKeySet();
          for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {
            var mutation = _a[_i];
            keySet = keySet.add(mutation.key);
          }
          return keySet;
        };
        MutationBatch.prototype.isEqual = function(other) {
          return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations);
        };
        MutationBatch.prototype.isTombstone = function() {
          return 0 === this.mutations.length;
        };
        MutationBatch.prototype.toTombstone = function() {
          return new MutationBatch(this.batchId, this.localWriteTime, []);
        };
        return MutationBatch;
      }();
      var MutationBatchResult = function() {
        function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, docVersions) {
          this.batch = batch;
          this.commitVersion = commitVersion;
          this.mutationResults = mutationResults;
          this.streamToken = streamToken;
          this.docVersions = docVersions;
        }
        MutationBatchResult.from = function(batch, commitVersion, results, streamToken) {
          assert(batch.mutations.length === results.length, "Mutations sent " + batch.mutations.length + " must equal results received " + results.length);
          var versionMap = documentVersionMap();
          var mutations = batch.mutations;
          for (var i = 0; i < mutations.length; i++) {
            var version = results[i].version;
            null === version && (version = commitVersion);
            versionMap = versionMap.insert(mutations[i].key, version);
          }
          return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);
        };
        return MutationBatchResult;
      }();
      var escapeChar = "";
      var encodedSeparatorChar = "";
      var encodedNul = "";
      var encodedEscape = "";
      function encode(path) {
        var result = "";
        for (var i = 0; i < path.length; i++) {
          result.length > 0 && (result = encodeSeparator(result));
          result = encodeSegment(path.get(i), result);
        }
        return encodeSeparator(result);
      }
      function encodeSegment(segment, resultBuf) {
        var result = resultBuf;
        var length = segment.length;
        for (var i = 0; i < length; i++) {
          var c = segment.charAt(i);
          switch (c) {
           case "\0":
            result += escapeChar + encodedNul;
            break;

           case escapeChar:
            result += escapeChar + encodedEscape;
            break;

           default:
            result += c;
          }
        }
        return result;
      }
      function encodeSeparator(result) {
        return result + escapeChar + encodedSeparatorChar;
      }
      function decode$1(path) {
        var length = path.length;
        assert(length >= 2, "Invalid path " + path);
        if (2 === length) {
          assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, "Non-empty path " + path + " had length 2");
          return ResourcePath.EMPTY_PATH;
        }
        var lastReasonableEscapeIndex = length - 2;
        var segments = [];
        var segmentBuilder = "";
        for (var start = 0; start < length; ) {
          var end = path.indexOf(escapeChar, start);
          (end < 0 || end > lastReasonableEscapeIndex) && fail('Invalid encoded resource path: "' + path + '"');
          var next = path.charAt(end + 1);
          switch (next) {
           case encodedSeparatorChar:
            var currentPiece = path.substring(start, end);
            var segment = void 0;
            if (0 === segmentBuilder.length) segment = currentPiece; else {
              segmentBuilder += currentPiece;
              segment = segmentBuilder;
              segmentBuilder = "";
            }
            segments.push(segment);
            break;

           case encodedNul:
            segmentBuilder += path.substring(start, end);
            segmentBuilder += "\0";
            break;

           case encodedEscape:
            segmentBuilder += path.substring(start, end + 1);
            break;

           default:
            fail('Invalid encoded resource path: "' + path + '"');
          }
          start = end + 2;
        }
        return new ResourcePath(segments);
      }
      var SCHEMA_VERSION = 3;
      function createOrUpgradeDb(db, txn, fromVersion, toVersion) {
        assert(fromVersion < toVersion && fromVersion >= 0 && toVersion <= SCHEMA_VERSION, "Unexpected schema upgrade from v${fromVersion} to v{toVersion}.");
        if (fromVersion < 1 && toVersion >= 1) {
          createOwnerStore(db);
          createMutationQueue(db);
          createQueryCache(db);
          createRemoteDocumentCache(db);
        }
        var p = PersistencePromise.resolve();
        if (fromVersion < 3 && toVersion >= 3) {
          if (0 !== fromVersion) {
            dropQueryCache(db);
            createQueryCache(db);
          }
          p = p.next(function() {
            return writeEmptyTargetGlobalEntry(txn);
          });
        }
        return p;
      }
      var DbTimestamp = function() {
        function DbTimestamp(seconds, nanoseconds) {
          this.seconds = seconds;
          this.nanoseconds = nanoseconds;
        }
        return DbTimestamp;
      }();
      var DbOwner = function() {
        function DbOwner(ownerId, leaseTimestampMs) {
          this.ownerId = ownerId;
          this.leaseTimestampMs = leaseTimestampMs;
        }
        DbOwner.store = "owner";
        return DbOwner;
      }();
      function createOwnerStore(db) {
        db.createObjectStore(DbOwner.store);
      }
      var DbMutationQueue = function() {
        function DbMutationQueue(userId, lastAcknowledgedBatchId, lastStreamToken) {
          this.userId = userId;
          this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
          this.lastStreamToken = lastStreamToken;
        }
        DbMutationQueue.store = "mutationQueues";
        DbMutationQueue.keyPath = "userId";
        return DbMutationQueue;
      }();
      var DbMutationBatch = function() {
        function DbMutationBatch(userId, batchId, localWriteTimeMs, mutations) {
          this.userId = userId;
          this.batchId = batchId;
          this.localWriteTimeMs = localWriteTimeMs;
          this.mutations = mutations;
        }
        DbMutationBatch.store = "mutations";
        DbMutationBatch.keyPath = [ "userId", "batchId" ];
        return DbMutationBatch;
      }();
      function createMutationQueue(db) {
        db.createObjectStore(DbMutationQueue.store, {
          keyPath: DbMutationQueue.keyPath
        });
        db.createObjectStore(DbMutationBatch.store, {
          keyPath: DbMutationBatch.keyPath
        });
        db.createObjectStore(DbDocumentMutation.store);
      }
      var DbDocumentMutation = function() {
        function DbDocumentMutation() {}
        DbDocumentMutation.prefixForUser = function(userId) {
          return [ userId ];
        };
        DbDocumentMutation.prefixForPath = function(userId, path) {
          return [ userId, encode(path) ];
        };
        DbDocumentMutation.key = function(userId, path, batchId) {
          return [ userId, encode(path), batchId ];
        };
        DbDocumentMutation.store = "documentMutations";
        DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
        return DbDocumentMutation;
      }();
      function createRemoteDocumentCache(db) {
        db.createObjectStore(DbRemoteDocument.store);
      }
      var DbNoDocument = function() {
        function DbNoDocument(path, readTime) {
          this.path = path;
          this.readTime = readTime;
        }
        return DbNoDocument;
      }();
      var DbRemoteDocument = function() {
        function DbRemoteDocument(noDocument, document) {
          this.noDocument = noDocument;
          this.document = document;
        }
        DbRemoteDocument.store = "remoteDocuments";
        return DbRemoteDocument;
      }();
      var DbTarget = function() {
        function DbTarget(targetId, canonicalId, readTime, resumeToken, lastListenSequenceNumber, query) {
          this.targetId = targetId;
          this.canonicalId = canonicalId;
          this.readTime = readTime;
          this.resumeToken = resumeToken;
          this.lastListenSequenceNumber = lastListenSequenceNumber;
          this.query = query;
        }
        DbTarget.store = "targets";
        DbTarget.keyPath = "targetId";
        DbTarget.queryTargetsIndexName = "queryTargetsIndex";
        DbTarget.queryTargetsKeyPath = [ "canonicalId", "targetId" ];
        return DbTarget;
      }();
      var DbTargetDocument = function() {
        function DbTargetDocument(targetId, path) {
          this.targetId = targetId;
          this.path = path;
        }
        DbTargetDocument.store = "targetDocuments";
        DbTargetDocument.keyPath = [ "targetId", "path" ];
        DbTargetDocument.documentTargetsIndex = "documentTargetsIndex";
        DbTargetDocument.documentTargetsKeyPath = [ "path", "targetId" ];
        return DbTargetDocument;
      }();
      var DbTargetGlobal = function() {
        function DbTargetGlobal(highestTargetId, highestListenSequenceNumber, lastRemoteSnapshotVersion, targetCount) {
          this.highestTargetId = highestTargetId;
          this.highestListenSequenceNumber = highestListenSequenceNumber;
          this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
          this.targetCount = targetCount;
        }
        DbTargetGlobal.key = "targetGlobalKey";
        DbTargetGlobal.store = "targetGlobal";
        return DbTargetGlobal;
      }();
      function createQueryCache(db) {
        var targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, {
          keyPath: DbTargetDocument.keyPath
        });
        targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, {
          unique: true
        });
        var targetStore = db.createObjectStore(DbTarget.store, {
          keyPath: DbTarget.keyPath
        });
        targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, {
          unique: true
        });
        db.createObjectStore(DbTargetGlobal.store);
      }
      function dropQueryCache(db) {
        db.deleteObjectStore(DbTargetDocument.store);
        db.deleteObjectStore(DbTarget.store);
        db.deleteObjectStore(DbTargetGlobal.store);
      }
      function writeEmptyTargetGlobalEntry(txn) {
        var globalStore = txn.store(DbTargetGlobal.store);
        var metadata = new DbTargetGlobal(0, 0, SnapshotVersion.MIN.toTimestamp(), 0);
        return globalStore.put(DbTargetGlobal.key, metadata);
      }
      var ALL_STORES = [ DbMutationQueue.store, DbMutationBatch.store, DbDocumentMutation.store, DbRemoteDocument.store, DbTarget.store, DbOwner.store, DbTargetGlobal.store, DbTargetDocument.store ];
      var IndexedDbMutationQueue = function() {
        function IndexedDbMutationQueue(userId, serializer) {
          this.userId = userId;
          this.serializer = serializer;
          this.garbageCollector = null;
        }
        IndexedDbMutationQueue.forUser = function(user, serializer) {
          assert("" !== user.uid, "UserID must not be an empty string.");
          var userId = user.isAuthenticated() ? user.uid : "";
          return new IndexedDbMutationQueue(userId, serializer);
        };
        IndexedDbMutationQueue.prototype.start = function(transaction) {
          var _this = this;
          return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction).next(function(nextBatchId) {
            _this.nextBatchId = nextBatchId;
            return mutationQueuesStore(transaction).get(_this.userId);
          }).next(function(metadata) {
            metadata || (metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, ""));
            _this.metadata = metadata;
            return _this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId ? _this.checkEmpty(transaction).next(function(empty) {
              assert(empty, "Reset nextBatchID is only possible when the queue is empty");
              _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;
              return mutationQueuesStore(transaction).put(_this.metadata);
            }) : PersistencePromise.resolve();
          });
        };
        IndexedDbMutationQueue.loadNextBatchIdFromDb = function(txn) {
          var maxBatchId = BATCHID_UNKNOWN;
          return mutationsStore(txn).iterate({
            reverse: true
          }, function(key, batch, control) {
            var userId = key[0], batchId = key[1];
            batchId > maxBatchId && (maxBatchId = batch.batchId);
            if ("" === userId) control.done(); else {
              var nextUser = immediatePredecessor(userId);
              control.skip([ nextUser ]);
            }
          }).next(function() {
            return maxBatchId + 1;
          });
        };
        IndexedDbMutationQueue.prototype.checkEmpty = function(transaction) {
          var empty = true;
          var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));
          return mutationsStore(transaction).iterate({
            range: range
          }, function(key, value, control) {
            empty = false;
            control.done();
          }).next(function() {
            return empty;
          });
        };
        IndexedDbMutationQueue.prototype.getNextBatchId = function(transaction) {
          return PersistencePromise.resolve(this.nextBatchId);
        };
        IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function(transaction) {
          return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);
        };
        IndexedDbMutationQueue.prototype.acknowledgeBatch = function(transaction, batch, streamToken) {
          var batchId = batch.batchId;
          assert(batchId > this.metadata.lastAcknowledgedBatchId, "Mutation batchIDs must be acknowledged in order");
          this.metadata.lastAcknowledgedBatchId = batchId;
          this.metadata.lastStreamToken = convertStreamToken(streamToken);
          return mutationQueuesStore(transaction).put(this.metadata);
        };
        IndexedDbMutationQueue.prototype.getLastStreamToken = function(transaction) {
          return PersistencePromise.resolve(this.metadata.lastStreamToken);
        };
        IndexedDbMutationQueue.prototype.setLastStreamToken = function(transaction, streamToken) {
          this.metadata.lastStreamToken = convertStreamToken(streamToken);
          return mutationQueuesStore(transaction).put(this.metadata);
        };
        IndexedDbMutationQueue.prototype.addMutationBatch = function(transaction, localWriteTime, mutations) {
          var _this = this;
          var batchId = this.nextBatchId;
          this.nextBatchId++;
          var batch = new MutationBatch(batchId, localWriteTime, mutations);
          var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);
          return mutationsStore(transaction).put(dbBatch).next(function() {
            var promises = [];
            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
              var mutation = mutations_1[_i];
              var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
              promises.push(documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER));
            }
            return PersistencePromise.waitFor(promises);
          }).next(function() {
            return batch;
          });
        };
        IndexedDbMutationQueue.prototype.lookupMutationBatch = function(transaction, batchId) {
          var _this = this;
          return mutationsStore(transaction).get(this.keyForBatchId(batchId)).next(function(dbBatch) {
            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;
          });
        };
        IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
          var _this = this;
          var nextBatchId = Math.max(batchId, this.metadata.lastAcknowledgedBatchId) + 1;
          var range = IDBKeyRange.lowerBound(this.keyForBatchId(nextBatchId));
          var foundBatch = null;
          return mutationsStore(transaction).iterate({
            range: range
          }, function(key, dbBatch, control) {
            if (dbBatch.userId === _this.userId) {
              assert(dbBatch.batchId >= nextBatchId, "Should have found mutation after " + nextBatchId);
              foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);
            }
            control.done();
          }).next(function() {
            return foundBatch;
          });
        };
        IndexedDbMutationQueue.prototype.getAllMutationBatches = function(transaction) {
          var _this = this;
          var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));
          return mutationsStore(transaction).loadAll(range).next(function(dbBatches) {
            return dbBatches.map(function(dbBatch) {
              return _this.serializer.fromDbMutationBatch(dbBatch);
            });
          });
        };
        IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function(transaction, batchId) {
          var _this = this;
          var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));
          return mutationsStore(transaction).loadAll(range).next(function(dbBatches) {
            return dbBatches.map(function(dbBatch) {
              return _this.serializer.fromDbMutationBatch(dbBatch);
            });
          });
        };
        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
          var _this = this;
          var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
          var indexStart = IDBKeyRange.lowerBound(indexPrefix);
          var results = [];
          return documentMutationsStore(transaction).iterate({
            range: indexStart
          }, function(indexKey, _, control) {
            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
            var path = decode$1(encodedPath);
            if (userID !== _this.userId || !documentKey.path.isEqual(path)) {
              control.done();
              return;
            }
            var mutationKey = _this.keyForBatchId(batchID);
            return mutationsStore(transaction).get(mutationKey).next(function(dbBatch) {
              null === dbBatch && fail("Dangling document-mutation reference found: " + indexKey + " which points to " + mutationKey);
              results.push(_this.serializer.fromDbMutationBatch(dbBatch));
            });
          }).next(function() {
            return results;
          });
        };
        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
          var _this = this;
          var uniqueBatchIDs = new SortedSet(primitiveComparator);
          var promises = [];
          documentKeys.forEach(function(documentKey) {
            var indexStart = DbDocumentMutation.prefixForPath(_this.userId, documentKey.path);
            var range = IDBKeyRange.lowerBound(indexStart);
            var promise = documentMutationsStore(transaction).iterate({
              range: range
            }, function(indexKey, _, control) {
              var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
              var path = decode$1(encodedPath);
              if (userID !== _this.userId || !documentKey.path.isEqual(path)) {
                control.done();
                return;
              }
              uniqueBatchIDs = uniqueBatchIDs.add(batchID);
            });
            promises.push(promise);
          });
          return PersistencePromise.waitFor(promises).next(function() {
            return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
          });
        };
        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query) {
          var _this = this;
          assert(!query.isDocumentQuery(), "Document queries shouldn't go down this path");
          var queryPath = query.path;
          var immediateChildrenLength = queryPath.length + 1;
          var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);
          var indexStart = IDBKeyRange.lowerBound(indexPrefix);
          var uniqueBatchIDs = new SortedSet(primitiveComparator);
          return documentMutationsStore(transaction).iterate({
            range: indexStart
          }, function(indexKey, _, control) {
            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
            var path = decode$1(encodedPath);
            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {
              control.done();
              return;
            }
            if (path.length !== immediateChildrenLength) return;
            uniqueBatchIDs = uniqueBatchIDs.add(batchID);
          }).next(function() {
            return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
          });
        };
        IndexedDbMutationQueue.prototype.lookupMutationBatches = function(transaction, batchIDs) {
          var _this = this;
          var results = [];
          var promises = [];
          batchIDs.forEach(function(batchID) {
            var mutationKey = _this.keyForBatchId(batchID);
            promises.push(mutationsStore(transaction).get(mutationKey).next(function(mutation) {
              null === mutation && fail("Dangling document-mutation reference found, which points to " + mutationKey);
              results.push(_this.serializer.fromDbMutationBatch(mutation));
            }));
          });
          return PersistencePromise.waitFor(promises).next(function() {
            return results;
          });
        };
        IndexedDbMutationQueue.prototype.removeMutationBatches = function(transaction, batches) {
          var txn = mutationsStore(transaction);
          var indexTxn = documentMutationsStore(transaction);
          var promises = [];
          var _loop_1 = function(batch) {
            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));
            var numDeleted = 0;
            var removePromise = txn.iterate({
              range: range
            }, function(key, value, control) {
              numDeleted++;
              return control.delete();
            });
            promises.push(removePromise.next(function() {
              assert(1 === numDeleted, "Dangling document-mutation reference found: Missing batch " + batch.batchId);
            }));
            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {
              var mutation = _a[_i];
              var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);
              promises.push(indexTxn.delete(indexKey));
              null !== this_1.garbageCollector && this_1.garbageCollector.addPotentialGarbageKey(mutation.key);
            }
          };
          var this_1 = this;
          for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            _loop_1(batch);
          }
          return PersistencePromise.waitFor(promises);
        };
        IndexedDbMutationQueue.prototype.performConsistencyCheck = function(txn) {
          var _this = this;
          return this.checkEmpty(txn).next(function(empty) {
            if (!empty) return PersistencePromise.resolve();
            var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));
            var danglingMutationReferences = [];
            return documentMutationsStore(txn).iterate({
              range: startRange
            }, function(key, _, control) {
              var userID = key[0];
              if (userID !== _this.userId) {
                control.done();
                return;
              }
              var path = decode$1(key[1]);
              danglingMutationReferences.push(path);
            }).next(function() {
              assert(0 === danglingMutationReferences.length, "Document leak -- detected dangling mutation references when queue is empty. Dangling keys: " + danglingMutationReferences.map(function(p) {
                return p.canonicalString();
              }));
            });
          });
        };
        IndexedDbMutationQueue.prototype.setGarbageCollector = function(gc) {
          this.garbageCollector = gc;
        };
        IndexedDbMutationQueue.prototype.containsKey = function(txn, key) {
          var _this = this;
          var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);
          var encodedPath = indexKey[1];
          var startRange = IDBKeyRange.lowerBound(indexKey);
          var containsKey = false;
          return documentMutationsStore(txn).iterate({
            range: startRange,
            keysOnly: true
          }, function(key, value, control) {
            var userID = key[0], keyPath = key[1], _ = key[2];
            userID === _this.userId && keyPath === encodedPath && (containsKey = true);
            control.done();
          }).next(function() {
            return containsKey;
          });
        };
        IndexedDbMutationQueue.prototype.keyForBatchId = function(batchId) {
          return [ this.userId, batchId ];
        };
        return IndexedDbMutationQueue;
      }();
      function convertStreamToken(token) {
        if (token instanceof Uint8Array) {
          assert("YES" === process.env.USE_MOCK_PERSISTENCE, "Persisting non-string stream tokens is only supported with mock persistence .");
          return token.toString();
        }
        return token;
      }
      function mutationsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbMutationBatch.store);
      }
      function documentMutationsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbDocumentMutation.store);
      }
      function mutationQueuesStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbMutationQueue.store);
      }
      var IndexedDbQueryCache = function() {
        function IndexedDbQueryCache(serializer) {
          this.serializer = serializer;
          this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;
          this.metadata = null;
          this.garbageCollector = null;
        }
        IndexedDbQueryCache.prototype.start = function(transaction) {
          var _this = this;
          return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function(metadata) {
            assert(null !== metadata, "Missing metadata row that should be added by schema migration.");
            _this.metadata = metadata;
            var lastSavedVersion = metadata.lastRemoteSnapshotVersion;
            _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanoseconds));
            return PersistencePromise.resolve();
          });
        };
        IndexedDbQueryCache.prototype.getHighestTargetId = function() {
          return this.metadata.highestTargetId;
        };
        IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function() {
          return this.lastRemoteSnapshotVersion;
        };
        IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function(transaction, snapshotVersion) {
          this.lastRemoteSnapshotVersion = snapshotVersion;
          this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();
          return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);
        };
        IndexedDbQueryCache.prototype.addQueryData = function(transaction, queryData) {
          var _this = this;
          return this.saveQueryData(transaction, queryData).next(function() {
            _this.metadata.targetCount += 1;
            _this.updateMetadataFromQueryData(queryData);
            return _this.saveMetadata(transaction);
          });
        };
        IndexedDbQueryCache.prototype.updateQueryData = function(transaction, queryData) {
          var _this = this;
          return this.saveQueryData(transaction, queryData).next(function() {
            return _this.updateMetadataFromQueryData(queryData) ? _this.saveMetadata(transaction) : PersistencePromise.resolve();
          });
        };
        IndexedDbQueryCache.prototype.removeQueryData = function(transaction, queryData) {
          var _this = this;
          assert(this.metadata.targetCount > 0, "Removing from an empty query cache");
          return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function() {
            return targetsStore(transaction).delete(queryData.targetId);
          }).next(function() {
            _this.metadata.targetCount -= 1;
            return _this.saveMetadata(transaction);
          });
        };
        IndexedDbQueryCache.prototype.saveMetadata = function(transaction) {
          return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);
        };
        IndexedDbQueryCache.prototype.saveQueryData = function(transaction, queryData) {
          return targetsStore(transaction).put(this.serializer.toDbTarget(queryData));
        };
        IndexedDbQueryCache.prototype.updateMetadataFromQueryData = function(queryData) {
          var needsUpdate = false;
          if (queryData.targetId > this.metadata.highestTargetId) {
            this.metadata.highestTargetId = queryData.targetId;
            needsUpdate = true;
          }
          return needsUpdate;
        };
        Object.defineProperty(IndexedDbQueryCache.prototype, "count", {
          get: function() {
            return this.metadata.targetCount;
          },
          enumerable: true,
          configurable: true
        });
        IndexedDbQueryCache.prototype.getQueryData = function(transaction, query) {
          var _this = this;
          var canonicalId = query.canonicalId();
          var range = IDBKeyRange.bound([ canonicalId, Number.NEGATIVE_INFINITY ], [ canonicalId, Number.POSITIVE_INFINITY ]);
          var result = null;
          return targetsStore(transaction).iterate({
            range: range,
            index: DbTarget.queryTargetsIndexName
          }, function(key, value, control) {
            var found = _this.serializer.fromDbTarget(value);
            if (query.isEqual(found.query)) {
              result = found;
              control.done();
            }
          }).next(function() {
            return result;
          });
        };
        IndexedDbQueryCache.prototype.addMatchingKeys = function(txn, keys, targetId) {
          var promises = [];
          var store = documentTargetStore(txn);
          keys.forEach(function(key) {
            var path = encode(key.path);
            promises.push(store.put(new DbTargetDocument(targetId, path)));
          });
          return PersistencePromise.waitFor(promises);
        };
        IndexedDbQueryCache.prototype.removeMatchingKeys = function(txn, keys, targetId) {
          var _this = this;
          var promises = [];
          var store = documentTargetStore(txn);
          keys.forEach(function(key) {
            var path = encode(key.path);
            promises.push(store.delete([ targetId, path ]));
            null !== _this.garbageCollector && _this.garbageCollector.addPotentialGarbageKey(key);
          });
          return PersistencePromise.waitFor(promises);
        };
        IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
          var store = documentTargetStore(txn);
          var range = IDBKeyRange.bound([ targetId ], [ targetId + 1 ], false, true);
          return this.notifyGCForRemovedKeys(txn, range).next(function() {
            return store.delete(range);
          });
        };
        IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function(txn, range) {
          var _this = this;
          var store = documentTargetStore(txn);
          return null !== this.garbageCollector && this.garbageCollector.isEager ? store.iterate({
            range: range,
            keysOnly: true
          }, function(key, _, control) {
            var path = decode$1(key[1]);
            var docKey = new DocumentKey(path);
            assert(null !== _this.garbageCollector, "GarbageCollector for query cache set to null during key removal.");
            _this.garbageCollector.addPotentialGarbageKey(docKey);
          }) : PersistencePromise.resolve();
        };
        IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
          var range = IDBKeyRange.bound([ targetId ], [ targetId + 1 ], false, true);
          var store = documentTargetStore(txn);
          var result = documentKeySet();
          return store.iterate({
            range: range,
            keysOnly: true
          }, function(key, _, control) {
            var path = decode$1(key[1]);
            var docKey = new DocumentKey(path);
            result = result.add(docKey);
          }).next(function() {
            return result;
          });
        };
        IndexedDbQueryCache.prototype.setGarbageCollector = function(gc) {
          this.garbageCollector = gc;
        };
        IndexedDbQueryCache.prototype.containsKey = function(txn, key) {
          assert(null !== txn, "Persistence Transaction cannot be null for query cache containsKey");
          var path = encode(key.path);
          var range = IDBKeyRange.bound([ path ], [ immediateSuccessor(path) ], false, true);
          var count = 0;
          return documentTargetStore(txn).iterate({
            index: DbTargetDocument.documentTargetsIndex,
            keysOnly: true,
            range: range
          }, function(key, _, control) {
            count++;
            control.done();
          }).next(function() {
            return count > 0;
          });
        };
        return IndexedDbQueryCache;
      }();
      function targetsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTarget.store);
      }
      function globalTargetStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTargetGlobal.store);
      }
      function documentTargetStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTargetDocument.store);
      }
      var IndexedDbRemoteDocumentCache = function() {
        function IndexedDbRemoteDocumentCache(serializer) {
          this.serializer = serializer;
        }
        IndexedDbRemoteDocumentCache.prototype.addEntry = function(transaction, maybeDocument) {
          return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));
        };
        IndexedDbRemoteDocumentCache.prototype.removeEntry = function(transaction, documentKey) {
          return remoteDocumentsStore(transaction).delete(dbKey(documentKey));
        };
        IndexedDbRemoteDocumentCache.prototype.getEntry = function(transaction, documentKey) {
          var _this = this;
          return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
            return dbRemoteDoc ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc) : null;
          });
        };
        IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function(transaction, query) {
          var _this = this;
          var results = documentMap();
          var startKey = query.path.toArray();
          var range = IDBKeyRange.lowerBound(startKey);
          return remoteDocumentsStore(transaction).iterate({
            range: range
          }, function(key, dbRemoteDoc, control) {
            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);
            query.path.isPrefixOf(maybeDoc.key.path) ? maybeDoc instanceof Document && query.matches(maybeDoc) && (results = results.insert(maybeDoc.key, maybeDoc)) : control.done();
          }).next(function() {
            return results;
          });
        };
        return IndexedDbRemoteDocumentCache;
      }();
      function remoteDocumentsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbRemoteDocument.store);
      }
      function dbKey(docKey) {
        return docKey.path.toArray();
      }
      var LocalSerializer = function() {
        function LocalSerializer(remoteSerializer) {
          this.remoteSerializer = remoteSerializer;
        }
        LocalSerializer.prototype.fromDbRemoteDocument = function(remoteDoc) {
          if (remoteDoc.document) return this.remoteSerializer.fromDocument(remoteDoc.document);
          if (remoteDoc.noDocument) {
            var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);
            var readTime = remoteDoc.noDocument.readTime;
            var timestamp = new Timestamp(readTime.seconds, readTime.nanoseconds);
            return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));
          }
          return fail("Unexpected DbRemoteDocument");
        };
        LocalSerializer.prototype.toDbRemoteDocument = function(maybeDoc) {
          if (maybeDoc instanceof Document) {
            var doc = this.remoteSerializer.toDocument(maybeDoc);
            return new DbRemoteDocument(null, doc);
          }
          var path = maybeDoc.key.path.toArray();
          var timestamp = maybeDoc.version.toTimestamp();
          var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
          return new DbRemoteDocument(new DbNoDocument(path, readTime), null);
        };
        LocalSerializer.prototype.toDbMutationBatch = function(userId, batch) {
          var _this = this;
          var serializedMutations = batch.mutations.map(function(m) {
            return _this.remoteSerializer.toMutation(m);
          });
          return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedMutations);
        };
        LocalSerializer.prototype.fromDbMutationBatch = function(dbBatch) {
          var _this = this;
          var mutations = dbBatch.mutations.map(function(m) {
            return _this.remoteSerializer.fromMutation(m);
          });
          var timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);
          return new MutationBatch(dbBatch.batchId, timestamp, mutations);
        };
        LocalSerializer.prototype.fromDbTarget = function(dbTarget) {
          var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanoseconds);
          var version = SnapshotVersion.fromTimestamp(readTime);
          var query;
          query = isDocumentQuery(dbTarget.query) ? this.remoteSerializer.fromDocumentsTarget(dbTarget.query) : this.remoteSerializer.fromQueryTarget(dbTarget.query);
          return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);
        };
        LocalSerializer.prototype.toDbTarget = function(queryData) {
          assert(QueryPurpose.Listen === queryData.purpose, "Only queries with purpose " + QueryPurpose.Listen + " may be stored, got " + queryData.purpose);
          var timestamp = queryData.snapshotVersion.toTimestamp();
          var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
          var queryProto;
          queryProto = queryData.query.isDocumentQuery() ? this.remoteSerializer.toDocumentsTarget(queryData.query) : this.remoteSerializer.toQueryTarget(queryData.query);
          var resumeToken;
          if (queryData.resumeToken instanceof Uint8Array) {
            assert("YES" === process.env.USE_MOCK_PERSISTENCE, "Persisting non-string stream tokens is only supported with mock persistence .");
            resumeToken = queryData.resumeToken.toString();
          } else resumeToken = queryData.resumeToken;
          return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);
        };
        return LocalSerializer;
      }();
      function isDocumentQuery(dbQuery) {
        return void 0 !== dbQuery.documents;
      }
      var PersistenceTransaction = function() {
        function PersistenceTransaction() {}
        return PersistenceTransaction;
      }();
      var Deferred$1 = function() {
        function Deferred() {
          var _this = this;
          this.promise = new Promise(function(resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
          });
        }
        return Deferred;
      }();
      var LOG_TAG$2 = "SimpleDb";
      var SimpleDb = function() {
        function SimpleDb(db) {
          this.db = db;
        }
        SimpleDb.openOrCreate = function(name, version, runUpgrade) {
          assert(SimpleDb.isAvailable(), "IndexedDB not supported in current environment.");
          debug(LOG_TAG$2, "Opening database:", name);
          return new PersistencePromise(function(resolve, reject) {
            var request = window.indexedDB.open(name, version);
            request.onsuccess = function(event) {
              var db = event.target.result;
              resolve(new SimpleDb(db));
            };
            request.onblocked = function() {
              reject(new FirestoreError(Code.FAILED_PRECONDITION, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
            };
            request.onerror = function(event) {
              reject(event.target.error);
            };
            request.onupgradeneeded = function(event) {
              debug(LOG_TAG$2, 'Database "' + name + '" requires upgrade from version:', event.oldVersion);
              var db = event.target.result;
              var txn = new SimpleDbTransaction(request.transaction);
              runUpgrade(db, txn, event.oldVersion, SCHEMA_VERSION).next(function() {
                debug(LOG_TAG$2, "Database upgrade to version " + SCHEMA_VERSION + " complete");
              });
            };
          }).toPromise();
        };
        SimpleDb.delete = function(name) {
          debug(LOG_TAG$2, "Removing database:", name);
          return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();
        };
        SimpleDb.isAvailable = function() {
          if ("undefined" === typeof window || null == window.indexedDB) return false;
          if (void 0 === window.navigator) return "YES" === process.env.USE_MOCK_PERSISTENCE;
          var ua = window.navigator.userAgent;
          return !(ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0);
        };
        SimpleDb.getStore = function(txn, store) {
          return txn.store(store);
        };
        SimpleDb.prototype.runTransaction = function(mode, objectStores, transactionFn) {
          var transaction = SimpleDbTransaction.open(this.db, mode, objectStores);
          var transactionFnResult = transactionFn(transaction).catch(function(error$$1) {
            transaction.abort(error$$1);
          }).toPromise();
          return transaction.completionPromise.then(function() {
            return transactionFnResult;
          });
        };
        SimpleDb.prototype.close = function() {
          this.db.close();
        };
        return SimpleDb;
      }();
      var IterationController = function() {
        function IterationController(dbCursor) {
          this.dbCursor = dbCursor;
          this.shouldStop = false;
          this.nextKey = null;
        }
        Object.defineProperty(IterationController.prototype, "isDone", {
          get: function() {
            return this.shouldStop;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(IterationController.prototype, "skipToKey", {
          get: function() {
            return this.nextKey;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(IterationController.prototype, "cursor", {
          set: function(value) {
            this.dbCursor = value;
          },
          enumerable: true,
          configurable: true
        });
        IterationController.prototype.done = function() {
          this.shouldStop = true;
        };
        IterationController.prototype.skip = function(key) {
          this.nextKey = key;
        };
        IterationController.prototype.delete = function() {
          return wrapRequest(this.dbCursor.delete());
        };
        return IterationController;
      }();
      var SimpleDbTransaction = function() {
        function SimpleDbTransaction(transaction) {
          var _this = this;
          this.transaction = transaction;
          this.aborted = false;
          this.completionDeferred = new Deferred$1();
          this.transaction.oncomplete = function() {
            _this.completionDeferred.resolve();
          };
          this.transaction.onabort = function() {
            transaction.error ? _this.completionDeferred.reject(transaction.error) : _this.completionDeferred.resolve();
          };
          this.transaction.onerror = function(event) {
            _this.completionDeferred.reject(event.target.error);
          };
        }
        SimpleDbTransaction.open = function(db, mode, objectStoreNames) {
          return new SimpleDbTransaction(db.transaction(objectStoreNames, mode));
        };
        Object.defineProperty(SimpleDbTransaction.prototype, "completionPromise", {
          get: function() {
            return this.completionDeferred.promise;
          },
          enumerable: true,
          configurable: true
        });
        SimpleDbTransaction.prototype.abort = function(error$$1) {
          error$$1 && this.completionDeferred.reject(error$$1);
          if (!this.aborted) {
            debug(LOG_TAG$2, "Aborting transaction: %s", error$$1 ? error$$1.message : "Client-initiated abort");
            this.aborted = true;
            this.transaction.abort();
          }
        };
        SimpleDbTransaction.prototype.store = function(storeName) {
          var store = this.transaction.objectStore(storeName);
          assert(!!store, "Object store not part of transaction: " + storeName);
          return new SimpleDbStore(store);
        };
        return SimpleDbTransaction;
      }();
      var SimpleDbStore = function() {
        function SimpleDbStore(store) {
          this.store = store;
        }
        SimpleDbStore.prototype.put = function(keyOrValue, value) {
          var request;
          if (void 0 !== value) {
            debug(LOG_TAG$2, "PUT", this.store.name, keyOrValue, value);
            request = this.store.put(value, keyOrValue);
          } else {
            debug(LOG_TAG$2, "PUT", this.store.name, "<auto-key>", keyOrValue);
            request = this.store.put(keyOrValue);
          }
          return wrapRequest(request);
        };
        SimpleDbStore.prototype.get = function(key) {
          var _this = this;
          var request = this.store.get(key);
          return wrapRequest(request).next(function(result) {
            void 0 === result && (result = null);
            debug(LOG_TAG$2, "GET", _this.store.name, key, result);
            return result;
          });
        };
        SimpleDbStore.prototype.delete = function(key) {
          debug(LOG_TAG$2, "DELETE", this.store.name, key);
          var request = this.store.delete(key);
          return wrapRequest(request);
        };
        SimpleDbStore.prototype.count = function() {
          debug(LOG_TAG$2, "COUNT", this.store.name);
          var request = this.store.count();
          return wrapRequest(request);
        };
        SimpleDbStore.prototype.loadAll = function(indexOrRange, range) {
          var cursor = this.cursor(this.options(indexOrRange, range));
          var results = [];
          return this.iterateCursor(cursor, function(key, value) {
            results.push(value);
          }).next(function() {
            return results;
          });
        };
        SimpleDbStore.prototype.deleteAll = function(indexOrRange, range) {
          debug(LOG_TAG$2, "DELETE ALL", this.store.name);
          var options = this.options(indexOrRange, range);
          options.keysOnly = false;
          var cursor = this.cursor(options);
          return this.iterateCursor(cursor, function(key, value, control) {
            return control.delete();
          });
        };
        SimpleDbStore.prototype.iterate = function(optionsOrCallback, callback) {
          var options;
          if (callback) options = optionsOrCallback; else {
            options = {};
            callback = optionsOrCallback;
          }
          var cursor = this.cursor(options);
          return this.iterateCursor(cursor, callback);
        };
        SimpleDbStore.prototype.iterateCursor = function(cursorRequest, fn) {
          var results = [];
          return new PersistencePromise(function(resolve, reject) {
            cursorRequest.onerror = function(event) {
              reject(event.target.error);
            };
            cursorRequest.onsuccess = function(event) {
              var cursor = event.target.result;
              if (!cursor) {
                resolve();
                return;
              }
              var controller = new IterationController(cursor);
              var userResult = fn(cursor.primaryKey, cursor.value, controller);
              userResult instanceof PersistencePromise && results.push(userResult);
              controller.isDone ? resolve() : null === controller.skipToKey ? cursor.continue() : cursor.continue(controller.skipToKey);
            };
          }).next(function() {
            return PersistencePromise.waitFor(results);
          });
        };
        SimpleDbStore.prototype.options = function(indexOrRange, range) {
          var indexName = void 0;
          if (void 0 !== indexOrRange) if ("string" === typeof indexOrRange) indexName = indexOrRange; else {
            assert(void 0 === range, "3rd argument must not be defined if 2nd is a range.");
            range = indexOrRange;
          }
          return {
            index: indexName,
            range: range
          };
        };
        SimpleDbStore.prototype.cursor = function(options) {
          var direction = "next";
          options.reverse && (direction = "prev");
          if (options.index) {
            var index = this.store.index(options.index);
            return options.keysOnly ? index.openKeyCursor(options.range, direction) : index.openCursor(options.range, direction);
          }
          return this.store.openCursor(options.range, direction);
        };
        return SimpleDbStore;
      }();
      function wrapRequest(request) {
        return new PersistencePromise(function(resolve, reject) {
          request.onsuccess = function(event) {
            var result = event.target.result;
            resolve(result);
          };
          request.onerror = function(event) {
            reject(event.target.error);
          };
        });
      }
      var LOG_TAG$3 = "IndexedDbPersistence";
      var OWNER_LEASE_MAX_AGE_MS = 5e3;
      var OWNER_LEASE_REFRESH_INTERVAL_MS = 4e3;
      var ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = "zombiedOwnerId";
      var EXISTING_OWNER_ERROR_MSG = "There is another tab open with offline persistence enabled. Only one such tab is allowed at a time. The other tab must be closed or persistence must be disabled.";
      var UNSUPPORTED_PLATFORM_ERROR_MSG = "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.";
      var IndexedDbTransaction = function(_super) {
        tslib_1.__extends(IndexedDbTransaction, _super);
        function IndexedDbTransaction(simpleDbTransaction) {
          var _this = _super.call(this) || this;
          _this.simpleDbTransaction = simpleDbTransaction;
          return _this;
        }
        return IndexedDbTransaction;
      }(PersistenceTransaction);
      var IndexedDbPersistence = function() {
        function IndexedDbPersistence(prefix, serializer) {
          this._started = false;
          this.ownerId = this.generateOwnerId();
          this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;
          this.serializer = new LocalSerializer(serializer);
          this.localStoragePrefix = prefix;
        }
        IndexedDbPersistence.getStore = function(txn, store) {
          if (txn instanceof IndexedDbTransaction) return SimpleDb.getStore(txn.simpleDbTransaction, store);
          fail("IndexedDbPersistence must use instances of IndexedDbTransaction");
        };
        IndexedDbPersistence.prototype.start = function() {
          var _this = this;
          if (!IndexedDbPersistence.isAvailable()) {
            this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
            return Promise.reject(this.persistenceError);
          }
          assert(!this.started, "IndexedDbPersistence double-started!");
          return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb).then(function(db) {
            _this.simpleDb = db;
          }).then(function() {
            return _this.tryAcquireOwnerLease();
          }).then(function() {
            _this.scheduleOwnerLeaseRefreshes();
            _this.attachWindowUnloadHook();
          }).then(function() {
            _this._started = true;
          });
        };
        IndexedDbPersistence.prototype.shutdown = function(deleteData) {
          var _this = this;
          assert(this.started, "IndexedDbPersistence shutdown without start!");
          this._started = false;
          this.detachWindowUnloadHook();
          this.stopOwnerLeaseRefreshes();
          return this.releaseOwnerLease().then(function() {
            _this.simpleDb.close();
            if (deleteData) return SimpleDb.delete(_this.dbName);
          });
        };
        Object.defineProperty(IndexedDbPersistence.prototype, "started", {
          get: function() {
            return this._started;
          },
          enumerable: true,
          configurable: true
        });
        IndexedDbPersistence.prototype.getMutationQueue = function(user) {
          return IndexedDbMutationQueue.forUser(user, this.serializer);
        };
        IndexedDbPersistence.prototype.getQueryCache = function() {
          return new IndexedDbQueryCache(this.serializer);
        };
        IndexedDbPersistence.prototype.getRemoteDocumentCache = function() {
          return new IndexedDbRemoteDocumentCache(this.serializer);
        };
        IndexedDbPersistence.prototype.runTransaction = function(action, operation) {
          var _this = this;
          if (this.persistenceError) return Promise.reject(this.persistenceError);
          debug(LOG_TAG$3, "Starting transaction:", action);
          return this.simpleDb.runTransaction("readwrite", ALL_STORES, function(simpleDbTxn) {
            return _this.ensureOwnerLease(simpleDbTxn).next(function() {
              return operation(new IndexedDbTransaction(simpleDbTxn));
            });
          });
        };
        IndexedDbPersistence.isAvailable = function() {
          return SimpleDb.isAvailable();
        };
        IndexedDbPersistence.buildStoragePrefix = function(databaseInfo) {
          var database = databaseInfo.databaseId.projectId;
          databaseInfo.databaseId.isDefaultDatabase || (database += "." + databaseInfo.databaseId.database);
          return "firestore/" + databaseInfo.persistenceKey + "/" + database + "/";
        };
        IndexedDbPersistence.prototype.tryAcquireOwnerLease = function() {
          var _this = this;
          return this.simpleDb.runTransaction("readwrite", [ DbOwner.store ], function(txn) {
            var store = txn.store(DbOwner.store);
            return store.get("owner").next(function(dbOwner) {
              if (_this.validOwner(dbOwner)) {
                debug(LOG_TAG$3, "Valid owner already. Failing. Current owner:", dbOwner);
                _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);
                return PersistencePromise.reject(_this.persistenceError);
              }
              var newDbOwner = new DbOwner(_this.ownerId, Date.now());
              debug(LOG_TAG$3, "No valid owner. Acquiring owner lease. Current owner:", dbOwner, "New owner:", newDbOwner);
              return store.put("owner", newDbOwner);
            });
          });
        };
        IndexedDbPersistence.prototype.releaseOwnerLease = function() {
          var _this = this;
          return this.simpleDb.runTransaction("readwrite", [ DbOwner.store ], function(txn) {
            var store = txn.store(DbOwner.store);
            return store.get("owner").next(function(dbOwner) {
              if (null !== dbOwner && dbOwner.ownerId === _this.ownerId) {
                debug(LOG_TAG$3, "Releasing owner lease.");
                return store.delete("owner");
              }
              return PersistencePromise.resolve();
            });
          });
        };
        IndexedDbPersistence.prototype.ensureOwnerLease = function(txn) {
          var _this = this;
          var store = txn.store(DbOwner.store);
          return store.get("owner").next(function(dbOwner) {
            if (null === dbOwner || dbOwner.ownerId !== _this.ownerId) {
              _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);
              return PersistencePromise.reject(_this.persistenceError);
            }
            return PersistencePromise.resolve();
          });
        };
        IndexedDbPersistence.prototype.validOwner = function(dbOwner) {
          var now = Date.now();
          var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;
          var maxAcceptable = now;
          if (null === dbOwner) return false;
          if (dbOwner.leaseTimestampMs < minAcceptable) return false;
          if (dbOwner.leaseTimestampMs > maxAcceptable) {
            error("Persistence owner-lease is in the future. Discarding.", dbOwner);
            return false;
          }
          return dbOwner.ownerId !== this.getZombiedOwnerId();
        };
        IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function() {
          var _this = this;
          this.ownerLeaseRefreshHandle = setInterval(function() {
            var txResult = _this.simpleDb.runTransaction("readwrite", ALL_STORES, function(txn) {
              return _this.ensureOwnerLease(txn).next(function() {
                var store = txn.store(DbOwner.store);
                return store.put("owner", new DbOwner(_this.ownerId, Date.now()));
              });
            });
            txResult.catch(function(reason) {
              error(reason);
              _this.stopOwnerLeaseRefreshes();
            });
          }, OWNER_LEASE_REFRESH_INTERVAL_MS);
        };
        IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function() {
          if (this.ownerLeaseRefreshHandle) {
            clearInterval(this.ownerLeaseRefreshHandle);
            this.ownerLeaseRefreshHandle = null;
          }
        };
        IndexedDbPersistence.prototype.attachWindowUnloadHook = function() {
          var _this = this;
          if ("object" === typeof window && "function" === typeof window.addEventListener) {
            this.windowUnloadHandler = function() {
              _this.setZombiedOwnerId(_this.ownerId);
              _this.shutdown();
            };
            window.addEventListener("unload", this.windowUnloadHandler);
          }
        };
        IndexedDbPersistence.prototype.detachWindowUnloadHook = function() {
          if (this.windowUnloadHandler) {
            assert("object" === typeof window && "function" === typeof window.removeEventListener, "Expected 'window.removeEventListener' to be a function");
            window.removeEventListener("unload", this.windowUnloadHandler);
            this.windowUnloadHandler = null;
          }
        };
        IndexedDbPersistence.prototype.getZombiedOwnerId = function() {
          try {
            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());
            debug(LOG_TAG$3, "Zombied ownerID from LocalStorage:", zombiedOwnerId);
            return zombiedOwnerId;
          } catch (e) {
            error("Failed to get zombie owner id.", e);
            return null;
          }
        };
        IndexedDbPersistence.prototype.setZombiedOwnerId = function(zombieOwnerId) {
          try {
            null === zombieOwnerId ? window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey()) : window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);
          } catch (e) {
            error("Failed to set zombie owner id.", e);
          }
        };
        IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function() {
          return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;
        };
        IndexedDbPersistence.prototype.generateOwnerId = function() {
          return AutoId.newId();
        };
        IndexedDbPersistence.MAIN_DATABASE = "main";
        return IndexedDbPersistence;
      }();
      var LocalDocumentsView = function() {
        function LocalDocumentsView(remoteDocumentCache, mutationQueue) {
          this.remoteDocumentCache = remoteDocumentCache;
          this.mutationQueue = mutationQueue;
        }
        LocalDocumentsView.prototype.getDocument = function(transaction, key) {
          var _this = this;
          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, key).next(function(batches) {
            return _this.getDocumentInternal(transaction, key, batches);
          });
        };
        LocalDocumentsView.prototype.getDocumentInternal = function(transaction, key, inBatches) {
          return this.remoteDocumentCache.getEntry(transaction, key).next(function(doc) {
            for (var _i = 0, inBatches_1 = inBatches; _i < inBatches_1.length; _i++) {
              var batch = inBatches_1[_i];
              doc = batch.applyToLocalView(key, doc);
            }
            return doc;
          });
        };
        LocalDocumentsView.prototype.getDocuments = function(transaction, keys) {
          var _this = this;
          return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction, keys).next(function(batches) {
            var promises = [];
            var results = maybeDocumentMap();
            keys.forEach(function(key) {
              promises.push(_this.getDocumentInternal(transaction, key, batches).next(function(maybeDoc) {
                maybeDoc || (maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc()));
                results = results.insert(key, maybeDoc);
              }));
            });
            return PersistencePromise.waitFor(promises).next(function() {
              return results;
            });
          });
        };
        LocalDocumentsView.prototype.getDocumentsMatchingQuery = function(transaction, query) {
          return DocumentKey.isDocumentKey(query.path) ? this.getDocumentsMatchingDocumentQuery(transaction, query.path) : this.getDocumentsMatchingCollectionQuery(transaction, query);
        };
        LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function(transaction, docPath) {
          return this.getDocument(transaction, new DocumentKey(docPath)).next(function(maybeDoc) {
            var result = documentMap();
            maybeDoc instanceof Document && (result = result.insert(maybeDoc.key, maybeDoc));
            return result;
          });
        };
        LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function(transaction, query) {
          var _this = this;
          var results;
          return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query).next(function(queryResults) {
            results = queryResults;
            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);
          }).next(function(matchingMutationBatches) {
            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
              var batch = matchingMutationBatches_1[_i];
              for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                var mutation = _b[_a];
                var key = mutation.key;
                if (!query.path.isImmediateParentOf(key.path)) continue;
                var baseDoc = results.get(key);
                var mutatedDoc = mutation.applyToLocalView(baseDoc, baseDoc, batch.localWriteTime);
                !mutatedDoc || mutatedDoc instanceof NoDocument ? results = results.remove(key) : mutatedDoc instanceof Document ? results = results.insert(key, mutatedDoc) : fail("Unknown MaybeDocument: " + mutatedDoc);
              }
            }
          }).next(function() {
            results.forEach(function(key, doc) {
              query.matches(doc) || (results = results.remove(key));
            });
            return results;
          });
        };
        return LocalDocumentsView;
      }();
      var RemoteDocumentChangeBuffer = function() {
        function RemoteDocumentChangeBuffer(remoteDocumentCache) {
          this.remoteDocumentCache = remoteDocumentCache;
          this.changes = maybeDocumentMap();
        }
        RemoteDocumentChangeBuffer.prototype.addEntry = function(maybeDocument) {
          var changes = this.assertChanges();
          this.changes = changes.insert(maybeDocument.key, maybeDocument);
        };
        RemoteDocumentChangeBuffer.prototype.getEntry = function(transaction, documentKey) {
          var changes = this.assertChanges();
          var bufferedEntry = changes.get(documentKey);
          return bufferedEntry ? PersistencePromise.resolve(bufferedEntry) : this.remoteDocumentCache.getEntry(transaction, documentKey);
        };
        RemoteDocumentChangeBuffer.prototype.apply = function(transaction) {
          var _this = this;
          var changes = this.assertChanges();
          var promises = [];
          changes.forEach(function(key, maybeDoc) {
            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));
          });
          this.changes = null;
          return PersistencePromise.waitFor(promises);
        };
        RemoteDocumentChangeBuffer.prototype.assertChanges = function() {
          assert(null !== this.changes, "Changes have already been applied.");
          return this.changes;
        };
        return RemoteDocumentChangeBuffer;
      }();
      var LOG_TAG$4 = "LocalStore";
      var LocalStore = function() {
        function LocalStore(persistence, initialUser, garbageCollector) {
          this.persistence = persistence;
          this.garbageCollector = garbageCollector;
          this.localViewReferences = new ReferenceSet();
          this.targetIds = {};
          this.targetIdGenerator = TargetIdGenerator.forLocalStore();
          this.heldBatchResults = [];
          assert(persistence.started, "LocalStore was passed an unstarted persistence implementation");
          this.mutationQueue = persistence.getMutationQueue(initialUser);
          this.remoteDocuments = persistence.getRemoteDocumentCache();
          this.queryCache = persistence.getQueryCache();
          this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue);
          this.garbageCollector.addGarbageSource(this.localViewReferences);
          this.garbageCollector.addGarbageSource(this.queryCache);
          this.garbageCollector.addGarbageSource(this.mutationQueue);
        }
        LocalStore.prototype.start = function() {
          var _this = this;
          return this.persistence.runTransaction("Start LocalStore", function(txn) {
            return _this.startMutationQueue(txn).next(function() {
              return _this.startQueryCache(txn);
            });
          });
        };
        LocalStore.prototype.handleUserChange = function(user) {
          var _this = this;
          return this.persistence.runTransaction("Handle user change", function(txn) {
            var oldBatches;
            return _this.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches) {
              oldBatches = promisedOldBatches;
              _this.garbageCollector.removeGarbageSource(_this.mutationQueue);
              _this.mutationQueue = _this.persistence.getMutationQueue(user);
              _this.garbageCollector.addGarbageSource(_this.mutationQueue);
              return _this.startMutationQueue(txn);
            }).next(function() {
              _this.localDocuments = new LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);
              return _this.mutationQueue.getAllMutationBatches(txn);
            }).next(function(newBatches) {
              var changedKeys = documentKeySet();
              for (var _i = 0, _a = [ oldBatches, newBatches ]; _i < _a.length; _i++) {
                var batches = _a[_i];
                for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {
                  var batch = batches_1[_b];
                  for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {
                    var mutation = _d[_c];
                    changedKeys = changedKeys.add(mutation.key);
                  }
                }
              }
              return _this.localDocuments.getDocuments(txn, changedKeys);
            });
          });
        };
        LocalStore.prototype.startQueryCache = function(txn) {
          var _this = this;
          return this.queryCache.start(txn).next(function() {
            var targetId = _this.queryCache.getHighestTargetId();
            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);
          });
        };
        LocalStore.prototype.startMutationQueue = function(txn) {
          var _this = this;
          return this.mutationQueue.start(txn).next(function() {
            _this.heldBatchResults = [];
            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);
          }).next(function(highestAck) {
            return highestAck !== BATCHID_UNKNOWN ? _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck) : PersistencePromise.resolve([]);
          }).next(function(ackedBatches) {
            return ackedBatches.length > 0 ? _this.mutationQueue.removeMutationBatches(txn, ackedBatches) : PersistencePromise.resolve();
          });
        };
        LocalStore.prototype.localWrite = function(mutations) {
          var _this = this;
          return this.persistence.runTransaction("Locally write mutations", function(txn) {
            var batch;
            var localWriteTime = Timestamp.now();
            return _this.mutationQueue.addMutationBatch(txn, localWriteTime, mutations).next(function(promisedBatch) {
              batch = promisedBatch;
              var keys = batch.keys();
              return _this.localDocuments.getDocuments(txn, keys);
            }).next(function(changedDocuments) {
              return {
                batchId: batch.batchId,
                changes: changedDocuments
              };
            });
          });
        };
        LocalStore.prototype.acknowledgeBatch = function(batchResult) {
          var _this = this;
          return this.persistence.runTransaction("Acknowledge batch", function(txn) {
            var affected;
            return _this.mutationQueue.acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken).next(function() {
              if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {
                _this.heldBatchResults.push(batchResult);
                affected = documentKeySet();
                return PersistencePromise.resolve();
              }
              var documentBuffer_1 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);
              return _this.releaseBatchResults(txn, [ batchResult ], documentBuffer_1).next(function(promisedAffectedKeys) {
                affected = promisedAffectedKeys;
                return documentBuffer_1.apply(txn);
              });
            }).next(function() {
              return _this.mutationQueue.performConsistencyCheck(txn);
            }).next(function() {
              return _this.localDocuments.getDocuments(txn, affected);
            });
          });
        };
        LocalStore.prototype.rejectBatch = function(batchId) {
          var _this = this;
          return this.persistence.runTransaction("Reject batch", function(txn) {
            var toReject;
            var affectedKeys;
            return _this.mutationQueue.lookupMutationBatch(txn, batchId).next(function(promisedToReject) {
              assert(null != promisedToReject, "Attempt to reject nonexistent batch!");
              toReject = promisedToReject;
              return _this.mutationQueue.getHighestAcknowledgedBatchId(txn).next(function(lastAcked) {
                assert(batchId > lastAcked, "Acknowledged batches can't be rejected.");
                return toReject;
              });
            }).next(function() {
              return _this.removeMutationBatch(txn, toReject);
            }).next(function(promisedAffectedKeys) {
              affectedKeys = promisedAffectedKeys;
              return _this.mutationQueue.performConsistencyCheck(txn);
            }).next(function() {
              return _this.localDocuments.getDocuments(txn, affectedKeys);
            });
          });
        };
        LocalStore.prototype.getLastStreamToken = function() {
          var _this = this;
          return this.persistence.runTransaction("Get last stream token", function(txn) {
            return _this.mutationQueue.getLastStreamToken(txn);
          });
        };
        LocalStore.prototype.setLastStreamToken = function(streamToken) {
          var _this = this;
          return this.persistence.runTransaction("Set last stream token", function(txn) {
            return _this.mutationQueue.setLastStreamToken(txn, streamToken);
          });
        };
        LocalStore.prototype.getLastRemoteSnapshotVersion = function() {
          return this.queryCache.getLastRemoteSnapshotVersion();
        };
        LocalStore.prototype.applyRemoteEvent = function(remoteEvent) {
          var _this = this;
          var documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);
          return this.persistence.runTransaction("Apply remote event", function(txn) {
            var promises = [];
            var authoritativeUpdates = documentKeySet();
            forEachNumber(remoteEvent.targetChanges, function(targetId, change) {
              var queryData = _this.targetIds[targetId];
              if (!queryData) return;
              change.addedDocuments.forEach(function(key) {
                authoritativeUpdates = authoritativeUpdates.add(key);
              });
              change.modifiedDocuments.forEach(function(key) {
                authoritativeUpdates = authoritativeUpdates.add(key);
              });
              promises.push(_this.queryCache.removeMatchingKeys(txn, change.removedDocuments, targetId).next(function() {
                return _this.queryCache.addMatchingKeys(txn, change.addedDocuments, targetId);
              }));
              var resumeToken = change.resumeToken;
              if (resumeToken.length > 0) {
                var oldQueryData = queryData;
                queryData = queryData.copy({
                  resumeToken: resumeToken,
                  snapshotVersion: remoteEvent.snapshotVersion
                });
                _this.targetIds[targetId] = queryData;
                LocalStore.shouldPersistQueryData(oldQueryData, queryData, change) && promises.push(_this.queryCache.updateQueryData(txn, queryData));
              }
            });
            var changedDocKeys = documentKeySet();
            remoteEvent.documentUpdates.forEach(function(key, doc) {
              changedDocKeys = changedDocKeys.add(key);
              promises.push(documentBuffer.getEntry(txn, key).next(function(existingDoc) {
                null == existingDoc || doc.version.isEqual(SnapshotVersion.MIN) || authoritativeUpdates.has(doc.key) || doc.version.compareTo(existingDoc.version) >= 0 ? documentBuffer.addEntry(doc) : debug(LOG_TAG$4, "Ignoring outdated watch update for ", key, ". Current version:", existingDoc.version, " Watch version:", doc.version);
                _this.garbageCollector.addPotentialGarbageKey(key);
              }));
            });
            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();
            var remoteVersion = remoteEvent.snapshotVersion;
            if (!remoteVersion.isEqual(SnapshotVersion.MIN)) {
              assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, "Watch stream reverted to previous snapshot?? " + remoteVersion + " < " + lastRemoteVersion);
              promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));
            }
            var releasedWriteKeys;
            return PersistencePromise.waitFor(promises).next(function() {
              return _this.releaseHeldBatchResults(txn, documentBuffer);
            }).next(function(promisedReleasedWriteKeys) {
              releasedWriteKeys = promisedReleasedWriteKeys;
              return documentBuffer.apply(txn);
            }).next(function() {
              return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));
            });
          });
        };
        LocalStore.shouldPersistQueryData = function(oldQueryData, newQueryData, change) {
          if (0 === newQueryData.resumeToken.length) return false;
          if (0 === oldQueryData.resumeToken.length) return true;
          var timeDelta = newQueryData.snapshotVersion.toMicroseconds() - oldQueryData.snapshotVersion.toMicroseconds();
          if (timeDelta >= this.RESUME_TOKEN_MAX_AGE_MICROS) return true;
          var changes = change.addedDocuments.size + change.modifiedDocuments.size + change.removedDocuments.size;
          return changes > 0;
        };
        LocalStore.prototype.notifyLocalViewChanges = function(viewChanges) {
          for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {
            var viewChange = viewChanges_1[_i];
            this.localViewReferences.addReferences(viewChange.addedKeys, viewChange.targetId);
            this.localViewReferences.removeReferences(viewChange.removedKeys, viewChange.targetId);
          }
        };
        LocalStore.prototype.nextMutationBatch = function(afterBatchId) {
          var _this = this;
          return this.persistence.runTransaction("Get next mutation batch", function(txn) {
            void 0 === afterBatchId && (afterBatchId = BATCHID_UNKNOWN);
            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
          });
        };
        LocalStore.prototype.readDocument = function(key) {
          var _this = this;
          return this.persistence.runTransaction("read document", function(txn) {
            return _this.localDocuments.getDocument(txn, key);
          });
        };
        LocalStore.prototype.allocateQuery = function(query) {
          var _this = this;
          return this.persistence.runTransaction("Allocate query", function(txn) {
            var queryData;
            return _this.queryCache.getQueryData(txn, query).next(function(cached) {
              if (cached) {
                queryData = cached;
                return PersistencePromise.resolve();
              }
              var targetId = _this.targetIdGenerator.next();
              queryData = new QueryData(query, targetId, QueryPurpose.Listen);
              return _this.queryCache.addQueryData(txn, queryData);
            }).next(function() {
              assert(!_this.targetIds[queryData.targetId], "Tried to allocate an already allocated query: " + query);
              _this.targetIds[queryData.targetId] = queryData;
              return queryData;
            });
          });
        };
        LocalStore.prototype.releaseQuery = function(query) {
          var _this = this;
          return this.persistence.runTransaction("Release query", function(txn) {
            return _this.queryCache.getQueryData(txn, query).next(function(queryData) {
              assert(null != queryData, "Tried to release nonexistent query: " + query);
              var targetId = queryData.targetId;
              var cachedQueryData = _this.targetIds[targetId];
              _this.localViewReferences.removeReferencesForId(targetId);
              delete _this.targetIds[targetId];
              return _this.garbageCollector.isEager ? _this.queryCache.removeQueryData(txn, queryData) : cachedQueryData.snapshotVersion > queryData.snapshotVersion ? _this.queryCache.updateQueryData(txn, cachedQueryData) : PersistencePromise.resolve();
            }).next(function() {
              if (isEmpty(_this.targetIds)) {
                var documentBuffer_2 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);
                return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function() {
                  documentBuffer_2.apply(txn);
                });
              }
              return PersistencePromise.resolve();
            });
          });
        };
        LocalStore.prototype.executeQuery = function(query) {
          var _this = this;
          return this.persistence.runTransaction("Execute query", function(txn) {
            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);
          });
        };
        LocalStore.prototype.remoteDocumentKeys = function(targetId) {
          var _this = this;
          return this.persistence.runTransaction("Remote document keys", function(txn) {
            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);
          });
        };
        LocalStore.prototype.collectGarbage = function() {
          var _this = this;
          return this.persistence.runTransaction("Garbage collection", function(txn) {
            return _this.garbageCollector.collectGarbage(txn).next(function(garbage) {
              var promises = [];
              garbage.forEach(function(key) {
                promises.push(_this.remoteDocuments.removeEntry(txn, key));
              });
              return PersistencePromise.waitFor(promises);
            });
          });
        };
        LocalStore.prototype.releaseHeldBatchResults = function(txn, documentBuffer) {
          var toRelease = [];
          for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {
            var batchResult = _a[_i];
            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) break;
            toRelease.push(batchResult);
          }
          if (0 === toRelease.length) return PersistencePromise.resolve(documentKeySet());
          this.heldBatchResults.splice(0, toRelease.length);
          return this.releaseBatchResults(txn, toRelease, documentBuffer);
        };
        LocalStore.prototype.isRemoteUpToVersion = function(version) {
          var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();
          return version.compareTo(lastRemoteVersion) <= 0 || isEmpty(this.targetIds);
        };
        LocalStore.prototype.shouldHoldBatchResult = function(version) {
          return !this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0;
        };
        LocalStore.prototype.releaseBatchResults = function(txn, batchResults, documentBuffer) {
          var _this = this;
          var promiseChain = PersistencePromise.resolve();
          var _loop_1 = function(batchResult) {
            promiseChain = promiseChain.next(function() {
              return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);
            });
          };
          for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {
            var batchResult = batchResults_1[_i];
            _loop_1(batchResult);
          }
          return promiseChain.next(function() {
            return _this.removeMutationBatches(txn, batchResults.map(function(result) {
              return result.batch;
            }));
          });
        };
        LocalStore.prototype.removeMutationBatch = function(txn, batch) {
          return this.removeMutationBatches(txn, [ batch ]);
        };
        LocalStore.prototype.removeMutationBatches = function(txn, batches) {
          var affectedDocs = documentKeySet();
          for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {
            var batch = batches_2[_i];
            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
              var mutation = _b[_a];
              var key = mutation.key;
              affectedDocs = affectedDocs.add(key);
            }
          }
          return this.mutationQueue.removeMutationBatches(txn, batches).next(function() {
            return affectedDocs;
          });
        };
        LocalStore.prototype.applyWriteToRemoteDocuments = function(txn, batchResult, documentBuffer) {
          var batch = batchResult.batch;
          var docKeys = batch.keys();
          var promiseChain = PersistencePromise.resolve();
          docKeys.forEach(function(docKey) {
            promiseChain = promiseChain.next(function() {
              return documentBuffer.getEntry(txn, docKey);
            }).next(function(remoteDoc) {
              var doc = remoteDoc;
              var ackVersion = batchResult.docVersions.get(docKey);
              assert(null !== ackVersion, "ackVersions should contain every doc in the write.");
              if (!doc || doc.version.compareTo(ackVersion) < 0) {
                doc = batch.applyToRemoteDocument(docKey, doc, batchResult);
                doc ? documentBuffer.addEntry(doc) : assert(!remoteDoc, "Mutation batch " + batch + " applied to document " + remoteDoc + " resulted in null");
              }
            });
          });
          return promiseChain;
        };
        LocalStore.RESUME_TOKEN_MAX_AGE_MICROS = 3e8;
        return LocalStore;
      }();
      var MemoryMutationQueue = function() {
        function MemoryMutationQueue() {
          this.mutationQueue = [];
          this.nextBatchId = 1;
          this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;
          this.lastStreamToken = emptyByteString();
          this.garbageCollector = null;
          this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);
        }
        MemoryMutationQueue.prototype.start = function(transaction) {
          if (0 === this.mutationQueue.length) {
            this.nextBatchId = 1;
            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;
          }
          assert(this.highestAcknowledgedBatchId < this.nextBatchId, "highestAcknowledgedBatchId must be less than the nextBatchId");
          return PersistencePromise.resolve();
        };
        MemoryMutationQueue.prototype.checkEmpty = function(transaction) {
          return PersistencePromise.resolve(0 === this.mutationQueue.length);
        };
        MemoryMutationQueue.prototype.getNextBatchId = function(transaction) {
          return PersistencePromise.resolve(this.nextBatchId);
        };
        MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function(transaction) {
          return PersistencePromise.resolve(this.highestAcknowledgedBatchId);
        };
        MemoryMutationQueue.prototype.acknowledgeBatch = function(transaction, batch, streamToken) {
          var batchId = batch.batchId;
          assert(batchId > this.highestAcknowledgedBatchId, "Mutation batchIDs must be acknowledged in order");
          var batchIndex = this.indexOfExistingBatchId(batchId, "acknowledged");
          var check = this.mutationQueue[batchIndex];
          assert(batchId === check.batchId, "Queue ordering failure: expected batch " + batchId + ", got batch " + check.batchId);
          assert(!check.isTombstone(), "Can't acknowledge a previously removed batch");
          this.highestAcknowledgedBatchId = batchId;
          this.lastStreamToken = streamToken;
          return PersistencePromise.resolve();
        };
        MemoryMutationQueue.prototype.getLastStreamToken = function(transaction) {
          return PersistencePromise.resolve(this.lastStreamToken);
        };
        MemoryMutationQueue.prototype.setLastStreamToken = function(transaction, streamToken) {
          this.lastStreamToken = streamToken;
          return PersistencePromise.resolve();
        };
        MemoryMutationQueue.prototype.addMutationBatch = function(transaction, localWriteTime, mutations) {
          assert(0 !== mutations.length, "Mutation batches should not be empty");
          var batchId = this.nextBatchId;
          this.nextBatchId++;
          if (this.mutationQueue.length > 0) {
            var prior = this.mutationQueue[this.mutationQueue.length - 1];
            assert(prior.batchId < batchId, "Mutation batchIDs must be monotonically increasing order");
          }
          var batch = new MutationBatch(batchId, localWriteTime, mutations);
          this.mutationQueue.push(batch);
          for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
            var mutation = mutations_1[_i];
            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));
          }
          return PersistencePromise.resolve(batch);
        };
        MemoryMutationQueue.prototype.lookupMutationBatch = function(transaction, batchId) {
          return PersistencePromise.resolve(this.findMutationBatch(batchId));
        };
        MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
          var size = this.mutationQueue.length;
          var nextBatchId = Math.max(batchId, this.highestAcknowledgedBatchId) + 1;
          var rawIndex = this.indexOfBatchId(nextBatchId);
          var index = rawIndex < 0 ? 0 : rawIndex;
          for (;index < size; index++) {
            var batch = this.mutationQueue[index];
            if (!batch.isTombstone()) return PersistencePromise.resolve(batch);
          }
          return PersistencePromise.resolve(null);
        };
        MemoryMutationQueue.prototype.getAllMutationBatches = function(transaction) {
          return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));
        };
        MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function(transaction, batchId) {
          var count = this.mutationQueue.length;
          var endIndex = this.indexOfBatchId(batchId);
          endIndex < 0 ? endIndex = 0 : endIndex >= count ? endIndex = count : endIndex++;
          return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));
        };
        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
          var _this = this;
          var start = new DocReference(documentKey, 0);
          var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
          var result = [];
          this.batchesByDocumentKey.forEachInRange([ start, end ], function(ref) {
            assert(documentKey.isEqual(ref.key), "Should only iterate over a single key's batches");
            var batch = _this.findMutationBatch(ref.targetOrBatchId);
            assert(null !== batch, "Batches in the index must exist in the main table");
            result.push(batch);
          });
          return PersistencePromise.resolve(result);
        };
        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
          var _this = this;
          var uniqueBatchIDs = new SortedSet(primitiveComparator);
          documentKeys.forEach(function(documentKey) {
            var start = new DocReference(documentKey, 0);
            var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
            _this.batchesByDocumentKey.forEachInRange([ start, end ], function(ref) {
              assert(documentKey.isEqual(ref.key), "For each key, should only iterate over a single key's batches");
              uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
            });
          });
          return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
        };
        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query) {
          var prefix = query.path;
          var immediateChildrenPathLength = prefix.length + 1;
          var startPath = prefix;
          DocumentKey.isDocumentKey(startPath) || (startPath = startPath.child(""));
          var start = new DocReference(new DocumentKey(startPath), 0);
          var uniqueBatchIDs = new SortedSet(primitiveComparator);
          this.batchesByDocumentKey.forEachWhile(function(ref) {
            var rowKeyPath = ref.key.path;
            if (prefix.isPrefixOf(rowKeyPath)) {
              rowKeyPath.length === immediateChildrenPathLength && (uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId));
              return true;
            }
            return false;
          }, start);
          return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
        };
        MemoryMutationQueue.prototype.findMutationBatches = function(batchIDs) {
          var _this = this;
          var result = [];
          batchIDs.forEach(function(batchId) {
            var batch = _this.findMutationBatch(batchId);
            null !== batch && result.push(batch);
          });
          return result;
        };
        MemoryMutationQueue.prototype.removeMutationBatches = function(transaction, batches) {
          var batchCount = batches.length;
          assert(batchCount > 0, "Should not remove mutations when none exist.");
          var firstBatchId = batches[0].batchId;
          var queueCount = this.mutationQueue.length;
          var startIndex = this.indexOfExistingBatchId(firstBatchId, "removed");
          assert(this.mutationQueue[startIndex].batchId === firstBatchId, "Removed batches must exist in the queue");
          var batchIndex = 1;
          var queueIndex = startIndex + 1;
          while (batchIndex < batchCount && queueIndex < queueCount) {
            var batch = this.mutationQueue[queueIndex];
            if (batch.isTombstone()) {
              queueIndex++;
              continue;
            }
            assert(batch.batchId === batches[batchIndex].batchId, "Removed batches must be contiguous in the queue");
            batchIndex++;
            queueIndex++;
          }
          if (0 === startIndex) {
            for (;queueIndex < queueCount; queueIndex++) {
              var batch = this.mutationQueue[queueIndex];
              if (!batch.isTombstone()) break;
            }
            var length_1 = queueIndex - startIndex;
            this.mutationQueue.splice(startIndex, length_1);
          } else for (var i = startIndex; i < queueIndex; i++) this.mutationQueue[i] = this.mutationQueue[i].toTombstone();
          var references = this.batchesByDocumentKey;
          for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            var batchId = batch.batchId;
            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
              var mutation = _b[_a];
              var key = mutation.key;
              null !== this.garbageCollector && this.garbageCollector.addPotentialGarbageKey(key);
              var ref = new DocReference(key, batchId);
              references = references.delete(ref);
            }
          }
          this.batchesByDocumentKey = references;
          return PersistencePromise.resolve();
        };
        MemoryMutationQueue.prototype.setGarbageCollector = function(garbageCollector) {
          this.garbageCollector = garbageCollector;
        };
        MemoryMutationQueue.prototype.containsKey = function(txn, key) {
          var ref = new DocReference(key, 0);
          var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);
          return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));
        };
        MemoryMutationQueue.prototype.performConsistencyCheck = function(txn) {
          0 === this.mutationQueue.length && assert(this.batchesByDocumentKey.isEmpty(), "Document leak -- detected dangling mutation references when queue is empty.");
          return PersistencePromise.resolve();
        };
        MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function(endIndex) {
          var result = [];
          for (var i = 0; i < endIndex; i++) {
            var batch = this.mutationQueue[i];
            batch.isTombstone() || result.push(batch);
          }
          return result;
        };
        MemoryMutationQueue.prototype.indexOfExistingBatchId = function(batchId, action) {
          var index = this.indexOfBatchId(batchId);
          assert(index >= 0 && index < this.mutationQueue.length, "Batches must exist to be " + action);
          return index;
        };
        MemoryMutationQueue.prototype.indexOfBatchId = function(batchId) {
          if (0 === this.mutationQueue.length) return 0;
          var firstBatchId = this.mutationQueue[0].batchId;
          return batchId - firstBatchId;
        };
        MemoryMutationQueue.prototype.findMutationBatch = function(batchId) {
          var index = this.indexOfBatchId(batchId);
          if (index < 0 || index >= this.mutationQueue.length) return null;
          var batch = this.mutationQueue[index];
          assert(batch.batchId === batchId, "If found batch must match");
          return batch.isTombstone() ? null : batch;
        };
        return MemoryMutationQueue;
      }();
      var MemoryQueryCache = function() {
        function MemoryQueryCache() {
          this.queries = new ObjectMap(function(q) {
            return q.canonicalId();
          });
          this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;
          this.highestTargetId = 0;
          this.references = new ReferenceSet();
          this.targetCount = 0;
        }
        MemoryQueryCache.prototype.start = function(transaction) {
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function() {
          return this.lastRemoteSnapshotVersion;
        };
        MemoryQueryCache.prototype.getHighestTargetId = function() {
          return this.highestTargetId;
        };
        MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function(transaction, snapshotVersion) {
          this.lastRemoteSnapshotVersion = snapshotVersion;
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.saveQueryData = function(queryData) {
          this.queries.set(queryData.query, queryData);
          var targetId = queryData.targetId;
          targetId > this.highestTargetId && (this.highestTargetId = targetId);
        };
        MemoryQueryCache.prototype.addQueryData = function(transaction, queryData) {
          assert(!this.queries.has(queryData.query), "Adding a query that already exists");
          this.saveQueryData(queryData);
          this.targetCount += 1;
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.updateQueryData = function(transaction, queryData) {
          assert(this.queries.has(queryData.query), "Updating a non-existent query");
          this.saveQueryData(queryData);
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.removeQueryData = function(transaction, queryData) {
          assert(this.targetCount > 0, "Removing a target from an empty cache");
          assert(this.queries.has(queryData.query), "Removing a non-existent target from the cache");
          this.queries.delete(queryData.query);
          this.references.removeReferencesForId(queryData.targetId);
          this.targetCount -= 1;
          return PersistencePromise.resolve();
        };
        Object.defineProperty(MemoryQueryCache.prototype, "count", {
          get: function() {
            return this.targetCount;
          },
          enumerable: true,
          configurable: true
        });
        MemoryQueryCache.prototype.getQueryData = function(transaction, query) {
          var queryData = this.queries.get(query) || null;
          return PersistencePromise.resolve(queryData);
        };
        MemoryQueryCache.prototype.addMatchingKeys = function(txn, keys, targetId) {
          this.references.addReferences(keys, targetId);
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.removeMatchingKeys = function(txn, keys, targetId) {
          this.references.removeReferences(keys, targetId);
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
          this.references.removeReferencesForId(targetId);
          return PersistencePromise.resolve();
        };
        MemoryQueryCache.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
          var matchingKeys = this.references.referencesForId(targetId);
          return PersistencePromise.resolve(matchingKeys);
        };
        MemoryQueryCache.prototype.setGarbageCollector = function(gc) {
          this.references.setGarbageCollector(gc);
        };
        MemoryQueryCache.prototype.containsKey = function(txn, key) {
          return this.references.containsKey(txn, key);
        };
        return MemoryQueryCache;
      }();
      var MemoryRemoteDocumentCache = function() {
        function MemoryRemoteDocumentCache() {
          this.docs = maybeDocumentMap();
        }
        MemoryRemoteDocumentCache.prototype.addEntry = function(transaction, maybeDocument) {
          this.docs = this.docs.insert(maybeDocument.key, maybeDocument);
          return PersistencePromise.resolve();
        };
        MemoryRemoteDocumentCache.prototype.removeEntry = function(transaction, documentKey) {
          this.docs = this.docs.remove(documentKey);
          return PersistencePromise.resolve();
        };
        MemoryRemoteDocumentCache.prototype.getEntry = function(transaction, documentKey) {
          return PersistencePromise.resolve(this.docs.get(documentKey));
        };
        MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function(transaction, query) {
          var results = documentMap();
          var prefix = new DocumentKey(query.path.child(""));
          var iterator = this.docs.getIteratorFrom(prefix);
          while (iterator.hasNext()) {
            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;
            if (!query.path.isPrefixOf(key.path)) break;
            maybeDoc instanceof Document && query.matches(maybeDoc) && (results = results.insert(maybeDoc.key, maybeDoc));
          }
          return PersistencePromise.resolve(results);
        };
        return MemoryRemoteDocumentCache;
      }();
      var LOG_TAG$5 = "MemoryPersistence";
      var MemoryPersistence = function() {
        function MemoryPersistence() {
          this.mutationQueues = {};
          this.remoteDocumentCache = new MemoryRemoteDocumentCache();
          this.queryCache = new MemoryQueryCache();
          this._started = false;
        }
        MemoryPersistence.prototype.start = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              assert(!this._started, "MemoryPersistence double-started!");
              this._started = true;
              return [ 2 ];
            });
          });
        };
        MemoryPersistence.prototype.shutdown = function(deleteData) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              assert(this._started, "MemoryPersistence shutdown without start!");
              this._started = false;
              return [ 2 ];
            });
          });
        };
        Object.defineProperty(MemoryPersistence.prototype, "started", {
          get: function() {
            return this._started;
          },
          enumerable: true,
          configurable: true
        });
        MemoryPersistence.prototype.getMutationQueue = function(user) {
          var queue = this.mutationQueues[user.toKey()];
          if (!queue) {
            queue = new MemoryMutationQueue();
            this.mutationQueues[user.toKey()] = queue;
          }
          return queue;
        };
        MemoryPersistence.prototype.getQueryCache = function() {
          return this.queryCache;
        };
        MemoryPersistence.prototype.getRemoteDocumentCache = function() {
          return this.remoteDocumentCache;
        };
        MemoryPersistence.prototype.runTransaction = function(action, operation) {
          debug(LOG_TAG$5, "Starting transaction:", action);
          return operation(new MemoryTransaction()).toPromise();
        };
        return MemoryPersistence;
      }();
      var MemoryTransaction = function() {
        function MemoryTransaction() {}
        return MemoryTransaction;
      }();
      var NoOpGarbageCollector = function() {
        function NoOpGarbageCollector() {
          this.isEager = false;
        }
        NoOpGarbageCollector.prototype.addGarbageSource = function(garbageSource) {};
        NoOpGarbageCollector.prototype.removeGarbageSource = function(garbageSource) {};
        NoOpGarbageCollector.prototype.addPotentialGarbageKey = function(key) {};
        NoOpGarbageCollector.prototype.collectGarbage = function(txn) {
          return PersistencePromise.resolve(documentKeySet());
        };
        return NoOpGarbageCollector;
      }();
      var TimerId;
      (function(TimerId) {
        TimerId["All"] = "all";
        TimerId["ListenStreamIdle"] = "listen_stream_idle";
        TimerId["ListenStreamConnectionBackoff"] = "listen_stream_connection_backoff";
        TimerId["WriteStreamIdle"] = "write_stream_idle";
        TimerId["WriteStreamConnectionBackoff"] = "write_stream_connection_backoff";
        TimerId["OnlineStateTimeout"] = "online_state_timeout";
      })(TimerId || (TimerId = {}));
      var DelayedOperation = function() {
        function DelayedOperation(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
          this.asyncQueue = asyncQueue;
          this.timerId = timerId;
          this.targetTimeMs = targetTimeMs;
          this.op = op;
          this.removalCallback = removalCallback;
          this.deferred = new Deferred$1();
          this.then = this.deferred.promise.then.bind(this.deferred.promise);
          this.catch = this.deferred.promise.catch.bind(this.deferred.promise);
          this.deferred.promise.catch(function(err) {});
        }
        DelayedOperation.createAndSchedule = function(asyncQueue, timerId, delayMs, op, removalCallback) {
          var targetTime = Date.now() + delayMs;
          var delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);
          delayedOp.start(delayMs);
          return delayedOp;
        };
        DelayedOperation.prototype.start = function(delayMs) {
          var _this = this;
          this.timerHandle = setTimeout(function() {
            return _this.handleDelayElapsed();
          }, delayMs);
        };
        DelayedOperation.prototype.skipDelay = function() {
          return this.handleDelayElapsed();
        };
        DelayedOperation.prototype.cancel = function(reason) {
          if (null !== this.timerHandle) {
            this.clearTimeout();
            this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
          }
        };
        DelayedOperation.prototype.handleDelayElapsed = function() {
          var _this = this;
          this.asyncQueue.enqueue(function() {
            if (null !== _this.timerHandle) {
              _this.clearTimeout();
              return _this.op().then(function(result) {
                return _this.deferred.resolve(result);
              });
            }
            return Promise.resolve();
          });
        };
        DelayedOperation.prototype.clearTimeout = function() {
          if (null !== this.timerHandle) {
            this.removalCallback(this);
            clearTimeout(this.timerHandle);
            this.timerHandle = null;
          }
        };
        return DelayedOperation;
      }();
      var AsyncQueue = function() {
        function AsyncQueue() {
          this.tail = Promise.resolve();
          this.delayedOperations = [];
          this.operationInProgress = false;
        }
        AsyncQueue.prototype.enqueue = function(op) {
          var _this = this;
          this.verifyNotFailed();
          var newTail = this.tail.then(function() {
            _this.operationInProgress = true;
            return op().catch(function(error$$1) {
              _this.failure = error$$1;
              _this.operationInProgress = false;
              var message = error$$1.stack || error$$1.message || "";
              error("INTERNAL UNHANDLED ERROR: ", message);
              message.indexOf("Firestore Test Simulated Error") < 0 && setTimeout(function() {
                throw error$$1;
              }, 0);
              throw error$$1;
            }).then(function(result) {
              _this.operationInProgress = false;
              return result;
            });
          });
          this.tail = newTail;
          return newTail;
        };
        AsyncQueue.prototype.enqueueAfterDelay = function(timerId, delayMs, op) {
          var _this = this;
          this.verifyNotFailed();
          assert(!this.containsDelayedOperation(timerId), "Attempted to schedule multiple operations with timer id " + timerId + ".");
          var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function(op) {
            return _this.removeDelayedOperation(op);
          });
          this.delayedOperations.push(delayedOp);
          return delayedOp;
        };
        AsyncQueue.prototype.verifyNotFailed = function() {
          this.failure && fail("AsyncQueue is already failed: " + (this.failure.stack || this.failure.message));
        };
        AsyncQueue.prototype.verifyOperationInProgress = function() {
          assert(this.operationInProgress, "verifyOpInProgress() called when no op in progress on this queue.");
        };
        AsyncQueue.prototype.drain = function() {
          return this.enqueue(function() {
            return Promise.resolve();
          });
        };
        AsyncQueue.prototype.containsDelayedOperation = function(timerId) {
          return this.delayedOperations.findIndex(function(op) {
            return op.timerId === timerId;
          }) >= 0;
        };
        AsyncQueue.prototype.runDelayedOperationsEarly = function(lastTimerId) {
          var _this = this;
          return this.drain().then(function() {
            assert(lastTimerId === TimerId.All || _this.containsDelayedOperation(lastTimerId), "Attempted to drain to missing operation " + lastTimerId);
            _this.delayedOperations.sort(function(a, b) {
              return a.targetTimeMs - b.targetTimeMs;
            });
            for (var _i = 0, _a = _this.delayedOperations; _i < _a.length; _i++) {
              var op = _a[_i];
              op.skipDelay();
              if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) break;
            }
            return _this.drain();
          });
        };
        AsyncQueue.prototype.removeDelayedOperation = function(op) {
          var index = this.delayedOperations.indexOf(op);
          assert(index >= 0, "Delayed operation not found.");
          this.delayedOperations.splice(index, 1);
        };
        return AsyncQueue;
      }();
      var LOG_TAG$6 = "ExponentialBackoff";
      var ExponentialBackoff = function() {
        function ExponentialBackoff(queue, timerId, initialDelayMs, backoffFactor, maxDelayMs) {
          this.queue = queue;
          this.timerId = timerId;
          this.initialDelayMs = initialDelayMs;
          this.backoffFactor = backoffFactor;
          this.maxDelayMs = maxDelayMs;
          this.timerPromise = null;
          this.reset();
        }
        ExponentialBackoff.prototype.reset = function() {
          this.currentBaseMs = 0;
        };
        ExponentialBackoff.prototype.resetToMax = function() {
          this.currentBaseMs = this.maxDelayMs;
        };
        ExponentialBackoff.prototype.backoffAndRun = function(op) {
          this.cancel();
          var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();
          this.currentBaseMs > 0 && debug(LOG_TAG$6, "Backing off for " + delayWithJitterMs + " ms (base delay: " + this.currentBaseMs + " ms)");
          this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, delayWithJitterMs, op);
          this.currentBaseMs *= this.backoffFactor;
          this.currentBaseMs < this.initialDelayMs && (this.currentBaseMs = this.initialDelayMs);
          this.currentBaseMs > this.maxDelayMs && (this.currentBaseMs = this.maxDelayMs);
        };
        ExponentialBackoff.prototype.cancel = function() {
          if (null !== this.timerPromise) {
            this.timerPromise.cancel();
            this.timerPromise = null;
          }
        };
        ExponentialBackoff.prototype.jitterDelayMs = function() {
          return (Math.random() - .5) * this.currentBaseMs;
        };
        return ExponentialBackoff;
      }();
      var LOG_TAG$7 = "PersistentStream";
      var PersistentStreamState;
      (function(PersistentStreamState) {
        PersistentStreamState[PersistentStreamState["Initial"] = 0] = "Initial";
        PersistentStreamState[PersistentStreamState["Starting"] = 1] = "Starting";
        PersistentStreamState[PersistentStreamState["Open"] = 2] = "Open";
        PersistentStreamState[PersistentStreamState["Error"] = 3] = "Error";
        PersistentStreamState[PersistentStreamState["Backoff"] = 4] = "Backoff";
      })(PersistentStreamState || (PersistentStreamState = {}));
      var BACKOFF_INITIAL_DELAY_MS = 1e3;
      var BACKOFF_MAX_DELAY_MS = 6e4;
      var BACKOFF_FACTOR = 1.5;
      var IDLE_TIMEOUT_MS = 6e4;
      var PersistentStream = function() {
        function PersistentStream(queue, connectionTimerId, idleTimerId, connection, credentialsProvider, listener) {
          this.queue = queue;
          this.idleTimerId = idleTimerId;
          this.connection = connection;
          this.credentialsProvider = credentialsProvider;
          this.listener = listener;
          this.state = PersistentStreamState.Initial;
          this.closeCount = 0;
          this.idleTimer = null;
          this.stream = null;
          this.backoff = new ExponentialBackoff(queue, connectionTimerId, BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);
        }
        PersistentStream.prototype.isStarted = function() {
          return this.state === PersistentStreamState.Starting || this.state === PersistentStreamState.Open || this.state === PersistentStreamState.Backoff;
        };
        PersistentStream.prototype.isOpen = function() {
          return this.state === PersistentStreamState.Open;
        };
        PersistentStream.prototype.start = function() {
          if (this.state === PersistentStreamState.Error) {
            this.performBackoff();
            return;
          }
          assert(this.state === PersistentStreamState.Initial, "Already started");
          this.auth();
        };
        PersistentStream.prototype.stop = function() {
          this.isStarted() && this.close(PersistentStreamState.Initial);
        };
        PersistentStream.prototype.inhibitBackoff = function() {
          assert(!this.isStarted(), "Can only inhibit backoff in a stopped state");
          this.state = PersistentStreamState.Initial;
          this.backoff.reset();
        };
        PersistentStream.prototype.markIdle = function() {
          var _this = this;
          this.isOpen() && null === this.idleTimer && (this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function() {
            return _this.handleIdleCloseTimer();
          }));
        };
        PersistentStream.prototype.sendRequest = function(msg) {
          this.cancelIdleCheck();
          this.stream.send(msg);
        };
        PersistentStream.prototype.handleIdleCloseTimer = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              if (this.isOpen()) return [ 2, this.close(PersistentStreamState.Initial) ];
              return [ 2 ];
            });
          });
        };
        PersistentStream.prototype.cancelIdleCheck = function() {
          if (this.idleTimer) {
            this.idleTimer.cancel();
            this.idleTimer = null;
          }
        };
        PersistentStream.prototype.close = function(finalState, error$$1) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                assert(this.isStarted(), "Only started streams should be closed.");
                assert(finalState === PersistentStreamState.Error || isNullOrUndefined(error$$1), "Can't provide an error when not in an error state.");
                this.cancelIdleCheck();
                this.backoff.cancel();
                this.closeCount++;
                if (finalState !== PersistentStreamState.Error) this.backoff.reset(); else if (error$$1 && error$$1.code === Code.RESOURCE_EXHAUSTED) {
                  error(error$$1.toString());
                  error("Using maximum backoff delay to prevent overloading the backend.");
                  this.backoff.resetToMax();
                } else error$$1 && error$$1.code === Code.UNAUTHENTICATED && this.credentialsProvider.invalidateToken();
                if (null !== this.stream) {
                  this.tearDown();
                  this.stream.close();
                  this.stream = null;
                }
                this.state = finalState;
                return [ 4, this.listener.onClose(error$$1) ];

               case 1:
                _a.sent();
                return [ 2 ];
              }
            });
          });
        };
        PersistentStream.prototype.tearDown = function() {};
        PersistentStream.prototype.auth = function() {
          var _this = this;
          assert(this.state === PersistentStreamState.Initial, "Must be in initial state to auth");
          this.state = PersistentStreamState.Starting;
          var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
          var closeCount = this.closeCount;
          this.credentialsProvider.getToken().then(function(token) {
            _this.closeCount === closeCount && _this.startStream(token);
          }, function(error$$1) {
            dispatchIfNotClosed(function() {
              var rpcError = new FirestoreError(Code.UNKNOWN, "Fetching auth token failed: " + error$$1.message);
              return _this.handleStreamClose(rpcError);
            });
          });
        };
        PersistentStream.prototype.startStream = function(token) {
          var _this = this;
          assert(this.state === PersistentStreamState.Starting, "Trying to start stream in a non-starting state");
          var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
          this.stream = this.startRpc(token);
          this.stream.onOpen(function() {
            dispatchIfNotClosed(function() {
              assert(_this.state === PersistentStreamState.Starting, "Expected stream to be in state Starting, but was " + _this.state);
              _this.state = PersistentStreamState.Open;
              return _this.listener.onOpen();
            });
          });
          this.stream.onClose(function(error$$1) {
            dispatchIfNotClosed(function() {
              return _this.handleStreamClose(error$$1);
            });
          });
          this.stream.onMessage(function(msg) {
            dispatchIfNotClosed(function() {
              return _this.onMessage(msg);
            });
          });
        };
        PersistentStream.prototype.performBackoff = function() {
          var _this = this;
          assert(this.state === PersistentStreamState.Error, "Should only perform backoff when in Error state");
          this.state = PersistentStreamState.Backoff;
          this.backoff.backoffAndRun(function() {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              return tslib_1.__generator(this, function(_a) {
                assert(this.state === PersistentStreamState.Backoff, "Backoff elapsed but state is now: " + this.state);
                this.state = PersistentStreamState.Initial;
                this.start();
                assert(this.isStarted(), "PersistentStream should have started");
                return [ 2 ];
              });
            });
          });
        };
        PersistentStream.prototype.handleStreamClose = function(error$$1) {
          assert(this.isStarted(), "Can't handle server close on non-started stream");
          debug(LOG_TAG$7, "close with error: " + error$$1);
          this.stream = null;
          return this.close(PersistentStreamState.Error, error$$1);
        };
        PersistentStream.prototype.getCloseGuardedDispatcher = function(startCloseCount) {
          var _this = this;
          return function(fn) {
            _this.queue.enqueue(function() {
              if (_this.closeCount === startCloseCount) return fn();
              debug(LOG_TAG$7, "stream callback skipped by getCloseGuardedDispatcher.");
              return Promise.resolve();
            });
          };
        };
        return PersistentStream;
      }();
      var PersistentListenStream = function(_super) {
        tslib_1.__extends(PersistentListenStream, _super);
        function PersistentListenStream(queue, connection, credentials, serializer, listener) {
          var _this = _super.call(this, queue, TimerId.ListenStreamConnectionBackoff, TimerId.ListenStreamIdle, connection, credentials, listener) || this;
          _this.serializer = serializer;
          return _this;
        }
        PersistentListenStream.prototype.startRpc = function(token) {
          return this.connection.openStream("Listen", token);
        };
        PersistentListenStream.prototype.onMessage = function(watchChangeProto) {
          this.backoff.reset();
          var watchChange = this.serializer.fromWatchChange(watchChangeProto);
          var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);
          return this.listener.onWatchChange(watchChange, snapshot);
        };
        PersistentListenStream.prototype.watch = function(queryData) {
          var request = {};
          request.database = this.serializer.encodedDatabaseId;
          request.addTarget = this.serializer.toTarget(queryData);
          var labels = this.serializer.toListenRequestLabels(queryData);
          labels && (request.labels = labels);
          this.sendRequest(request);
        };
        PersistentListenStream.prototype.unwatch = function(targetId) {
          var request = {};
          request.database = this.serializer.encodedDatabaseId;
          request.removeTarget = targetId;
          this.sendRequest(request);
        };
        return PersistentListenStream;
      }(PersistentStream);
      var PersistentWriteStream = function(_super) {
        tslib_1.__extends(PersistentWriteStream, _super);
        function PersistentWriteStream(queue, connection, credentials, serializer, listener) {
          var _this = _super.call(this, queue, TimerId.WriteStreamConnectionBackoff, TimerId.WriteStreamIdle, connection, credentials, listener) || this;
          _this.serializer = serializer;
          _this.handshakeComplete_ = false;
          return _this;
        }
        Object.defineProperty(PersistentWriteStream.prototype, "handshakeComplete", {
          get: function() {
            return this.handshakeComplete_;
          },
          enumerable: true,
          configurable: true
        });
        PersistentWriteStream.prototype.start = function() {
          this.handshakeComplete_ = false;
          _super.prototype.start.call(this);
        };
        PersistentWriteStream.prototype.tearDown = function() {
          this.handshakeComplete_ && this.writeMutations([]);
        };
        PersistentWriteStream.prototype.startRpc = function(token) {
          return this.connection.openStream("Write", token);
        };
        PersistentWriteStream.prototype.onMessage = function(responseProto) {
          assert(!!responseProto.streamToken, "Got a write response without a stream token");
          this.lastStreamToken = responseProto.streamToken;
          if (this.handshakeComplete_) {
            this.backoff.reset();
            var results = this.serializer.fromWriteResults(responseProto.writeResults);
            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);
            return this.listener.onMutationResult(commitVersion, results);
          }
          assert(!responseProto.writeResults || 0 === responseProto.writeResults.length, "Got mutation results for handshake");
          this.handshakeComplete_ = true;
          return this.listener.onHandshakeComplete();
        };
        PersistentWriteStream.prototype.writeHandshake = function() {
          assert(this.isOpen(), "Writing handshake requires an opened stream");
          assert(!this.handshakeComplete_, "Handshake already completed");
          var request = {};
          request.database = this.serializer.encodedDatabaseId;
          this.sendRequest(request);
        };
        PersistentWriteStream.prototype.writeMutations = function(mutations) {
          var _this = this;
          assert(this.isOpen(), "Writing mutations requires an opened stream");
          assert(this.handshakeComplete_, "Handshake must be complete before writing mutations");
          assert(this.lastStreamToken.length > 0, "Trying to write mutation without a token");
          var request = {
            streamToken: this.lastStreamToken,
            writes: mutations.map(function(mutation) {
              return _this.serializer.toMutation(mutation);
            })
          };
          this.sendRequest(request);
        };
        return PersistentWriteStream;
      }(PersistentStream);
      var Datastore = function() {
        function Datastore(queue, connection, credentials, serializer) {
          this.queue = queue;
          this.connection = connection;
          this.credentials = credentials;
          this.serializer = serializer;
        }
        Datastore.prototype.newPersistentWriteStream = function(listener) {
          return new PersistentWriteStream(this.queue, this.connection, this.credentials, this.serializer, listener);
        };
        Datastore.prototype.newPersistentWatchStream = function(listener) {
          return new PersistentListenStream(this.queue, this.connection, this.credentials, this.serializer, listener);
        };
        Datastore.prototype.commit = function(mutations) {
          var _this = this;
          var params = {
            database: this.serializer.encodedDatabaseId,
            writes: mutations.map(function(m) {
              return _this.serializer.toMutation(m);
            })
          };
          return this.invokeRPC("Commit", params).then(function(response) {
            return _this.serializer.fromWriteResults(response.writeResults);
          });
        };
        Datastore.prototype.lookup = function(keys) {
          var _this = this;
          var params = {
            database: this.serializer.encodedDatabaseId,
            documents: keys.map(function(k) {
              return _this.serializer.toName(k);
            })
          };
          return this.invokeStreamingRPC("BatchGetDocuments", params).then(function(response) {
            var docs = maybeDocumentMap();
            response.forEach(function(proto) {
              var doc = _this.serializer.fromMaybeDocument(proto);
              docs = docs.insert(doc.key, doc);
            });
            var result = [];
            keys.forEach(function(key) {
              var doc = docs.get(key);
              assert(!!doc, "Missing entity in write response for " + key);
              result.push(doc);
            });
            return result;
          });
        };
        Datastore.prototype.invokeRPC = function(rpcName, request) {
          var _this = this;
          return this.credentials.getToken().then(function(token) {
            return _this.connection.invokeRPC(rpcName, request, token);
          }).catch(function(error) {
            error.code === Code.UNAUTHENTICATED && _this.credentials.invalidateToken();
            throw error;
          });
        };
        Datastore.prototype.invokeStreamingRPC = function(rpcName, request) {
          var _this = this;
          return this.credentials.getToken().then(function(token) {
            return _this.connection.invokeStreamingRPC(rpcName, request, token);
          }).catch(function(error) {
            error.code === Code.UNAUTHENTICATED && _this.credentials.invalidateToken();
            throw error;
          });
        };
        return Datastore;
      }();
      var Transaction = function() {
        function Transaction(datastore) {
          this.datastore = datastore;
          this.readVersions = documentVersionMap();
          this.mutations = [];
          this.committed = false;
        }
        Transaction.prototype.recordVersion = function(doc) {
          var docVersion = doc.version;
          doc instanceof NoDocument && (docVersion = SnapshotVersion.forDeletedDoc());
          var existingVersion = this.readVersions.get(doc.key);
          if (null !== existingVersion) {
            if (!docVersion.isEqual(existingVersion)) throw new FirestoreError(Code.ABORTED, "Document version changed between two reads.");
          } else this.readVersions = this.readVersions.insert(doc.key, docVersion);
        };
        Transaction.prototype.lookup = function(keys) {
          var _this = this;
          if (this.committed) return Promise.reject("Transaction has already completed.");
          if (this.mutations.length > 0) return Promise.reject("Transactions lookups are invalid after writes.");
          return this.datastore.lookup(keys).then(function(docs) {
            docs.forEach(function(doc) {
              return _this.recordVersion(doc);
            });
            return docs;
          });
        };
        Transaction.prototype.write = function(mutations) {
          if (this.committed) throw new FirestoreError(Code.FAILED_PRECONDITION, "Transaction has already completed.");
          this.mutations = this.mutations.concat(mutations);
        };
        Transaction.prototype.precondition = function(key) {
          var version = this.readVersions.get(key);
          return version ? Precondition.updateTime(version) : Precondition.NONE;
        };
        Transaction.prototype.preconditionForUpdate = function(key) {
          var version = this.readVersions.get(key);
          if (version && version.isEqual(SnapshotVersion.forDeletedDoc())) throw new FirestoreError(Code.FAILED_PRECONDITION, "Can't update a document that doesn't exist.");
          return version ? Precondition.updateTime(version) : Precondition.exists(true);
        };
        Transaction.prototype.set = function(key, data) {
          this.write(data.toMutations(key, this.precondition(key)));
        };
        Transaction.prototype.update = function(key, data) {
          this.write(data.toMutations(key, this.preconditionForUpdate(key)));
        };
        Transaction.prototype.delete = function(key) {
          this.write([ new DeleteMutation(key, this.precondition(key)) ]);
          this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());
        };
        Transaction.prototype.commit = function() {
          var _this = this;
          var unwritten = this.readVersions;
          this.mutations.forEach(function(mutation) {
            unwritten = unwritten.remove(mutation.key);
          });
          if (!unwritten.isEmpty()) return Promise.reject(Error("Every document read in a transaction must also be written."));
          return this.datastore.commit(this.mutations).then(function() {
            _this.committed = true;
          });
        };
        return Transaction;
      }();
      var LOG_TAG$8 = "OnlineStateTracker";
      var MAX_WATCH_STREAM_FAILURES = 2;
      var ONLINE_STATE_TIMEOUT_MS = 1e4;
      var OnlineStateTracker = function() {
        function OnlineStateTracker(asyncQueue, onlineStateHandler) {
          this.asyncQueue = asyncQueue;
          this.onlineStateHandler = onlineStateHandler;
          this.state = OnlineState.Unknown;
          this.watchStreamFailures = 0;
          this.onlineStateTimer = null;
          this.shouldWarnClientIsOffline = true;
        }
        OnlineStateTracker.prototype.handleWatchStreamStart = function() {
          var _this = this;
          if (0 === this.watchStreamFailures) {
            this.setAndBroadcast(OnlineState.Unknown);
            assert(null === this.onlineStateTimer, "onlineStateTimer shouldn't be started yet");
            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout, ONLINE_STATE_TIMEOUT_MS, function() {
              _this.onlineStateTimer = null;
              assert(_this.state === OnlineState.Unknown, "Timer should be canceled if we transitioned to a different state.");
              _this.logClientOfflineWarningIfNecessary("Backend didn't respond within " + ONLINE_STATE_TIMEOUT_MS / 1e3 + " seconds.");
              _this.setAndBroadcast(OnlineState.Offline);
              return Promise.resolve();
            });
          }
        };
        OnlineStateTracker.prototype.handleWatchStreamFailure = function(error$$1) {
          if (this.state === OnlineState.Online) {
            this.setAndBroadcast(OnlineState.Unknown);
            assert(0 === this.watchStreamFailures, "watchStreamFailures must be 0");
            assert(null === this.onlineStateTimer, "onlineStateTimer must be null");
          } else {
            this.watchStreamFailures++;
            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {
              this.clearOnlineStateTimer();
              this.logClientOfflineWarningIfNecessary("Connection failed " + MAX_WATCH_STREAM_FAILURES + " times. Most recent error: " + error$$1.toString());
              this.setAndBroadcast(OnlineState.Offline);
            }
          }
        };
        OnlineStateTracker.prototype.set = function(newState) {
          this.clearOnlineStateTimer();
          this.watchStreamFailures = 0;
          newState === OnlineState.Online && (this.shouldWarnClientIsOffline = false);
          this.setAndBroadcast(newState);
        };
        OnlineStateTracker.prototype.setAndBroadcast = function(newState) {
          if (newState !== this.state) {
            this.state = newState;
            this.onlineStateHandler(newState);
          }
        };
        OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary = function(details) {
          var message = "Could not reach Cloud Firestore backend. " + details + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
          if (this.shouldWarnClientIsOffline) {
            error(message);
            this.shouldWarnClientIsOffline = false;
          } else debug(LOG_TAG$8, message);
        };
        OnlineStateTracker.prototype.clearOnlineStateTimer = function() {
          if (null !== this.onlineStateTimer) {
            this.onlineStateTimer.cancel();
            this.onlineStateTimer = null;
          }
        };
        return OnlineStateTracker;
      }();
      var LOG_TAG$9 = "RemoteStore";
      var MAX_PENDING_WRITES = 10;
      var RemoteStore = function() {
        function RemoteStore(localStore, datastore, asyncQueue, onlineStateHandler) {
          this.localStore = localStore;
          this.datastore = datastore;
          this.writePipeline = [];
          this.listenTargets = {};
          this.networkEnabled = false;
          this.watchChangeAggregator = null;
          this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);
          this.watchStream = this.datastore.newPersistentWatchStream({
            onOpen: this.onWatchStreamOpen.bind(this),
            onClose: this.onWatchStreamClose.bind(this),
            onWatchChange: this.onWatchStreamChange.bind(this)
          });
          this.writeStream = this.datastore.newPersistentWriteStream({
            onOpen: this.onWriteStreamOpen.bind(this),
            onClose: this.onWriteStreamClose.bind(this),
            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),
            onMutationResult: this.onMutationResult.bind(this)
          });
        }
        RemoteStore.prototype.start = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                return [ 4, this.enableNetwork() ];

               case 1:
                _a.sent();
                return [ 2 ];
              }
            });
          });
        };
        RemoteStore.prototype.enableNetwork = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
               case 0:
                if (!!this.networkEnabled) return [ 3, 3 ];
                this.networkEnabled = true;
                _a = this.writeStream;
                return [ 4, this.localStore.getLastStreamToken() ];

               case 1:
                _a.lastStreamToken = _b.sent();
                this.shouldStartWatchStream() ? this.startWatchStream() : this.onlineStateTracker.set(OnlineState.Unknown);
                return [ 4, this.fillWritePipeline() ];

               case 2:
                _b.sent();
                _b.label = 3;

               case 3:
                return [ 2 ];
              }
            });
          });
        };
        RemoteStore.prototype.disableNetwork = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                return [ 4, this.disableNetworkInternal() ];

               case 1:
                _a.sent();
                this.onlineStateTracker.set(OnlineState.Offline);
                return [ 2 ];
              }
            });
          });
        };
        RemoteStore.prototype.disableNetworkInternal = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              if (this.networkEnabled) {
                this.networkEnabled = false;
                this.writeStream.stop();
                this.watchStream.stop();
                if (this.writePipeline.length > 0) {
                  debug(LOG_TAG$9, "Stopping write stream with " + this.writePipeline.length + " pending writes");
                  this.writePipeline = [];
                }
                this.cleanUpWatchStreamState();
              }
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.shutdown = function() {
          debug(LOG_TAG$9, "RemoteStore shutting down.");
          this.disableNetworkInternal();
          this.onlineStateTracker.set(OnlineState.Unknown);
          return Promise.resolve();
        };
        RemoteStore.prototype.listen = function(queryData) {
          assert(!contains(this.listenTargets, queryData.targetId), "listen called with duplicate targetId!");
          this.listenTargets[queryData.targetId] = queryData;
          this.shouldStartWatchStream() ? this.startWatchStream() : this.watchStream.isOpen() && this.sendWatchRequest(queryData);
        };
        RemoteStore.prototype.unlisten = function(targetId) {
          assert(contains(this.listenTargets, targetId), "unlisten called without assigned target ID!");
          delete this.listenTargets[targetId];
          if (this.watchStream.isOpen()) {
            this.sendUnwatchRequest(targetId);
            isEmpty(this.listenTargets) && this.watchStream.markIdle();
          }
        };
        RemoteStore.prototype.getQueryDataForTarget = function(targetId) {
          return this.listenTargets[targetId] || null;
        };
        RemoteStore.prototype.getRemoteKeysForTarget = function(targetId) {
          return this.syncEngine.getRemoteKeysForTarget(targetId);
        };
        RemoteStore.prototype.sendWatchRequest = function(queryData) {
          this.watchChangeAggregator.recordPendingTargetRequest(queryData.targetId);
          this.watchStream.watch(queryData);
        };
        RemoteStore.prototype.sendUnwatchRequest = function(targetId) {
          this.watchChangeAggregator.recordPendingTargetRequest(targetId);
          this.watchStream.unwatch(targetId);
        };
        RemoteStore.prototype.startWatchStream = function() {
          assert(this.shouldStartWatchStream(), "startWatchStream() called when shouldStartWatchStream() is false.");
          this.watchChangeAggregator = new WatchChangeAggregator(this);
          this.watchStream.start();
          this.onlineStateTracker.handleWatchStreamStart();
        };
        RemoteStore.prototype.shouldStartWatchStream = function() {
          return this.canUseNetwork() && !this.watchStream.isStarted() && !isEmpty(this.listenTargets);
        };
        RemoteStore.prototype.canUseNetwork = function() {
          return this.networkEnabled;
        };
        RemoteStore.prototype.cleanUpWatchStreamState = function() {
          this.watchChangeAggregator = null;
        };
        RemoteStore.prototype.onWatchStreamOpen = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _this = this;
            return tslib_1.__generator(this, function(_a) {
              forEachNumber(this.listenTargets, function(targetId, queryData) {
                _this.sendWatchRequest(queryData);
              });
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.onWatchStreamClose = function(error$$1) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              void 0 === error$$1 && assert(!this.shouldStartWatchStream(), "Watch stream was stopped gracefully while still needed.");
              this.cleanUpWatchStreamState();
              if (this.shouldStartWatchStream()) {
                this.onlineStateTracker.handleWatchStreamFailure(error$$1);
                this.startWatchStream();
              } else this.onlineStateTracker.set(OnlineState.Unknown);
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.onWatchStreamChange = function(watchChange, snapshotVersion) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                this.onlineStateTracker.set(OnlineState.Online);
                if (watchChange instanceof WatchTargetChange && watchChange.state === WatchTargetChangeState.Removed && watchChange.cause) return [ 2, this.handleTargetError(watchChange) ];
                if (watchChange instanceof DocumentWatchChange) this.watchChangeAggregator.handleDocumentChange(watchChange); else if (watchChange instanceof ExistenceFilterChange) this.watchChangeAggregator.handleExistenceFilter(watchChange); else {
                  assert(watchChange instanceof WatchTargetChange, "Expected watchChange to be an instance of WatchTargetChange");
                  this.watchChangeAggregator.handleTargetChange(watchChange);
                }
                if (!(!snapshotVersion.isEqual(SnapshotVersion.MIN) && snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0)) return [ 3, 2 ];
                return [ 4, this.raiseWatchSnapshot(snapshotVersion) ];

               case 1:
                _a.sent();
                _a.label = 2;

               case 2:
                return [ 2 ];
              }
            });
          });
        };
        RemoteStore.prototype.raiseWatchSnapshot = function(snapshotVersion) {
          var _this = this;
          assert(!snapshotVersion.isEqual(SnapshotVersion.MIN), "Can't raise event for unknown SnapshotVersion");
          var remoteEvent = this.watchChangeAggregator.createRemoteEvent(snapshotVersion);
          forEachNumber(remoteEvent.targetChanges, function(targetId, change) {
            if (change.resumeToken.length > 0) {
              var queryData = _this.listenTargets[targetId];
              queryData && (_this.listenTargets[targetId] = queryData.copy({
                resumeToken: change.resumeToken,
                snapshotVersion: snapshotVersion
              }));
            }
          });
          remoteEvent.targetMismatches.forEach(function(targetId) {
            var queryData = _this.listenTargets[targetId];
            if (!queryData) return;
            _this.listenTargets[targetId] = queryData.copy({
              resumeToken: emptyByteString()
            });
            _this.sendUnwatchRequest(targetId);
            var requestQueryData = new QueryData(queryData.query, targetId, QueryPurpose.ExistenceFilterMismatch);
            _this.sendWatchRequest(requestQueryData);
          });
          return this.syncEngine.applyRemoteEvent(remoteEvent);
        };
        RemoteStore.prototype.handleTargetError = function(watchChange) {
          var _this = this;
          assert(!!watchChange.cause, "Handling target error without a cause");
          var error$$1 = watchChange.cause;
          var promiseChain = Promise.resolve();
          watchChange.targetIds.forEach(function(targetId) {
            promiseChain = promiseChain.then(function() {
              return tslib_1.__awaiter(_this, void 0, void 0, function() {
                return tslib_1.__generator(this, function(_a) {
                  if (contains(this.listenTargets, targetId)) {
                    delete this.listenTargets[targetId];
                    this.watchChangeAggregator.removeTarget(targetId);
                    return [ 2, this.syncEngine.rejectListen(targetId, error$$1) ];
                  }
                  return [ 2 ];
                });
              });
            });
          });
          return promiseChain;
        };
        RemoteStore.prototype.fillWritePipeline = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var lastBatchIdRetrieved, batch;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                if (!this.canAddToWritePipeline()) return [ 3, 4 ];
                lastBatchIdRetrieved = this.writePipeline.length > 0 ? this.writePipeline[this.writePipeline.length - 1].batchId : BATCHID_UNKNOWN;
                return [ 4, this.localStore.nextMutationBatch(lastBatchIdRetrieved) ];

               case 1:
                batch = _a.sent();
                if (!(null === batch)) return [ 3, 2 ];
                0 === this.writePipeline.length && this.writeStream.markIdle();
                return [ 3, 4 ];

               case 2:
                this.addToWritePipeline(batch);
                return [ 4, this.fillWritePipeline() ];

               case 3:
                _a.sent();
                _a.label = 4;

               case 4:
                this.shouldStartWriteStream() && this.startWriteStream();
                return [ 2 ];
              }
            });
          });
        };
        RemoteStore.prototype.canAddToWritePipeline = function() {
          return this.networkEnabled && this.writePipeline.length < MAX_PENDING_WRITES;
        };
        RemoteStore.prototype.outstandingWrites = function() {
          return this.writePipeline.length;
        };
        RemoteStore.prototype.addToWritePipeline = function(batch) {
          assert(this.canAddToWritePipeline(), "addToWritePipeline called when pipeline is full");
          this.writePipeline.push(batch);
          this.writeStream.isOpen() && this.writeStream.handshakeComplete && this.writeStream.writeMutations(batch.mutations);
        };
        RemoteStore.prototype.shouldStartWriteStream = function() {
          return this.canUseNetwork() && !this.writeStream.isStarted() && this.writePipeline.length > 0;
        };
        RemoteStore.prototype.startWriteStream = function() {
          assert(this.shouldStartWriteStream(), "startWriteStream() called when shouldStartWriteStream() is false.");
          this.writeStream.start();
        };
        RemoteStore.prototype.onWriteStreamOpen = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              this.writeStream.writeHandshake();
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.onWriteHandshakeComplete = function() {
          var _this = this;
          return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function() {
            for (var _i = 0, _a = _this.writePipeline; _i < _a.length; _i++) {
              var batch = _a[_i];
              _this.writeStream.writeMutations(batch.mutations);
            }
          });
        };
        RemoteStore.prototype.onMutationResult = function(commitVersion, results) {
          var _this = this;
          assert(this.writePipeline.length > 0, "Got result for empty write pipeline");
          var batch = this.writePipeline.shift();
          var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);
          return this.syncEngine.applySuccessfulWrite(success).then(function() {
            return _this.fillWritePipeline();
          });
        };
        RemoteStore.prototype.onWriteStreamClose = function(error$$1) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _this = this;
            var errorHandling;
            return tslib_1.__generator(this, function(_a) {
              void 0 === error$$1 && assert(!this.shouldStartWriteStream(), "Write stream was stopped gracefully while still needed.");
              if (error$$1 && this.writePipeline.length > 0) {
                errorHandling = void 0;
                errorHandling = this.writeStream.handshakeComplete ? this.handleWriteError(error$$1) : this.handleHandshakeError(error$$1);
                return [ 2, errorHandling.then(function() {
                  _this.shouldStartWriteStream() && _this.startWriteStream();
                }) ];
              }
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.handleHandshakeError = function(error$$1) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              if (isPermanentError(error$$1.code) || error$$1.code === Code.ABORTED) {
                debug(LOG_TAG$9, "RemoteStore error before completed handshake; resetting stream token: ", this.writeStream.lastStreamToken);
                this.writeStream.lastStreamToken = emptyByteString();
                return [ 2, this.localStore.setLastStreamToken(emptyByteString()) ];
              }
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.handleWriteError = function(error$$1) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _this = this;
            var batch;
            return tslib_1.__generator(this, function(_a) {
              if (isPermanentError(error$$1.code)) {
                batch = this.writePipeline.shift();
                this.writeStream.inhibitBackoff();
                return [ 2, this.syncEngine.rejectFailedWrite(batch.batchId, error$$1).then(function() {
                  return _this.fillWritePipeline();
                }) ];
              }
              return [ 2 ];
            });
          });
        };
        RemoteStore.prototype.createTransaction = function() {
          return new Transaction(this.datastore);
        };
        RemoteStore.prototype.handleUserChange = function(user) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
               case 0:
                debug(LOG_TAG$9, "RemoteStore changing users: uid=", user.uid);
                if (!this.networkEnabled) return [ 3, 2 ];
                this.disableNetworkInternal();
                this.onlineStateTracker.set(OnlineState.Unknown);
                return [ 4, this.enableNetwork() ];

               case 1:
                _a.sent();
                _a.label = 2;

               case 2:
                return [ 2 ];
              }
            });
          });
        };
        return RemoteStore;
      }();
      var LOG_TAG$10 = "FirestoreClient";
      var DOM_EXCEPTION_ABORTED = 20;
      var DOM_EXCEPTION_QUOTA_EXCEEDED = 22;
      var FirestoreClient = function() {
        function FirestoreClient(platform, databaseInfo, credentials, asyncQueue) {
          this.platform = platform;
          this.databaseInfo = databaseInfo;
          this.credentials = credentials;
          this.asyncQueue = asyncQueue;
        }
        FirestoreClient.prototype.start = function(usePersistence) {
          var _this = this;
          var initializationDone = new Deferred$1();
          var persistenceResult = new Deferred$1();
          var initialized = false;
          this.credentials.setUserChangeListener(function(user) {
            if (initialized) _this.asyncQueue.enqueue(function() {
              return _this.handleUserChange(user);
            }); else {
              initialized = true;
              _this.initializePersistence(usePersistence, persistenceResult).then(function() {
                return _this.initializeRest(user);
              }).then(initializationDone.resolve, initializationDone.reject);
            }
          });
          this.asyncQueue.enqueue(function() {
            return initializationDone.promise;
          });
          return persistenceResult.promise;
        };
        FirestoreClient.prototype.enableNetwork = function() {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            return _this.remoteStore.enableNetwork();
          });
        };
        FirestoreClient.prototype.initializePersistence = function(usePersistence, persistenceResult) {
          var _this = this;
          if (usePersistence) return this.startIndexedDbPersistence().then(persistenceResult.resolve).catch(function(error$$1) {
            persistenceResult.reject(error$$1);
            if (!_this.canFallback(error$$1)) return Promise.reject(error$$1);
            console.warn("Error enabling offline storage. Falling back to storage disabled: " + error$$1);
            return _this.startMemoryPersistence();
          });
          persistenceResult.resolve();
          return this.startMemoryPersistence();
        };
        FirestoreClient.prototype.canFallback = function(error$$1) {
          if (error$$1 instanceof FirestoreError) return error$$1.code === Code.FAILED_PRECONDITION || error$$1.code === Code.UNIMPLEMENTED;
          if ("undefined" !== typeof DOMException && error$$1 instanceof DOMException) return error$$1.code === DOM_EXCEPTION_QUOTA_EXCEEDED || error$$1.code === DOM_EXCEPTION_ABORTED;
          return true;
        };
        FirestoreClient.prototype.startIndexedDbPersistence = function() {
          this.garbageCollector = new NoOpGarbageCollector();
          var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);
          var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {
            useProto3Json: true
          });
          this.persistence = new IndexedDbPersistence(storagePrefix, serializer);
          return this.persistence.start();
        };
        FirestoreClient.prototype.startMemoryPersistence = function() {
          this.garbageCollector = new EagerGarbageCollector();
          this.persistence = new MemoryPersistence();
          return this.persistence.start();
        };
        FirestoreClient.prototype.initializeRest = function(user) {
          var _this = this;
          return this.platform.loadConnection(this.databaseInfo).then(function(connection) {
            _this.localStore = new LocalStore(_this.persistence, user, _this.garbageCollector);
            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);
            var datastore = new Datastore(_this.asyncQueue, connection, _this.credentials, serializer);
            var onlineStateChangedHandler = function(onlineState) {
              _this.syncEngine.applyOnlineStateChange(onlineState);
              _this.eventMgr.applyOnlineStateChange(onlineState);
            };
            _this.remoteStore = new RemoteStore(_this.localStore, datastore, _this.asyncQueue, onlineStateChangedHandler);
            _this.syncEngine = new SyncEngine(_this.localStore, _this.remoteStore, user);
            _this.remoteStore.syncEngine = _this.syncEngine;
            _this.eventMgr = new EventManager(_this.syncEngine);
            return _this.localStore.start();
          }).then(function() {
            return _this.remoteStore.start();
          });
        };
        FirestoreClient.prototype.handleUserChange = function(user) {
          this.asyncQueue.verifyOperationInProgress();
          debug(LOG_TAG$10, "User Changed: " + user.uid);
          return this.syncEngine.handleUserChange(user);
        };
        FirestoreClient.prototype.disableNetwork = function() {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            return _this.remoteStore.disableNetwork();
          });
        };
        FirestoreClient.prototype.shutdown = function(options) {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            _this.credentials.removeUserChangeListener();
            return _this.remoteStore.shutdown();
          }).then(function() {
            return _this.persistence.shutdown(options && options.purgePersistenceWithDataLoss);
          });
        };
        FirestoreClient.prototype.listen = function(query, observer, options) {
          var _this = this;
          var listener = new QueryListener(query, observer, options);
          this.asyncQueue.enqueue(function() {
            return _this.eventMgr.listen(listener);
          });
          return listener;
        };
        FirestoreClient.prototype.unlisten = function(listener) {
          var _this = this;
          this.asyncQueue.enqueue(function() {
            return _this.eventMgr.unlisten(listener);
          });
        };
        FirestoreClient.prototype.getDocumentFromLocalCache = function(docKey) {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            return _this.localStore.readDocument(docKey);
          }).then(function(maybeDoc) {
            if (maybeDoc instanceof Document) return maybeDoc;
            throw new FirestoreError(Code.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)");
          });
        };
        FirestoreClient.prototype.getDocumentsFromLocalCache = function(query) {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            return _this.localStore.executeQuery(query);
          }).then(function(docs) {
            var remoteKeys = documentKeySet();
            var view = new View(query, remoteKeys);
            var viewDocChanges = view.computeDocChanges(docs);
            return view.applyChanges(viewDocChanges).snapshot;
          });
        };
        FirestoreClient.prototype.write = function(mutations) {
          var _this = this;
          var deferred = new Deferred$1();
          this.asyncQueue.enqueue(function() {
            return _this.syncEngine.write(mutations, deferred);
          });
          return deferred.promise;
        };
        FirestoreClient.prototype.databaseId = function() {
          return this.databaseInfo.databaseId;
        };
        FirestoreClient.prototype.transaction = function(updateFunction) {
          var _this = this;
          return this.asyncQueue.enqueue(function() {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              return tslib_1.__generator(this, function(_a) {
                return [ 2 ];
              });
            });
          }).then(function() {
            return _this.syncEngine.runTransaction(updateFunction);
          });
        };
        return FirestoreClient;
      }();
      var AsyncObserver = function() {
        function AsyncObserver(observer) {
          this.observer = observer;
          this.muted = false;
        }
        AsyncObserver.prototype.next = function(value) {
          this.scheduleEvent(this.observer.next, value);
        };
        AsyncObserver.prototype.error = function(error) {
          this.scheduleEvent(this.observer.error, error);
        };
        AsyncObserver.prototype.mute = function() {
          this.muted = true;
        };
        AsyncObserver.prototype.scheduleEvent = function(eventHandler, event) {
          var _this = this;
          this.muted || setTimeout(function() {
            _this.muted || eventHandler(event);
          }, 0);
        };
        return AsyncObserver;
      }();
      var User = function() {
        function User(uid) {
          this.uid = uid;
        }
        User.prototype.isAuthenticated = function() {
          return null != this.uid;
        };
        User.prototype.toKey = function() {
          return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
        };
        User.prototype.isEqual = function(otherUser) {
          return otherUser.uid === this.uid;
        };
        User.UNAUTHENTICATED = new User(null);
        User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
        User.FIRST_PARTY = new User("first-party-uid");
        return User;
      }();
      var OAuthToken = function() {
        function OAuthToken(value, user) {
          this.user = user;
          this.type = "OAuth";
          this.authHeaders = {
            Authorization: "Bearer " + value
          };
        }
        return OAuthToken;
      }();
      var EmptyCredentialsProvider = function() {
        function EmptyCredentialsProvider() {
          this.userListener = null;
        }
        EmptyCredentialsProvider.prototype.getToken = function() {
          return Promise.resolve(null);
        };
        EmptyCredentialsProvider.prototype.invalidateToken = function() {};
        EmptyCredentialsProvider.prototype.setUserChangeListener = function(listener) {
          assert(!this.userListener, "Can only call setUserChangeListener() once.");
          this.userListener = listener;
          listener(User.UNAUTHENTICATED);
        };
        EmptyCredentialsProvider.prototype.removeUserChangeListener = function() {
          assert(null !== this.userListener, "removeUserChangeListener() when no listener registered");
          this.userListener = null;
        };
        return EmptyCredentialsProvider;
      }();
      var FirebaseCredentialsProvider = function() {
        function FirebaseCredentialsProvider(app) {
          var _this = this;
          this.app = app;
          this.tokenListener = null;
          this.userCounter = 0;
          this.userListener = null;
          this.forceRefresh = false;
          this.tokenListener = function() {
            var newUser = _this.getUser();
            if (!_this.currentUser || !newUser.isEqual(_this.currentUser)) {
              _this.currentUser = newUser;
              _this.userCounter++;
              _this.userListener && _this.userListener(_this.currentUser);
            }
          };
          this.userCounter = 0;
          this.app.INTERNAL.addAuthTokenListener(this.tokenListener);
        }
        FirebaseCredentialsProvider.prototype.getToken = function() {
          var _this = this;
          assert(null != this.tokenListener, "getToken cannot be called after listener removed.");
          var initialUserCounter = this.userCounter;
          var forceRefresh = this.forceRefresh;
          this.forceRefresh = false;
          return this.app.INTERNAL.getToken(forceRefresh).then(function(tokenData) {
            if (_this.userCounter !== initialUserCounter) throw new FirestoreError(Code.ABORTED, "getToken aborted due to uid change.");
            if (tokenData) {
              assert("string" === typeof tokenData.accessToken, "Invalid tokenData returned from getToken():" + tokenData);
              return new OAuthToken(tokenData.accessToken, _this.currentUser);
            }
            return null;
          });
        };
        FirebaseCredentialsProvider.prototype.invalidateToken = function() {
          this.forceRefresh = true;
        };
        FirebaseCredentialsProvider.prototype.setUserChangeListener = function(listener) {
          assert(!this.userListener, "Can only call setUserChangeListener() once.");
          this.userListener = listener;
          this.currentUser && listener(this.currentUser);
        };
        FirebaseCredentialsProvider.prototype.removeUserChangeListener = function() {
          assert(null != this.tokenListener, "removeUserChangeListener() called twice");
          assert(null !== this.userListener, "removeUserChangeListener() called when no listener registered");
          this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);
          this.tokenListener = null;
          this.userListener = null;
        };
        FirebaseCredentialsProvider.prototype.getUser = function() {
          "function" !== typeof this.app.INTERNAL.getUid && fail("This version of the Firestore SDK requires at least version 3.7.0 of firebase.js.");
          var currentUid = this.app.INTERNAL.getUid();
          assert(null === currentUid || "string" === typeof currentUid, "Received invalid UID: " + currentUid);
          return new User(currentUid);
        };
        return FirebaseCredentialsProvider;
      }();
      var FirstPartyToken = function() {
        function FirstPartyToken(gapi, sessionIndex) {
          this.gapi = gapi;
          this.sessionIndex = sessionIndex;
          this.type = "FirstParty";
          this.user = User.FIRST_PARTY;
          assert(this.gapi && this.gapi["auth"] && this.gapi["auth"]["getAuthHeaderValueForFirstParty"], "unexpected gapi interface");
        }
        Object.defineProperty(FirstPartyToken.prototype, "authHeaders", {
          get: function() {
            return {
              Authorization: this.gapi["auth"]["getAuthHeaderValueForFirstParty"]([]),
              "X-Goog-AuthUser": this.sessionIndex
            };
          },
          enumerable: true,
          configurable: true
        });
        return FirstPartyToken;
      }();
      var FirstPartyCredentialsProvider = function() {
        function FirstPartyCredentialsProvider(gapi, sessionIndex) {
          this.gapi = gapi;
          this.sessionIndex = sessionIndex;
          assert(this.gapi && this.gapi["auth"] && this.gapi["auth"]["getAuthHeaderValueForFirstParty"], "unexpected gapi interface");
        }
        FirstPartyCredentialsProvider.prototype.getToken = function() {
          return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));
        };
        FirstPartyCredentialsProvider.prototype.setUserChangeListener = function(listener) {
          listener(User.FIRST_PARTY);
        };
        FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function() {};
        FirstPartyCredentialsProvider.prototype.invalidateToken = function() {};
        return FirstPartyCredentialsProvider;
      }();
      function makeCredentialsProvider(credentials) {
        if (!credentials) return new EmptyCredentialsProvider();
        switch (credentials.type) {
         case "gapi":
          return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || "0");

         case "provider":
          return credentials.client;

         default:
          throw new FirestoreError(Code.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
        }
      }
      function isPartialObserver(obj) {
        return implementsAnyMethods$1(obj, [ "next", "error", "complete" ]);
      }
      function implementsAnyMethods$1(obj, methods) {
        if ("object" !== typeof obj || null === obj) return false;
        var object = obj;
        for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
          var method = methods_1[_i];
          if (method in object && "function" === typeof object[method]) return true;
        }
        return false;
      }
      var FieldValueImpl = function() {
        function FieldValueImpl(methodName) {
          this.methodName = methodName;
        }
        FieldValueImpl.delete = function() {
          return DeleteFieldValueImpl.instance;
        };
        FieldValueImpl.serverTimestamp = function() {
          return ServerTimestampFieldValueImpl.instance;
        };
        FieldValueImpl.arrayUnion = function() {
          var elements = [];
          for (var _i = 0; _i < arguments.length; _i++) elements[_i] = arguments[_i];
          validateAtLeastNumberOfArgs("FieldValue.arrayUnion", arguments, 1);
          return new ArrayUnionFieldValueImpl(elements);
        };
        FieldValueImpl.arrayRemove = function() {
          var elements = [];
          for (var _i = 0; _i < arguments.length; _i++) elements[_i] = arguments[_i];
          validateAtLeastNumberOfArgs("FieldValue.arrayRemove", arguments, 1);
          return new ArrayRemoveFieldValueImpl(elements);
        };
        FieldValueImpl.prototype.isEqual = function(other) {
          return this === other;
        };
        return FieldValueImpl;
      }();
      var DeleteFieldValueImpl = function(_super) {
        tslib_1.__extends(DeleteFieldValueImpl, _super);
        function DeleteFieldValueImpl() {
          return _super.call(this, "FieldValue.delete") || this;
        }
        DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();
        return DeleteFieldValueImpl;
      }(FieldValueImpl);
      var ServerTimestampFieldValueImpl = function(_super) {
        tslib_1.__extends(ServerTimestampFieldValueImpl, _super);
        function ServerTimestampFieldValueImpl() {
          return _super.call(this, "FieldValue.serverTimestamp") || this;
        }
        ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();
        return ServerTimestampFieldValueImpl;
      }(FieldValueImpl);
      var ArrayUnionFieldValueImpl = function(_super) {
        tslib_1.__extends(ArrayUnionFieldValueImpl, _super);
        function ArrayUnionFieldValueImpl(_elements) {
          var _this = _super.call(this, "FieldValue.arrayUnion") || this;
          _this._elements = _elements;
          return _this;
        }
        return ArrayUnionFieldValueImpl;
      }(FieldValueImpl);
      var ArrayRemoveFieldValueImpl = function(_super) {
        tslib_1.__extends(ArrayRemoveFieldValueImpl, _super);
        function ArrayRemoveFieldValueImpl(_elements) {
          var _this = _super.call(this, "FieldValue.arrayRemove") || this;
          _this._elements = _elements;
          return _this;
        }
        return ArrayRemoveFieldValueImpl;
      }(FieldValueImpl);
      var PublicFieldValue = makeConstructorPrivate(FieldValueImpl, "Use FieldValue.<field>() instead.");
      var RESERVED_FIELD_REGEX = /^__.*__$/;
      var ParsedSetData = function() {
        function ParsedSetData(data, fieldMask, fieldTransforms) {
          this.data = data;
          this.fieldMask = fieldMask;
          this.fieldTransforms = fieldTransforms;
        }
        ParsedSetData.prototype.toMutations = function(key, precondition) {
          var mutations = [];
          null !== this.fieldMask ? mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition)) : mutations.push(new SetMutation(key, this.data, precondition));
          this.fieldTransforms.length > 0 && mutations.push(new TransformMutation(key, this.fieldTransforms));
          return mutations;
        };
        return ParsedSetData;
      }();
      var ParsedUpdateData = function() {
        function ParsedUpdateData(data, fieldMask, fieldTransforms) {
          this.data = data;
          this.fieldMask = fieldMask;
          this.fieldTransforms = fieldTransforms;
        }
        ParsedUpdateData.prototype.toMutations = function(key, precondition) {
          var mutations = [ new PatchMutation(key, this.data, this.fieldMask, precondition) ];
          this.fieldTransforms.length > 0 && mutations.push(new TransformMutation(key, this.fieldTransforms));
          return mutations;
        };
        return ParsedUpdateData;
      }();
      var UserDataSource;
      (function(UserDataSource) {
        UserDataSource[UserDataSource["Set"] = 0] = "Set";
        UserDataSource[UserDataSource["Update"] = 1] = "Update";
        UserDataSource[UserDataSource["MergeSet"] = 2] = "MergeSet";
        UserDataSource[UserDataSource["Argument"] = 3] = "Argument";
      })(UserDataSource || (UserDataSource = {}));
      function isWrite(dataSource) {
        switch (dataSource) {
         case UserDataSource.Set:
         case UserDataSource.MergeSet:
         case UserDataSource.Update:
          return true;

         case UserDataSource.Argument:
          return false;

         default:
          throw fail("Unexpected case for UserDataSource: " + dataSource);
        }
      }
      var ParseContext = function() {
        function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {
          this.dataSource = dataSource;
          this.methodName = methodName;
          this.path = path;
          this.arrayElement = arrayElement;
          void 0 === fieldTransforms && this.validatePath();
          this.arrayElement = void 0 !== arrayElement && arrayElement;
          this.fieldTransforms = fieldTransforms || [];
          this.fieldMask = fieldMask || [];
        }
        ParseContext.prototype.childContextForField = function(field) {
          var childPath = null == this.path ? null : this.path.child(field);
          var context = new ParseContext(this.dataSource, this.methodName, childPath, false, this.fieldTransforms, this.fieldMask);
          context.validatePathSegment(field);
          return context;
        };
        ParseContext.prototype.childContextForFieldPath = function(field) {
          var childPath = null == this.path ? null : this.path.child(field);
          var context = new ParseContext(this.dataSource, this.methodName, childPath, false, this.fieldTransforms, this.fieldMask);
          context.validatePath();
          return context;
        };
        ParseContext.prototype.childContextForArray = function(index) {
          return new ParseContext(this.dataSource, this.methodName, null, true, this.fieldTransforms, this.fieldMask);
        };
        ParseContext.prototype.createError = function(reason) {
          var fieldDescription = null === this.path || this.path.isEmpty() ? "" : " (found in field " + this.path.toString() + ")";
          return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + this.methodName + "() called with invalid data. " + reason + fieldDescription);
        };
        ParseContext.prototype.contains = function(fieldPath) {
          return void 0 !== this.fieldMask.find(function(field) {
            return fieldPath.isPrefixOf(field);
          }) || void 0 !== this.fieldTransforms.find(function(transform) {
            return fieldPath.isPrefixOf(transform.field);
          });
        };
        ParseContext.prototype.validatePath = function() {
          if (null === this.path) return;
          for (var i = 0; i < this.path.length; i++) this.validatePathSegment(this.path.get(i));
        };
        ParseContext.prototype.validatePathSegment = function(segment) {
          if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) throw this.createError("Document fields cannot begin and end with __");
        };
        return ParseContext;
      }();
      var DocumentKeyReference = function() {
        function DocumentKeyReference(databaseId, key) {
          this.databaseId = databaseId;
          this.key = key;
        }
        return DocumentKeyReference;
      }();
      var UserDataConverter = function() {
        function UserDataConverter(preConverter) {
          this.preConverter = preConverter;
        }
        UserDataConverter.prototype.parseSetData = function(methodName, input) {
          var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);
          validatePlainObject("Data must be an object, but it was:", context, input);
          var updateData = this.parseData(input, context);
          return new ParsedSetData(updateData, null, context.fieldTransforms);
        };
        UserDataConverter.prototype.parseMergeData = function(methodName, input, fieldPaths) {
          var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);
          validatePlainObject("Data must be an object, but it was:", context, input);
          var updateData = this.parseData(input, context);
          var fieldMask;
          var fieldTransforms;
          if (fieldPaths) {
            var validatedFieldPaths = [];
            for (var _i = 0, fieldPaths_1 = fieldPaths; _i < fieldPaths_1.length; _i++) {
              var stringOrFieldPath = fieldPaths_1[_i];
              var fieldPath = void 0;
              stringOrFieldPath instanceof FieldPath$1 ? fieldPath = stringOrFieldPath : "string" === typeof stringOrFieldPath ? fieldPath = fieldPathFromDotSeparatedString(methodName, stringOrFieldPath) : fail("Expected stringOrFieldPath to be a string or a FieldPath");
              if (!context.contains(fieldPath)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Field '" + fieldPath + "' is specified in your field mask but missing from your input data.");
              validatedFieldPaths.push(fieldPath);
            }
            fieldMask = new FieldMask(validatedFieldPaths);
            fieldTransforms = context.fieldTransforms.filter(function(transform) {
              return fieldMask.covers(transform.field);
            });
          } else {
            fieldMask = new FieldMask(context.fieldMask);
            fieldTransforms = context.fieldTransforms;
          }
          return new ParsedSetData(updateData, fieldMask, fieldTransforms);
        };
        UserDataConverter.prototype.parseUpdateData = function(methodName, input) {
          var _this = this;
          var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
          validatePlainObject("Data must be an object, but it was:", context, input);
          var fieldMaskPaths = [];
          var updateData = ObjectValue.EMPTY;
          forEach(input, function(key, value) {
            var path = fieldPathFromDotSeparatedString(methodName, key);
            var childContext = context.childContextForFieldPath(path);
            value = _this.runPreConverter(value, childContext);
            if (value instanceof DeleteFieldValueImpl) fieldMaskPaths.push(path); else {
              var parsedValue = _this.parseData(value, childContext);
              if (null != parsedValue) {
                fieldMaskPaths.push(path);
                updateData = updateData.set(path, parsedValue);
              }
            }
          });
          var mask = new FieldMask(fieldMaskPaths);
          return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
        };
        UserDataConverter.prototype.parseUpdateVarargs = function(methodName, field, value, moreFieldsAndValues) {
          var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
          var keys = [ fieldPathFromArgument(methodName, field) ];
          var values = [ value ];
          if (moreFieldsAndValues.length % 2 !== 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number of arguments that alternate between field names and values.");
          for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));
            values.push(moreFieldsAndValues[i + 1]);
          }
          var fieldMaskPaths = [];
          var updateData = ObjectValue.EMPTY;
          for (var i = 0; i < keys.length; ++i) {
            var path = keys[i];
            var childContext = context.childContextForFieldPath(path);
            var value_1 = this.runPreConverter(values[i], childContext);
            if (value_1 instanceof DeleteFieldValueImpl) fieldMaskPaths.push(path); else {
              var parsedValue = this.parseData(value_1, childContext);
              if (null != parsedValue) {
                fieldMaskPaths.push(path);
                updateData = updateData.set(path, parsedValue);
              }
            }
          }
          var mask = new FieldMask(fieldMaskPaths);
          return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
        };
        UserDataConverter.prototype.parseQueryValue = function(methodName, input) {
          var context = new ParseContext(UserDataSource.Argument, methodName, FieldPath.EMPTY_PATH);
          var parsed = this.parseData(input, context);
          assert(null != parsed, "Parsed data should not be null.");
          assert(0 === context.fieldTransforms.length, "Field transforms should have been disallowed.");
          return parsed;
        };
        UserDataConverter.prototype.runPreConverter = function(input, context) {
          try {
            return this.preConverter(input);
          } catch (e) {
            var message = errorMessage(e);
            throw context.createError(message);
          }
        };
        UserDataConverter.prototype.parseData = function(input, context) {
          input = this.runPreConverter(input, context);
          if (looksLikeJsonObject(input)) {
            validatePlainObject("Unsupported field value:", context, input);
            return this.parseObject(input, context);
          }
          if (input instanceof FieldValueImpl) {
            this.parseSentinelFieldValue(input, context);
            return null;
          }
          context.path && context.fieldMask.push(context.path);
          if (input instanceof Array) {
            if (context.arrayElement) throw context.createError("Nested arrays are not supported");
            return this.parseArray(input, context);
          }
          return this.parseScalarValue(input, context);
        };
        UserDataConverter.prototype.parseObject = function(obj, context) {
          var _this = this;
          var result = new SortedMap(primitiveComparator);
          forEach(obj, function(key, val) {
            var parsedValue = _this.parseData(val, context.childContextForField(key));
            null != parsedValue && (result = result.insert(key, parsedValue));
          });
          return new ObjectValue(result);
        };
        UserDataConverter.prototype.parseArray = function(array, context) {
          var result = [];
          var entryIndex = 0;
          for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var entry = array_1[_i];
            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));
            null == parsedEntry && (parsedEntry = NullValue.INSTANCE);
            result.push(parsedEntry);
            entryIndex++;
          }
          return new ArrayValue(result);
        };
        UserDataConverter.prototype.parseSentinelFieldValue = function(value, context) {
          if (!isWrite(context.dataSource)) throw context.createError(value.methodName + "() can only be used with update() and set()");
          if (null === context.path) throw context.createError(value.methodName + "() is not currently supported inside arrays");
          if (value instanceof DeleteFieldValueImpl) {
            if (context.dataSource !== UserDataSource.MergeSet) {
              if (context.dataSource === UserDataSource.Update) {
                assert(context.path.length > 0, "FieldValue.delete() at the top level should have already been handled.");
                throw context.createError("FieldValue.delete() can only appear at the top level of your update data");
              }
              throw context.createError("FieldValue.delete() cannot be used with set() unless you pass {merge:true}");
            }
            context.fieldMask.push(context.path);
          } else if (value instanceof ServerTimestampFieldValueImpl) context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance)); else if (value instanceof ArrayUnionFieldValueImpl) {
            var parsedElements = this.parseArrayTransformElements(value.methodName, value._elements);
            var arrayUnion = new ArrayUnionTransformOperation(parsedElements);
            context.fieldTransforms.push(new FieldTransform(context.path, arrayUnion));
          } else if (value instanceof ArrayRemoveFieldValueImpl) {
            var parsedElements = this.parseArrayTransformElements(value.methodName, value._elements);
            var arrayRemove = new ArrayRemoveTransformOperation(parsedElements);
            context.fieldTransforms.push(new FieldTransform(context.path, arrayRemove));
          } else fail("Unknown FieldValue type: " + value);
        };
        UserDataConverter.prototype.parseScalarValue = function(value, context) {
          if (null === value) return NullValue.INSTANCE;
          if ("number" === typeof value) return isSafeInteger(value) ? new IntegerValue(value) : new DoubleValue(value);
          if ("boolean" === typeof value) return BooleanValue.of(value);
          if ("string" === typeof value) return new StringValue(value);
          if (value instanceof Date) return new TimestampValue(Timestamp.fromDate(value));
          if (value instanceof Timestamp) return new TimestampValue(new Timestamp(value.seconds, 1e3 * Math.floor(value.nanoseconds / 1e3)));
          if (value instanceof GeoPoint) return new GeoPointValue(value);
          if (value instanceof Blob) return new BlobValue(value);
          if (value instanceof DocumentKeyReference) return new RefValue(value.databaseId, value.key);
          throw context.createError("Unsupported field value: " + valueDescription(value));
        };
        UserDataConverter.prototype.parseArrayTransformElements = function(methodName, elements) {
          var _this = this;
          return elements.map(function(element, i) {
            var context = new ParseContext(UserDataSource.Argument, methodName, FieldPath.EMPTY_PATH);
            return _this.parseData(element, context.childContextForArray(i));
          });
        };
        return UserDataConverter;
      }();
      function looksLikeJsonObject(input) {
        return "object" === typeof input && null !== input && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Blob) && !(input instanceof DocumentKeyReference) && !(input instanceof FieldValueImpl);
      }
      function validatePlainObject(message, context, input) {
        if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
          var description = valueDescription(input);
          throw "an object" === description ? context.createError(message + " a custom object") : context.createError(message + " " + description);
        }
      }
      function fieldPathFromArgument(methodName, path) {
        if (path instanceof FieldPath$1) return path._internalPath;
        if ("string" === typeof path) return fieldPathFromDotSeparatedString(methodName, path);
        var message = "Field path arguments must be of type string or FieldPath.";
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
      }
      function fieldPathFromDotSeparatedString(methodName, path) {
        try {
          return fromDotSeparatedString(path)._internalPath;
        } catch (e) {
          var message = errorMessage(e);
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
        }
      }
      function errorMessage(error) {
        return error instanceof Error ? error.message : error.toString();
      }
      var DEFAULT_HOST = "firestore.googleapis.com";
      var DEFAULT_SSL = true;
      var DEFAULT_TIMESTAMPS_IN_SNAPSHOTS = false;
      var FirestoreSettings = function() {
        function FirestoreSettings(settings) {
          if (void 0 === settings.host) {
            if (void 0 !== settings.ssl) throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            this.host = DEFAULT_HOST;
            this.ssl = DEFAULT_SSL;
          } else {
            validateNamedType("settings", "string", "host", settings.host);
            this.host = settings.host;
            validateNamedOptionalType("settings", "boolean", "ssl", settings.ssl);
            this.ssl = defaulted(settings.ssl, DEFAULT_SSL);
          }
          validateOptionNames("settings", settings, [ "host", "ssl", "credentials", "timestampsInSnapshots" ]);
          validateNamedOptionalType("settings", "object", "credentials", settings.credentials);
          this.credentials = settings.credentials;
          validateNamedOptionalType("settings", "boolean", "timestampsInSnapshots", settings.timestampsInSnapshots);
          this.timestampsInSnapshots = defaulted(settings.timestampsInSnapshots, DEFAULT_TIMESTAMPS_IN_SNAPSHOTS);
        }
        FirestoreSettings.prototype.isEqual = function(other) {
          return this.host === other.host && this.ssl === other.ssl && this.timestampsInSnapshots === other.timestampsInSnapshots && this.credentials === other.credentials;
        };
        return FirestoreSettings;
      }();
      var FirestoreConfig = function() {
        function FirestoreConfig() {}
        return FirestoreConfig;
      }();
      var Firestore = function() {
        function Firestore(databaseIdOrApp) {
          var _this = this;
          this._queue = new AsyncQueue();
          this.INTERNAL = {
            delete: function(options) {
              return tslib_1.__awaiter(_this, void 0, void 0, function() {
                return tslib_1.__generator(this, function(_a) {
                  if (this._firestoreClient) return [ 2, this._firestoreClient.shutdown(options) ];
                  return [ 2 ];
                });
              });
            }
          };
          var config = new FirestoreConfig();
          if ("object" === typeof databaseIdOrApp.options) {
            var app = databaseIdOrApp;
            config.firebaseApp = app;
            config.databaseId = Firestore.databaseIdFromApp(app);
            config.persistenceKey = config.firebaseApp.name;
            config.credentials = new FirebaseCredentialsProvider(app);
          } else {
            var external_1 = databaseIdOrApp;
            if (!external_1.projectId) throw new FirestoreError(Code.INVALID_ARGUMENT, "Must provide projectId");
            config.databaseId = new DatabaseId(external_1.projectId, external_1.database);
            config.persistenceKey = "[DEFAULT]";
            config.credentials = new EmptyCredentialsProvider();
          }
          config.settings = new FirestoreSettings({});
          this._config = config;
          this._databaseId = config.databaseId;
        }
        Firestore.prototype.settings = function(settingsLiteral) {
          validateExactNumberOfArgs("Firestore.settings", arguments, 1);
          validateArgType("Firestore.settings", "object", 1, settingsLiteral);
          if (contains(settingsLiteral, "persistence")) throw new FirestoreError(Code.INVALID_ARGUMENT, '"persistence" is now specified with a separate call to firestore.enablePersistence().');
          var newSettings = new FirestoreSettings(settingsLiteral);
          if (this._firestoreClient && !this._config.settings.isEqual(newSettings)) throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.");
          this._config.settings = newSettings;
          void 0 !== newSettings.credentials && (this._config.credentials = makeCredentialsProvider(newSettings.credentials));
        };
        Firestore.prototype.enableNetwork = function() {
          this.ensureClientConfigured();
          return this._firestoreClient.enableNetwork();
        };
        Firestore.prototype.disableNetwork = function() {
          this.ensureClientConfigured();
          return this._firestoreClient.disableNetwork();
        };
        Firestore.prototype.enablePersistence = function() {
          if (this._firestoreClient) throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.");
          return this.configureClient(true);
        };
        Firestore.prototype.ensureClientConfigured = function() {
          this._firestoreClient || this.configureClient(false);
          return this._firestoreClient;
        };
        Firestore.prototype.configureClient = function(persistence) {
          var _this = this;
          assert(!!this._config.settings.host, "FirestoreSettings.host cannot be falsey");
          this._config.settings.timestampsInSnapshots || error("\nThe behavior for Date objects stored in Firestore is going to change\nAND YOUR APP MAY BREAK.\nTo hide this warning and ensure your app does not break, you need to add the\nfollowing code to your app before calling any other Cloud Firestore methods:\n\n  const firestore = firebase.firestore();\n  const settings = {/* your settings... */ timestampsInSnapshots: true};\n  firestore.settings(settings);\n\nWith this change, timestamps stored in Cloud Firestore will be read back as\nFirebase Timestamp objects instead of as system Date objects. So you will also\nneed to update code expecting a Date to instead expect a Timestamp. For example:\n\n  // Old:\n  const date = snapshot.get('created_at');\n  // New:\n  const timestamp = snapshot.get('created_at');\n  const date = timestamp.toDate();\n\nPlease audit all existing usages of Date when you enable the new behavior. In a\nfuture release, the behavior will change to the new behavior, so if you do not\nfollow these steps, YOUR APP MAY BREAK.");
          assert(!this._firestoreClient, "configureClient() called multiple times");
          var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);
          var preConverter = function(value) {
            if (value instanceof DocumentReference) {
              var thisDb = _this._config.databaseId;
              var otherDb = value.firestore._config.databaseId;
              if (!otherDb.isEqual(thisDb)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Document reference is for database " + otherDb.projectId + "/" + otherDb.database + " but should be for database " + thisDb.projectId + "/" + thisDb.database);
              return new DocumentKeyReference(_this._config.databaseId, value._key);
            }
            return value;
          };
          this._dataConverter = new UserDataConverter(preConverter);
          this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);
          return this._firestoreClient.start(persistence);
        };
        Firestore.databaseIdFromApp = function(app) {
          var options = app.options;
          if (!contains(options, "projectId")) {
            if (contains(options, "firestoreId")) throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreId" is now specified as "projectId" in firebase.initializeApp.');
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
          }
          if (contains(options, "firestoreOptions")) throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreOptions" values are now specified with Firestore.settings()');
          var projectId = options["projectId"];
          if (!projectId || "string" !== typeof projectId) throw new FirestoreError(Code.INVALID_ARGUMENT, "projectId must be a string in FirebaseApp.options");
          return new DatabaseId(projectId);
        };
        Object.defineProperty(Firestore.prototype, "app", {
          get: function() {
            if (!this._config.firebaseApp) throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
            return this._config.firebaseApp;
          },
          enumerable: true,
          configurable: true
        });
        Firestore.prototype.collection = function(pathString) {
          validateExactNumberOfArgs("Firestore.collection", arguments, 1);
          validateArgType("Firestore.collection", "string", 1, pathString);
          if (!pathString) throw new FirestoreError(Code.INVALID_ARGUMENT, "Must provide a non-empty collection path to collection()");
          this.ensureClientConfigured();
          return new CollectionReference(ResourcePath.fromString(pathString), this);
        };
        Firestore.prototype.doc = function(pathString) {
          validateExactNumberOfArgs("Firestore.doc", arguments, 1);
          validateArgType("Firestore.doc", "string", 1, pathString);
          if (!pathString) throw new FirestoreError(Code.INVALID_ARGUMENT, "Must provide a non-empty document path to doc()");
          this.ensureClientConfigured();
          return DocumentReference.forPath(ResourcePath.fromString(pathString), this);
        };
        Firestore.prototype.runTransaction = function(updateFunction) {
          var _this = this;
          validateExactNumberOfArgs("Firestore.runTransaction", arguments, 1);
          validateArgType("Firestore.runTransaction", "function", 1, updateFunction);
          return this.ensureClientConfigured().transaction(function(transaction) {
            return updateFunction(new Transaction$1(_this, transaction));
          });
        };
        Firestore.prototype.batch = function() {
          this.ensureClientConfigured();
          return new WriteBatch(this);
        };
        Object.defineProperty(Firestore, "logLevel", {
          get: function() {
            switch (getLogLevel()) {
             case LogLevel.DEBUG:
              return "debug";

             case LogLevel.ERROR:
              return "error";

             case LogLevel.SILENT:
              return "silent";

             default:
              return fail("Unknown log level: " + getLogLevel());
            }
          },
          enumerable: true,
          configurable: true
        });
        Firestore.setLogLevel = function(level) {
          validateExactNumberOfArgs("Firestore.setLogLevel", arguments, 1);
          validateArgType("Firestore.setLogLevel", "string", 1, level);
          switch (level) {
           case "debug":
            setLogLevel(LogLevel.DEBUG);
            break;

           case "error":
            setLogLevel(LogLevel.ERROR);
            break;

           case "silent":
            setLogLevel(LogLevel.SILENT);
            break;

           default:
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid log level: " + level);
          }
        };
        Firestore.prototype._areTimestampsInSnapshotsEnabled = function() {
          return this._config.settings.timestampsInSnapshots;
        };
        return Firestore;
      }();
      var Transaction$1 = function() {
        function Transaction(_firestore, _transaction) {
          this._firestore = _firestore;
          this._transaction = _transaction;
        }
        Transaction.prototype.get = function(documentRef) {
          var _this = this;
          validateExactNumberOfArgs("Transaction.get", arguments, 1);
          var ref = validateReference("Transaction.get", documentRef, this._firestore);
          return this._transaction.lookup([ ref._key ]).then(function(docs) {
            if (!docs || 1 !== docs.length) return fail("Mismatch in docs returned from document lookup.");
            var doc = docs[0];
            if (doc instanceof NoDocument) return new DocumentSnapshot(_this._firestore, ref._key, null, false);
            return new DocumentSnapshot(_this._firestore, ref._key, doc, false);
          });
        };
        Transaction.prototype.set = function(documentRef, value, options) {
          validateBetweenNumberOfArgs("Transaction.set", arguments, 2, 3);
          var ref = validateReference("Transaction.set", documentRef, this._firestore);
          options = validateSetOptions("Transaction.set", options);
          var parsed = options.merge || options.mergeFields ? this._firestore._dataConverter.parseMergeData("Transaction.set", value, options.mergeFields) : this._firestore._dataConverter.parseSetData("Transaction.set", value);
          this._transaction.set(ref._key, parsed);
          return this;
        };
        Transaction.prototype.update = function(documentRef, fieldOrUpdateData, value) {
          var moreFieldsAndValues = [];
          for (var _i = 3; _i < arguments.length; _i++) moreFieldsAndValues[_i - 3] = arguments[_i];
          var ref;
          var parsed;
          if ("string" === typeof fieldOrUpdateData || fieldOrUpdateData instanceof FieldPath$1) {
            validateAtLeastNumberOfArgs("Transaction.update", arguments, 3);
            ref = validateReference("Transaction.update", documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs("Transaction.update", fieldOrUpdateData, value, moreFieldsAndValues);
          } else {
            validateExactNumberOfArgs("Transaction.update", arguments, 2);
            ref = validateReference("Transaction.update", documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData("Transaction.update", fieldOrUpdateData);
          }
          this._transaction.update(ref._key, parsed);
          return this;
        };
        Transaction.prototype.delete = function(documentRef) {
          validateExactNumberOfArgs("Transaction.delete", arguments, 1);
          var ref = validateReference("Transaction.delete", documentRef, this._firestore);
          this._transaction.delete(ref._key);
          return this;
        };
        return Transaction;
      }();
      var WriteBatch = function() {
        function WriteBatch(_firestore) {
          this._firestore = _firestore;
          this._mutations = [];
          this._committed = false;
        }
        WriteBatch.prototype.set = function(documentRef, value, options) {
          validateBetweenNumberOfArgs("WriteBatch.set", arguments, 2, 3);
          this.verifyNotCommitted();
          var ref = validateReference("WriteBatch.set", documentRef, this._firestore);
          options = validateSetOptions("WriteBatch.set", options);
          var parsed = options.merge || options.mergeFields ? this._firestore._dataConverter.parseMergeData("WriteBatch.set", value, options.mergeFields) : this._firestore._dataConverter.parseSetData("WriteBatch.set", value);
          this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));
          return this;
        };
        WriteBatch.prototype.update = function(documentRef, fieldOrUpdateData, value) {
          var moreFieldsAndValues = [];
          for (var _i = 3; _i < arguments.length; _i++) moreFieldsAndValues[_i - 3] = arguments[_i];
          this.verifyNotCommitted();
          var ref;
          var parsed;
          if ("string" === typeof fieldOrUpdateData || fieldOrUpdateData instanceof FieldPath$1) {
            validateAtLeastNumberOfArgs("WriteBatch.update", arguments, 3);
            ref = validateReference("WriteBatch.update", documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs("WriteBatch.update", fieldOrUpdateData, value, moreFieldsAndValues);
          } else {
            validateExactNumberOfArgs("WriteBatch.update", arguments, 2);
            ref = validateReference("WriteBatch.update", documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData("WriteBatch.update", fieldOrUpdateData);
          }
          this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));
          return this;
        };
        WriteBatch.prototype.delete = function(documentRef) {
          validateExactNumberOfArgs("WriteBatch.delete", arguments, 1);
          this.verifyNotCommitted();
          var ref = validateReference("WriteBatch.delete", documentRef, this._firestore);
          this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));
          return this;
        };
        WriteBatch.prototype.commit = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              this.verifyNotCommitted();
              this._committed = true;
              if (this._mutations.length > 0) return [ 2, this._firestore.ensureClientConfigured().write(this._mutations) ];
              return [ 2 ];
            });
          });
        };
        WriteBatch.prototype.verifyNotCommitted = function() {
          if (this._committed) throw new FirestoreError(Code.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
        };
        return WriteBatch;
      }();
      var DocumentReference = function() {
        function DocumentReference(_key, firestore) {
          this._key = _key;
          this.firestore = firestore;
          this._firestoreClient = this.firestore.ensureClientConfigured();
        }
        DocumentReference.forPath = function(path, firestore) {
          if (path.length % 2 !== 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + path.canonicalString() + " has " + path.length);
          return new DocumentReference(new DocumentKey(path), firestore);
        };
        Object.defineProperty(DocumentReference.prototype, "id", {
          get: function() {
            return this._key.path.lastSegment();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DocumentReference.prototype, "parent", {
          get: function() {
            return new CollectionReference(this._key.path.popLast(), this.firestore);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DocumentReference.prototype, "path", {
          get: function() {
            return this._key.path.canonicalString();
          },
          enumerable: true,
          configurable: true
        });
        DocumentReference.prototype.collection = function(pathString) {
          validateExactNumberOfArgs("DocumentReference.collection", arguments, 1);
          validateArgType("DocumentReference.collection", "string", 1, pathString);
          if (!pathString) throw new FirestoreError(Code.INVALID_ARGUMENT, "Must provide a non-empty collection name to collection()");
          var path = ResourcePath.fromString(pathString);
          return new CollectionReference(this._key.path.child(path), this.firestore);
        };
        DocumentReference.prototype.isEqual = function(other) {
          if (!(other instanceof DocumentReference)) throw invalidClassError("isEqual", "DocumentReference", 1, other);
          return this.firestore === other.firestore && this._key.isEqual(other._key);
        };
        DocumentReference.prototype.set = function(value, options) {
          validateBetweenNumberOfArgs("DocumentReference.set", arguments, 1, 2);
          options = validateSetOptions("DocumentReference.set", options);
          var parsed = options.merge || options.mergeFields ? this.firestore._dataConverter.parseMergeData("DocumentReference.set", value, options.mergeFields) : this.firestore._dataConverter.parseSetData("DocumentReference.set", value);
          return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));
        };
        DocumentReference.prototype.update = function(fieldOrUpdateData, value) {
          var moreFieldsAndValues = [];
          for (var _i = 2; _i < arguments.length; _i++) moreFieldsAndValues[_i - 2] = arguments[_i];
          var parsed;
          if ("string" === typeof fieldOrUpdateData || fieldOrUpdateData instanceof FieldPath$1) {
            validateAtLeastNumberOfArgs("DocumentReference.update", arguments, 2);
            parsed = this.firestore._dataConverter.parseUpdateVarargs("DocumentReference.update", fieldOrUpdateData, value, moreFieldsAndValues);
          } else {
            validateExactNumberOfArgs("DocumentReference.update", arguments, 1);
            parsed = this.firestore._dataConverter.parseUpdateData("DocumentReference.update", fieldOrUpdateData);
          }
          return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));
        };
        DocumentReference.prototype.delete = function() {
          validateExactNumberOfArgs("DocumentReference.delete", arguments, 0);
          return this._firestoreClient.write([ new DeleteMutation(this._key, Precondition.NONE) ]);
        };
        DocumentReference.prototype.onSnapshot = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          validateBetweenNumberOfArgs("DocumentReference.onSnapshot", arguments, 1, 4);
          var options = {
            includeMetadataChanges: false
          };
          var observer;
          var currArg = 0;
          if ("object" === typeof args[currArg] && !isPartialObserver(args[currArg])) {
            options = args[currArg];
            validateOptionNames("DocumentReference.onSnapshot", options, [ "includeMetadataChanges" ]);
            validateNamedOptionalType("DocumentReference.onSnapshot", "boolean", "includeMetadataChanges", options.includeMetadataChanges);
            currArg++;
          }
          var internalOptions = {
            includeMetadataChanges: options.includeMetadataChanges
          };
          if (isPartialObserver(args[currArg])) observer = args[currArg]; else {
            validateArgType("DocumentReference.onSnapshot", "function", currArg, args[currArg]);
            validateOptionalArgType("DocumentReference.onSnapshot", "function", currArg + 1, args[currArg + 1]);
            validateOptionalArgType("DocumentReference.onSnapshot", "function", currArg + 2, args[currArg + 2]);
            observer = {
              next: args[currArg],
              error: args[currArg + 1],
              complete: args[currArg + 2]
            };
          }
          return this.onSnapshotInternal(internalOptions, observer);
        };
        DocumentReference.prototype.onSnapshotInternal = function(options, observer) {
          var _this = this;
          var errHandler = function(err) {
            console.error("Uncaught Error in onSnapshot:", err);
          };
          observer.error && (errHandler = observer.error.bind(observer));
          var asyncObserver = new AsyncObserver({
            next: function(snapshot) {
              if (observer.next) {
                assert(snapshot.docs.size <= 1, "Too many documents returned on a document query");
                var doc = snapshot.docs.get(_this._key);
                observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));
              }
            },
            error: errHandler
          });
          var internalListener = this._firestoreClient.listen(Query.atPath(this._key.path), asyncObserver, options);
          return function() {
            asyncObserver.mute();
            _this._firestoreClient.unlisten(internalListener);
          };
        };
        DocumentReference.prototype.get = function(options) {
          var _this = this;
          validateOptionNames("DocumentReference.get", options, [ "source" ]);
          options && validateNamedOptionalPropertyEquals("DocumentReference.get", "options", "source", options.source, [ "default", "server", "cache" ]);
          return new Promise(function(resolve, reject) {
            options && "cache" === options.source ? _this.firestore.ensureClientConfigured().getDocumentFromLocalCache(_this._key).then(function(doc) {
              resolve(new DocumentSnapshot(_this.firestore, _this._key, doc, true));
            }, reject) : _this.getViaSnapshotListener(resolve, reject, options);
          });
        };
        DocumentReference.prototype.getViaSnapshotListener = function(resolve, reject, options) {
          var unlisten = this.onSnapshotInternal({
            includeMetadataChanges: true,
            waitForSyncWhenOnline: true
          }, {
            next: function(snap) {
              unlisten();
              !snap.exists && snap.metadata.fromCache ? reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document because the client is offline.")) : snap.exists && snap.metadata.fromCache && options && "server" === options.source ? reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : resolve(snap);
            },
            error: reject
          });
        };
        return DocumentReference;
      }();
      var SnapshotMetadata = function() {
        function SnapshotMetadata(hasPendingWrites, fromCache) {
          this.hasPendingWrites = hasPendingWrites;
          this.fromCache = fromCache;
        }
        SnapshotMetadata.prototype.isEqual = function(other) {
          return this.hasPendingWrites === other.hasPendingWrites && this.fromCache === other.fromCache;
        };
        return SnapshotMetadata;
      }();
      var DocumentSnapshot = function() {
        function DocumentSnapshot(_firestore, _key, _document, _fromCache) {
          this._firestore = _firestore;
          this._key = _key;
          this._document = _document;
          this._fromCache = _fromCache;
        }
        DocumentSnapshot.prototype.data = function(options) {
          validateBetweenNumberOfArgs("DocumentSnapshot.data", arguments, 0, 1);
          options = validateSnapshotOptions("DocumentSnapshot.data", options);
          return this._document ? this.convertObject(this._document.data, FieldValueOptions.fromSnapshotOptions(options, this._firestore._areTimestampsInSnapshotsEnabled())) : void 0;
        };
        DocumentSnapshot.prototype.get = function(fieldPath, options) {
          validateBetweenNumberOfArgs("DocumentSnapshot.get", arguments, 1, 2);
          options = validateSnapshotOptions("DocumentSnapshot.get", options);
          if (this._document) {
            var value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
            if (void 0 !== value) return this.convertValue(value, FieldValueOptions.fromSnapshotOptions(options, this._firestore._areTimestampsInSnapshotsEnabled()));
          }
          return;
        };
        Object.defineProperty(DocumentSnapshot.prototype, "id", {
          get: function() {
            return this._key.path.lastSegment();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "ref", {
          get: function() {
            return new DocumentReference(this._key, this._firestore);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "exists", {
          get: function() {
            return null !== this._document;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "metadata", {
          get: function() {
            return new SnapshotMetadata(null !== this._document && this._document.hasLocalMutations, this._fromCache);
          },
          enumerable: true,
          configurable: true
        });
        DocumentSnapshot.prototype.isEqual = function(other) {
          if (!(other instanceof DocumentSnapshot)) throw invalidClassError("isEqual", "DocumentSnapshot", 1, other);
          return this._firestore === other._firestore && this._fromCache === other._fromCache && this._key.isEqual(other._key) && (null === this._document ? null === other._document : this._document.isEqual(other._document));
        };
        DocumentSnapshot.prototype.convertObject = function(data, options) {
          var _this = this;
          var result = {};
          data.forEach(function(key, value) {
            result[key] = _this.convertValue(value, options);
          });
          return result;
        };
        DocumentSnapshot.prototype.convertValue = function(value, options) {
          if (value instanceof ObjectValue) return this.convertObject(value, options);
          if (value instanceof ArrayValue) return this.convertArray(value, options);
          if (value instanceof RefValue) {
            var key = value.value(options);
            var database = this._firestore.ensureClientConfigured().databaseId();
            value.databaseId.isEqual(database) || error("Document " + this._key.path + " contains a document reference within a different database (" + value.databaseId.projectId + "/" + value.databaseId.database + ") which is not supported. It will be treated as a reference in the current database (" + database.projectId + "/" + database.database + ") instead.");
            return new DocumentReference(key, this._firestore);
          }
          return value.value(options);
        };
        DocumentSnapshot.prototype.convertArray = function(data, options) {
          var _this = this;
          return data.internalValue.map(function(value) {
            return _this.convertValue(value, options);
          });
        };
        return DocumentSnapshot;
      }();
      var QueryDocumentSnapshot = function(_super) {
        tslib_1.__extends(QueryDocumentSnapshot, _super);
        function QueryDocumentSnapshot(firestore, key, document, fromCache) {
          return _super.call(this, firestore, key, document, fromCache) || this;
        }
        QueryDocumentSnapshot.prototype.data = function(options) {
          var data = _super.prototype.data.call(this, options);
          assert("object" === typeof data, "Document in a QueryDocumentSnapshot should exist");
          return data;
        };
        return QueryDocumentSnapshot;
      }(DocumentSnapshot);
      var Query$1 = function() {
        function Query$$1(_query, firestore) {
          this._query = _query;
          this.firestore = firestore;
        }
        Query$$1.prototype.where = function(field, opStr, value) {
          validateExactNumberOfArgs("Query.where", arguments, 3);
          validateArgType("Query.where", "string", 2, opStr);
          validateDefined("Query.where", 3, value);
          var fieldValue;
          var fieldPath = fieldPathFromArgument("Query.where", field);
          var relationOp = RelationOp.fromString(opStr);
          if (fieldPath.isKeyField()) {
            if (relationOp === RelationOp.ARRAY_CONTAINS) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. You can't perform array-contains queries on FieldPath.documentId() since document IDs are not arrays.");
            if ("string" === typeof value) {
              if (-1 !== value.indexOf("/")) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it contains a slash.");
              if ("" === value) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a valid document ID if the first parameter is FieldPath.documentId(), but it was an empty string.");
              var path = this._query.path.child(new ResourcePath([ value ]));
              assert(path.length % 2 === 0, "Path should be a document key");
              fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));
            } else {
              if (!(value instanceof DocumentReference)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a string or a DocumentReference if the first parameter is FieldPath.documentId(), but it was: " + valueDescription(value) + ".");
              var ref = value;
              fieldValue = new RefValue(this.firestore._databaseId, ref._key);
            }
          } else fieldValue = this.firestore._dataConverter.parseQueryValue("Query.where", value);
          var filter = Filter.create(fieldPath, relationOp, fieldValue);
          this.validateNewFilter(filter);
          return new Query$$1(this._query.addFilter(filter), this.firestore);
        };
        Query$$1.prototype.orderBy = function(field, directionStr) {
          validateBetweenNumberOfArgs("Query.orderBy", arguments, 1, 2);
          validateOptionalArgType("Query.orderBy", "string", 2, directionStr);
          var direction;
          if (void 0 === directionStr || "asc" === directionStr) direction = Direction.ASCENDING; else {
            if ("desc" !== directionStr) throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.orderBy() has unknown direction '" + directionStr + "', expected 'asc' or 'desc'.");
            direction = Direction.DESCENDING;
          }
          if (null !== this._query.startAt) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call Query.startAt() or Query.startAfter() before calling Query.orderBy().");
          if (null !== this._query.endAt) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call Query.endAt() or Query.endBefore() before calling Query.orderBy().");
          var fieldPath = fieldPathFromArgument("Query.orderBy", field);
          var orderBy = new OrderBy(fieldPath, direction);
          this.validateNewOrderBy(orderBy);
          return new Query$$1(this._query.addOrderBy(orderBy), this.firestore);
        };
        Query$$1.prototype.limit = function(n) {
          validateExactNumberOfArgs("Query.limit", arguments, 1);
          validateArgType("Query.limit", "number", 1, n);
          if (n <= 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. Query limit (" + n + ") is invalid. Limit must be positive.");
          return new Query$$1(this._query.withLimit(n), this.firestore);
        };
        Query$$1.prototype.startAt = function(docOrField) {
          var fields = [];
          for (var _i = 1; _i < arguments.length; _i++) fields[_i - 1] = arguments[_i];
          validateAtLeastNumberOfArgs("Query.startAt", arguments, 1);
          var bound = this.boundFromDocOrFields("Query.startAt", docOrField, fields, true);
          return new Query$$1(this._query.withStartAt(bound), this.firestore);
        };
        Query$$1.prototype.startAfter = function(docOrField) {
          var fields = [];
          for (var _i = 1; _i < arguments.length; _i++) fields[_i - 1] = arguments[_i];
          validateAtLeastNumberOfArgs("Query.startAfter", arguments, 1);
          var bound = this.boundFromDocOrFields("Query.startAfter", docOrField, fields, false);
          return new Query$$1(this._query.withStartAt(bound), this.firestore);
        };
        Query$$1.prototype.endBefore = function(docOrField) {
          var fields = [];
          for (var _i = 1; _i < arguments.length; _i++) fields[_i - 1] = arguments[_i];
          validateAtLeastNumberOfArgs("Query.endBefore", arguments, 1);
          var bound = this.boundFromDocOrFields("Query.endBefore", docOrField, fields, true);
          return new Query$$1(this._query.withEndAt(bound), this.firestore);
        };
        Query$$1.prototype.endAt = function(docOrField) {
          var fields = [];
          for (var _i = 1; _i < arguments.length; _i++) fields[_i - 1] = arguments[_i];
          validateAtLeastNumberOfArgs("Query.endAt", arguments, 1);
          var bound = this.boundFromDocOrFields("Query.endAt", docOrField, fields, false);
          return new Query$$1(this._query.withEndAt(bound), this.firestore);
        };
        Query$$1.prototype.isEqual = function(other) {
          if (!(other instanceof Query$$1)) throw invalidClassError("isEqual", "Query", 1, other);
          return this.firestore === other.firestore && this._query.isEqual(other._query);
        };
        Query$$1.prototype.boundFromDocOrFields = function(methodName, docOrField, fields, before) {
          validateDefined(methodName, 1, docOrField);
          if (docOrField instanceof DocumentSnapshot) {
            if (fields.length > 0) throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "().");
            var snap = docOrField;
            if (!snap.exists) throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + methodName + "().");
            return this.boundFromDocument(methodName, snap._document, before);
          }
          var allFields = [ docOrField ].concat(fields);
          return this.boundFromFields(methodName, allFields, before);
        };
        Query$$1.prototype.boundFromDocument = function(methodName, doc, before) {
          var components = [];
          for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            if (orderBy.field.isKeyField()) components.push(new RefValue(this.firestore._databaseId, doc.key)); else {
              var value = doc.field(orderBy.field);
              if (void 0 === value) {
                var field = orderBy.field.canonicalString();
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a document for which the field '" + field + "' (used as the orderBy) does not exist.");
              }
              components.push(value);
            }
          }
          return new Bound(components, before);
        };
        Query$$1.prototype.boundFromFields = function(methodName, values, before) {
          var orderBy = this._query.explicitOrderBy;
          if (values.length > orderBy.length) throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). The number of arguments must be less than or equal to the number of Query.orderBy() clauses");
          var components = [];
          for (var i = 0; i < values.length; i++) {
            var rawValue = values[i];
            var orderByComponent = orderBy[i];
            if (orderByComponent.field.isKeyField()) {
              if ("string" !== typeof rawValue) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + methodName + "(), but got a " + typeof rawValue);
              if (-1 !== rawValue.indexOf("/")) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Document ID '" + rawValue + "' contains a slash in " + methodName + "()");
              var key = new DocumentKey(this._query.path.child(rawValue));
              components.push(new RefValue(this.firestore._databaseId, key));
            } else {
              var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);
              components.push(wrapped);
            }
          }
          return new Bound(components, before);
        };
        Query$$1.prototype.onSnapshot = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          validateBetweenNumberOfArgs("Query.onSnapshot", arguments, 1, 4);
          var options = {};
          var observer;
          var currArg = 0;
          if ("object" === typeof args[currArg] && !isPartialObserver(args[currArg])) {
            options = args[currArg];
            validateOptionNames("Query.onSnapshot", options, [ "includeMetadataChanges" ]);
            validateNamedOptionalType("Query.onSnapshot", "boolean", "includeMetadataChanges", options.includeMetadataChanges);
            currArg++;
          }
          if (isPartialObserver(args[currArg])) observer = args[currArg]; else {
            validateArgType("Query.onSnapshot", "function", currArg, args[currArg]);
            validateOptionalArgType("Query.onSnapshot", "function", currArg + 1, args[currArg + 1]);
            validateOptionalArgType("Query.onSnapshot", "function", currArg + 2, args[currArg + 2]);
            observer = {
              next: args[currArg],
              error: args[currArg + 1],
              complete: args[currArg + 2]
            };
          }
          return this.onSnapshotInternal(options, observer);
        };
        Query$$1.prototype.onSnapshotInternal = function(options, observer) {
          var _this = this;
          var errHandler = function(err) {
            console.error("Uncaught Error in onSnapshot:", err);
          };
          observer.error && (errHandler = observer.error.bind(observer));
          var asyncObserver = new AsyncObserver({
            next: function(result) {
              observer.next && observer.next(new QuerySnapshot(_this.firestore, _this._query, result));
            },
            error: errHandler
          });
          var firestoreClient = this.firestore.ensureClientConfigured();
          var internalListener = firestoreClient.listen(this._query, asyncObserver, options);
          return function() {
            asyncObserver.mute();
            firestoreClient.unlisten(internalListener);
          };
        };
        Query$$1.prototype.get = function(options) {
          var _this = this;
          validateBetweenNumberOfArgs("Query.get", arguments, 0, 1);
          return new Promise(function(resolve, reject) {
            options && "cache" === options.source ? _this.firestore.ensureClientConfigured().getDocumentsFromLocalCache(_this._query).then(function(viewSnap) {
              resolve(new QuerySnapshot(_this.firestore, _this._query, viewSnap));
            }, reject) : _this.getViaSnapshotListener(resolve, reject, options);
          });
        };
        Query$$1.prototype.getViaSnapshotListener = function(resolve, reject, options) {
          var unlisten = this.onSnapshotInternal({
            includeMetadataChanges: true,
            waitForSyncWhenOnline: true
          }, {
            next: function(result) {
              unlisten();
              result.metadata.fromCache && options && "server" === options.source ? reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : resolve(result);
            },
            error: reject
          });
        };
        Query$$1.prototype.validateNewFilter = function(filter) {
          if (filter instanceof RelationFilter) if (filter.isInequality()) {
            var existingField = this._query.getInequalityFilterField();
            if (null !== existingField && !existingField.isEqual(filter.field)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '" + existingField.toString() + "' and '" + filter.field.toString() + "'");
            var firstOrderByField = this._query.getFirstOrderByField();
            null !== firstOrderByField && this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);
          } else if (filter.op === RelationOp.ARRAY_CONTAINS && this._query.hasArrayContainsFilter()) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Queries only support a single array-contains filter.");
        };
        Query$$1.prototype.validateNewOrderBy = function(orderBy) {
          if (null === this._query.getFirstOrderByField()) {
            var inequalityField = this._query.getInequalityFilterField();
            null !== inequalityField && this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);
          }
        };
        Query$$1.prototype.validateOrderByAndInequalityMatch = function(inequality, orderBy) {
          if (!orderBy.isEqual(inequality)) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '" + inequality.toString() + "' and so you must also use '" + inequality.toString() + "' as your first Query.orderBy(), but your first Query.orderBy() is on field '" + orderBy.toString() + "' instead.");
        };
        return Query$$1;
      }();
      var QuerySnapshot = function() {
        function QuerySnapshot(_firestore, _originalQuery, _snapshot) {
          this._firestore = _firestore;
          this._originalQuery = _originalQuery;
          this._snapshot = _snapshot;
          this._cachedChanges = null;
          this._cachedChangesIncludeMetadataChanges = null;
          this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
        }
        Object.defineProperty(QuerySnapshot.prototype, "docs", {
          get: function() {
            var result = [];
            this.forEach(function(doc) {
              return result.push(doc);
            });
            return result;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(QuerySnapshot.prototype, "empty", {
          get: function() {
            return this._snapshot.docs.isEmpty();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(QuerySnapshot.prototype, "size", {
          get: function() {
            return this._snapshot.docs.size;
          },
          enumerable: true,
          configurable: true
        });
        QuerySnapshot.prototype.forEach = function(callback, thisArg) {
          var _this = this;
          validateBetweenNumberOfArgs("QuerySnapshot.forEach", arguments, 1, 2);
          validateArgType("QuerySnapshot.forEach", "function", 1, callback);
          this._snapshot.docs.forEach(function(doc) {
            callback.call(thisArg, _this.convertToDocumentImpl(doc));
          });
        };
        Object.defineProperty(QuerySnapshot.prototype, "query", {
          get: function() {
            return new Query$1(this._originalQuery, this._firestore);
          },
          enumerable: true,
          configurable: true
        });
        QuerySnapshot.prototype.docChanges = function(options) {
          validateOptionNames("QuerySnapshot.docChanges", options, [ "includeMetadataChanges" ]);
          options && validateNamedOptionalType("QuerySnapshot.docChanges", "boolean", "includeMetadataChanges", options.includeMetadataChanges);
          var includeMetadataChanges = options && options.includeMetadataChanges;
          if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) throw new FirestoreError(Code.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
          if (!this._cachedChanges || this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {
            this._cachedChanges = changesFromSnapshot(this._firestore, includeMetadataChanges, this._snapshot);
            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;
          }
          return this._cachedChanges;
        };
        QuerySnapshot.prototype.isEqual = function(other) {
          if (!(other instanceof QuerySnapshot)) throw invalidClassError("isEqual", "QuerySnapshot", 1, other);
          return this._firestore === other._firestore && this._originalQuery.isEqual(other._originalQuery) && this._snapshot.isEqual(other._snapshot);
        };
        QuerySnapshot.prototype.convertToDocumentImpl = function(doc) {
          return new QueryDocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);
        };
        return QuerySnapshot;
      }();
      function throwDocChangesMethodError() {
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a method, so usages like "querySnapshot.docChanges" should become "querySnapshot.docChanges()"');
      }
      var docChangesPropertiesToOverride = [ "length", "forEach", "map" ].concat("undefined" !== typeof Symbol ? [ Symbol.iterator ] : []);
      docChangesPropertiesToOverride.forEach(function(property) {
        try {
          Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {
            get: function() {
              return throwDocChangesMethodError();
            }
          });
        } catch (err) {}
      });
      var CollectionReference = function(_super) {
        tslib_1.__extends(CollectionReference, _super);
        function CollectionReference(path, firestore) {
          var _this = _super.call(this, Query.atPath(path), firestore) || this;
          if (path.length % 2 !== 1) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + path.canonicalString() + " has " + path.length);
          return _this;
        }
        Object.defineProperty(CollectionReference.prototype, "id", {
          get: function() {
            return this._query.path.lastSegment();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CollectionReference.prototype, "parent", {
          get: function() {
            var parentPath = this._query.path.popLast();
            return parentPath.isEmpty() ? null : new DocumentReference(new DocumentKey(parentPath), this.firestore);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(CollectionReference.prototype, "path", {
          get: function() {
            return this._query.path.canonicalString();
          },
          enumerable: true,
          configurable: true
        });
        CollectionReference.prototype.doc = function(pathString) {
          validateBetweenNumberOfArgs("CollectionReference.doc", arguments, 0, 1);
          0 === arguments.length && (pathString = AutoId.newId());
          validateArgType("CollectionReference.doc", "string", 1, pathString);
          if ("" === pathString) throw new FirestoreError(Code.INVALID_ARGUMENT, "Document path must be a non-empty string");
          var path = ResourcePath.fromString(pathString);
          return DocumentReference.forPath(this._query.path.child(path), this.firestore);
        };
        CollectionReference.prototype.add = function(value) {
          validateExactNumberOfArgs("CollectionReference.add", arguments, 1);
          validateArgType("CollectionReference.add", "object", 1, value);
          var docRef = this.doc();
          return docRef.set(value).then(function() {
            return docRef;
          });
        };
        return CollectionReference;
      }(Query$1);
      function validateSetOptions(methodName, options) {
        if (void 0 === options) return {
          merge: false
        };
        validateOptionNames(methodName, options, [ "merge", "mergeFields" ]);
        validateNamedOptionalType(methodName, "boolean", "merge", options.merge);
        validateOptionalArrayElements(methodName, "mergeFields", "a string or a FieldPath", options.mergeFields, function(element) {
          return "string" === typeof element || element instanceof FieldPath$1;
        });
        if (void 0 !== options.mergeFields && void 0 !== options.merge) throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid options passed to function " + methodName + '(): You cannot specify both "merge" and "mergeFields".');
        return options;
      }
      function validateSnapshotOptions(methodName, options) {
        if (void 0 === options) return {};
        validateOptionNames(methodName, options, [ "serverTimestamps" ]);
        validateNamedOptionalPropertyEquals(methodName, "options", "serverTimestamps", options.serverTimestamps, [ "estimate", "previous", "none" ]);
        return options;
      }
      function validateReference(methodName, documentRef, firestore) {
        if (documentRef instanceof DocumentReference) {
          if (documentRef.firestore !== firestore) throw new FirestoreError(Code.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
          return documentRef;
        }
        throw invalidClassError(methodName, "DocumentReference", 1, documentRef);
      }
      function changesFromSnapshot(firestore, includeMetadataChanges, snapshot) {
        if (snapshot.oldDocs.isEmpty()) {
          var lastDoc_1;
          var index_1 = 0;
          return snapshot.docChanges.map(function(change) {
            var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
            assert(change.type === ChangeType.Added, "Invalid event type for first snapshot");
            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, "Got added events in wrong order");
            lastDoc_1 = change.doc;
            return {
              type: "added",
              doc: doc,
              oldIndex: -1,
              newIndex: index_1++
            };
          });
        }
        var indexTracker_1 = snapshot.oldDocs;
        return snapshot.docChanges.filter(function(change) {
          return includeMetadataChanges || change.type !== ChangeType.Metadata;
        }).map(function(change) {
          var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
          var oldIndex = -1;
          var newIndex = -1;
          if (change.type !== ChangeType.Added) {
            oldIndex = indexTracker_1.indexOf(change.doc.key);
            assert(oldIndex >= 0, "Index for document not found");
            indexTracker_1 = indexTracker_1.delete(change.doc.key);
          }
          if (change.type !== ChangeType.Removed) {
            indexTracker_1 = indexTracker_1.add(change.doc);
            newIndex = indexTracker_1.indexOf(change.doc.key);
          }
          return {
            type: resultChangeType(change.type),
            doc: doc,
            oldIndex: oldIndex,
            newIndex: newIndex
          };
        });
      }
      function resultChangeType(type) {
        switch (type) {
         case ChangeType.Added:
          return "added";

         case ChangeType.Modified:
         case ChangeType.Metadata:
          return "modified";

         case ChangeType.Removed:
          return "removed";

         default:
          return fail("Unknown change type: " + type);
        }
      }
      var PublicFirestore = makeConstructorPrivate(Firestore, "Use firebase.firestore() instead.");
      var PublicTransaction = makeConstructorPrivate(Transaction$1, "Use firebase.firestore().runTransaction() instead.");
      var PublicWriteBatch = makeConstructorPrivate(WriteBatch, "Use firebase.firestore().batch() instead.");
      var PublicDocumentReference = makeConstructorPrivate(DocumentReference, "Use firebase.firestore().doc() instead.");
      var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);
      var PublicQueryDocumentSnapshot = makeConstructorPrivate(QueryDocumentSnapshot);
      var PublicQuery = makeConstructorPrivate(Query$1);
      var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);
      var PublicCollectionReference = makeConstructorPrivate(CollectionReference, "Use firebase.firestore().collection() instead.");
      var firestoreNamespace = {
        Firestore: PublicFirestore,
        GeoPoint: GeoPoint,
        Timestamp: Timestamp,
        Blob: PublicBlob,
        Transaction: PublicTransaction,
        WriteBatch: PublicWriteBatch,
        DocumentReference: PublicDocumentReference,
        DocumentSnapshot: PublicDocumentSnapshot,
        Query: PublicQuery,
        QueryDocumentSnapshot: PublicQueryDocumentSnapshot,
        QuerySnapshot: PublicQuerySnapshot,
        CollectionReference: PublicCollectionReference,
        FieldPath: FieldPath$1,
        FieldValue: PublicFieldValue,
        setLogLevel: Firestore.setLogLevel
      };
      function configureForFirebase(firebase$$1) {
        firebase$$1.INTERNAL.registerService("firestore", function(app) {
          return new Firestore(app);
        }, shallowCopy(firestoreNamespace));
      }
      function registerFirestore(instance) {
        configureForFirebase(instance);
      }
      registerFirestore(firebase);
      exports.registerFirestore = registerFirestore;
    }).call(this, require("_process"));
  }, {
    "@firebase/app": 7,
    "@firebase/logger": 12,
    "@firebase/webchannel-wrapper": 17,
    _process: 6,
    tslib: 61
  } ],
  11: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _interopDefault(ex) {
      return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
    }
    var tslib_1 = require("tslib");
    var firebase = _interopDefault(require("@firebase/app"));
    var errorCodeMap = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    var HttpsErrorImpl = function(_super) {
      tslib_1.__extends(HttpsErrorImpl, _super);
      function HttpsErrorImpl(code, message, details) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, HttpsErrorImpl.prototype);
        _this.code = code;
        _this.details = details;
        return _this;
      }
      return HttpsErrorImpl;
    }(Error);
    function codeForHTTPStatus(status) {
      if (status >= 200 && status < 300) return "ok";
      switch (status) {
       case 0:
        return "internal";

       case 400:
        return "invalid-argument";

       case 401:
        return "unauthenticated";

       case 403:
        return "permission-denied";

       case 404:
        return "not-found";

       case 409:
        return "aborted";

       case 429:
        return "resource-exhausted";

       case 499:
        return "cancelled";

       case 500:
        return "internal";

       case 501:
        return "unimplemented";

       case 503:
        return "unavailable";

       case 504:
        return "deadline-exceeded";
      }
      return "unknown";
    }
    function _errorForResponse(status, bodyJSON, serializer) {
      var code = codeForHTTPStatus(status);
      var description = code;
      var details = void 0;
      try {
        var errorJSON = bodyJSON.error;
        if (errorJSON) {
          var status_1 = errorJSON.status;
          if ("string" === typeof status_1) {
            if (!errorCodeMap[status_1]) return new HttpsErrorImpl("internal", "internal");
            code = errorCodeMap[status_1];
          }
          description = status_1;
          var message = errorJSON.message;
          "string" === typeof message && (description = message);
          details = errorJSON.details;
          void 0 !== details && (details = serializer.decode(details));
        }
      } catch (e) {}
      if ("ok" === code) return null;
      return new HttpsErrorImpl(code, description, details);
    }
    var ContextProvider = function() {
      function ContextProvider(app) {
        this.app = app;
      }
      ContextProvider.prototype.getAuthToken = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var token, e_1;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              _a.trys.push([ 0, 2, , 3 ]);
              return [ 4, this.app.INTERNAL.getToken() ];

             case 1:
              token = _a.sent();
              if (!token) return [ 2, void 0 ];
              return [ 2, token.accessToken ];

             case 2:
              e_1 = _a.sent();
              return [ 2, void 0 ];

             case 3:
              return [ 2 ];
            }
          });
        });
      };
      ContextProvider.prototype.getInstanceIdToken = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var messaging, token, e_2;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              _a.trys.push([ 0, 2, , 3 ]);
              if (!this.app.messaging) return [ 2, void 0 ];
              messaging = this.app.messaging();
              return [ 4, messaging.getToken() ];

             case 1:
              token = _a.sent();
              if (!token) return [ 2, void 0 ];
              return [ 2, token ];

             case 2:
              e_2 = _a.sent();
              return [ 2, void 0 ];

             case 3:
              return [ 2 ];
            }
          });
        });
      };
      ContextProvider.prototype.getContext = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var authToken, instanceIdToken;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.getAuthToken() ];

             case 1:
              authToken = _a.sent();
              return [ 4, this.getInstanceIdToken() ];

             case 2:
              instanceIdToken = _a.sent();
              return [ 2, {
                authToken: authToken,
                instanceIdToken: instanceIdToken
              } ];
            }
          });
        });
      };
      return ContextProvider;
    }();
    var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
    var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
    function mapValues(o, f) {
      var result = {};
      for (var key in o) o.hasOwnProperty(key) && (result[key] = f(o[key]));
      return result;
    }
    var Serializer = function() {
      function Serializer() {}
      Serializer.prototype.encode = function(data) {
        var _this = this;
        if (null === data || void 0 === data) return null;
        data instanceof Number && (data = data.valueOf());
        if ("number" === typeof data && isFinite(data)) return data;
        if (true === data || false === data) return data;
        if ("[object String]" === Object.prototype.toString.call(data)) return data;
        if (Array.isArray(data)) return data.map(function(x) {
          return _this.encode(x);
        });
        if ("function" === typeof data || "object" === typeof data) return mapValues(data, function(x) {
          return _this.encode(x);
        });
        throw new Error("Data cannot be encoded in JSON: " + data);
      };
      Serializer.prototype.decode = function(json) {
        var _this = this;
        if (null === json) return json;
        if (json["@type"]) switch (json["@type"]) {
         case LONG_TYPE:
         case UNSIGNED_LONG_TYPE:
          var value = parseFloat(json.value);
          if (isNaN(value)) throw new Error("Data cannot be decoded from JSON: " + json);
          return value;

         default:
          throw new Error("Data cannot be decoded from JSON: " + json);
        }
        if (Array.isArray(json)) return json.map(function(x) {
          return _this.decode(x);
        });
        if ("function" === typeof json || "object" === typeof json) return mapValues(json, function(x) {
          return _this.decode(x);
        });
        return json;
      };
      return Serializer;
    }();
    var Service = function() {
      function Service(app_, region_) {
        void 0 === region_ && (region_ = "us-central1");
        this.app_ = app_;
        this.region_ = region_;
        this.serializer = new Serializer();
        this.emulatorOrigin = null;
        this.contextProvider = new ContextProvider(app_);
      }
      Object.defineProperty(Service.prototype, "app", {
        get: function() {
          return this.app_;
        },
        enumerable: true,
        configurable: true
      });
      Service.prototype._url = function(name) {
        var projectId = this.app_.options.projectId;
        var region = this.region_;
        if (null !== this.emulatorOrigin) {
          var origin = this.emulatorOrigin;
          return origin + "/" + projectId + "/" + region + "/" + name;
        }
        return "https://" + region + "-" + projectId + ".cloudfunctions.net/" + name;
      };
      Service.prototype.useFunctionsEmulator = function(origin) {
        this.emulatorOrigin = origin;
      };
      Service.prototype.httpsCallable = function(name) {
        var _this = this;
        var callable = function(data) {
          return _this.call(name, data);
        };
        return callable;
      };
      Service.prototype.postJSON = function(url, body, headers) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var response, e_1, json, e_2;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              headers.append("Content-Type", "application/json");
              _a.label = 1;

             case 1:
              _a.trys.push([ 1, 3, , 4 ]);
              return [ 4, fetch(url, {
                method: "POST",
                body: JSON.stringify(body),
                headers: headers
              }) ];

             case 2:
              response = _a.sent();
              return [ 3, 4 ];

             case 3:
              e_1 = _a.sent();
              return [ 2, {
                status: 0,
                json: null
              } ];

             case 4:
              json = null;
              _a.label = 5;

             case 5:
              _a.trys.push([ 5, 7, , 8 ]);
              return [ 4, response.json() ];

             case 6:
              json = _a.sent();
              return [ 3, 8 ];

             case 7:
              e_2 = _a.sent();
              return [ 3, 8 ];

             case 8:
              return [ 2, {
                status: response.status,
                json: json
              } ];
            }
          });
        });
      };
      Service.prototype.call = function(name, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var url, body, headers, context, response, error, responseData, decodedData;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              url = this._url(name);
              data = this.serializer.encode(data);
              body = {
                data: data
              };
              headers = new Headers();
              return [ 4, this.contextProvider.getContext() ];

             case 1:
              context = _a.sent();
              context.authToken && headers.append("Authorization", "Bearer " + context.authToken);
              context.instanceIdToken && headers.append("Firebase-Instance-ID-Token", context.instanceIdToken);
              return [ 4, this.postJSON(url, body, headers) ];

             case 2:
              response = _a.sent();
              error = _errorForResponse(response.status, response.json, this.serializer);
              if (error) throw error;
              if (!response.json) throw new HttpsErrorImpl("internal", "Response is not valid JSON object.");
              responseData = response.json.data;
              "undefined" === typeof responseData && (responseData = response.json.result);
              if ("undefined" === typeof responseData) throw new HttpsErrorImpl("internal", "Response is missing data field.");
              decodedData = this.serializer.decode(responseData);
              return [ 2, {
                data: decodedData
              } ];
            }
          });
        });
      };
      return Service;
    }();
    var FUNCTIONS_TYPE = "functions";
    function factory(app, unused, region) {
      return new Service(app, region);
    }
    function registerFunctions(instance) {
      var namespaceExports = {
        Functions: Service
      };
      instance.INTERNAL.registerService(FUNCTIONS_TYPE, factory, namespaceExports, void 0, true);
    }
    registerFunctions(firebase);
    exports.registerFunctions = registerFunctions;
  }, {
    "@firebase/app": 7,
    tslib: 61
  } ],
  12: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var instances = [];
    (function(LogLevel) {
      LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
      LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
      LogLevel[LogLevel["INFO"] = 2] = "INFO";
      LogLevel[LogLevel["WARN"] = 3] = "WARN";
      LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
      LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
    })(exports.LogLevel || (exports.LogLevel = {}));
    var defaultLogLevel = exports.LogLevel.INFO;
    var defaultLogHandler = function(instance, logType) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
      if (logType < instance.logLevel) return;
      var now = new Date().toISOString();
      switch (logType) {
       case exports.LogLevel.DEBUG:
       case exports.LogLevel.VERBOSE:
        console.log.apply(console, [ "[" + now + "]  " + instance.name + ":" ].concat(args));
        break;

       case exports.LogLevel.INFO:
        console.info.apply(console, [ "[" + now + "]  " + instance.name + ":" ].concat(args));
        break;

       case exports.LogLevel.WARN:
        console.warn.apply(console, [ "[" + now + "]  " + instance.name + ":" ].concat(args));
        break;

       case exports.LogLevel.ERROR:
        console.error.apply(console, [ "[" + now + "]  " + instance.name + ":" ].concat(args));
        break;

       default:
        throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
      }
    };
    var Logger = function() {
      function Logger(name) {
        this.name = name;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        instances.push(this);
      }
      Object.defineProperty(Logger.prototype, "logLevel", {
        get: function() {
          return this._logLevel;
        },
        set: function(val) {
          if (!(val in exports.LogLevel)) throw new TypeError("Invalid value assigned to `logLevel`");
          this._logLevel = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Logger.prototype, "logHandler", {
        get: function() {
          return this._logHandler;
        },
        set: function(val) {
          if ("function" !== typeof val) throw new TypeError("Value assigned to `logHandler` must be a function");
          this._logHandler = val;
        },
        enumerable: true,
        configurable: true
      });
      Logger.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        this._logHandler.apply(this, [ this, exports.LogLevel.DEBUG ].concat(args));
      };
      Logger.prototype.log = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        this._logHandler.apply(this, [ this, exports.LogLevel.VERBOSE ].concat(args));
      };
      Logger.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        this._logHandler.apply(this, [ this, exports.LogLevel.INFO ].concat(args));
      };
      Logger.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        this._logHandler.apply(this, [ this, exports.LogLevel.WARN ].concat(args));
      };
      Logger.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        this._logHandler.apply(this, [ this, exports.LogLevel.ERROR ].concat(args));
      };
      return Logger;
    }();
    function setLogLevel(level) {
      instances.forEach(function(inst) {
        inst.logLevel = level;
      });
    }
    exports.setLogLevel = setLogLevel;
    exports.Logger = Logger;
  }, {} ],
  13: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _interopDefault(ex) {
      return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
    }
    var util = require("@firebase/util");
    var tslib_1 = require("tslib");
    var firebase = _interopDefault(require("@firebase/app"));
    var ERROR_CODES = {
      AVAILABLE_IN_WINDOW: "only-available-in-window",
      AVAILABLE_IN_SW: "only-available-in-sw",
      SHOULD_BE_INHERITED: "should-be-overriden",
      BAD_SENDER_ID: "bad-sender-id",
      INCORRECT_GCM_SENDER_ID: "incorrect-gcm-sender-id",
      PERMISSION_DEFAULT: "permission-default",
      PERMISSION_BLOCKED: "permission-blocked",
      UNSUPPORTED_BROWSER: "unsupported-browser",
      NOTIFICATIONS_BLOCKED: "notifications-blocked",
      FAILED_DEFAULT_REGISTRATION: "failed-serviceworker-registration",
      SW_REGISTRATION_EXPECTED: "sw-registration-expected",
      GET_SUBSCRIPTION_FAILED: "get-subscription-failed",
      INVALID_SAVED_TOKEN: "invalid-saved-token",
      SW_REG_REDUNDANT: "sw-reg-redundant",
      TOKEN_SUBSCRIBE_FAILED: "token-subscribe-failed",
      TOKEN_SUBSCRIBE_NO_TOKEN: "token-subscribe-no-token",
      TOKEN_SUBSCRIBE_NO_PUSH_SET: "token-subscribe-no-push-set",
      TOKEN_UNSUBSCRIBE_FAILED: "token-unsubscribe-failed",
      TOKEN_UPDATE_FAILED: "token-update-failed",
      TOKEN_UPDATE_NO_TOKEN: "token-update-no-token",
      USE_SW_BEFORE_GET_TOKEN: "use-sw-before-get-token",
      INVALID_DELETE_TOKEN: "invalid-delete-token",
      DELETE_TOKEN_NOT_FOUND: "delete-token-not-found",
      DELETE_SCOPE_NOT_FOUND: "delete-scope-not-found",
      BG_HANDLER_FUNCTION_EXPECTED: "bg-handler-function-expected",
      NO_WINDOW_CLIENT_TO_MSG: "no-window-client-to-msg",
      UNABLE_TO_RESUBSCRIBE: "unable-to-resubscribe",
      NO_FCM_TOKEN_FOR_RESUBSCRIBE: "no-fcm-token-for-resubscribe",
      FAILED_TO_DELETE_TOKEN: "failed-to-delete-token",
      NO_SW_IN_REG: "no-sw-in-reg",
      BAD_SCOPE: "bad-scope",
      BAD_VAPID_KEY: "bad-vapid-key",
      BAD_SUBSCRIPTION: "bad-subscription",
      BAD_TOKEN: "bad-token",
      BAD_PUSH_SET: "bad-push-set",
      FAILED_DELETE_VAPID_KEY: "failed-delete-vapid-key",
      INVALID_PUBLIC_VAPID_KEY: "invalid-public-vapid-key",
      USE_PUBLIC_KEY_BEFORE_GET_TOKEN: "use-public-key-before-get-token",
      PUBLIC_KEY_DECRYPTION_FAILED: "public-vapid-key-decryption-failed"
    };
    var ERROR_MAP = (_a = {}, _a[ERROR_CODES.AVAILABLE_IN_WINDOW] = "This method is available in a Window context.", 
    _a[ERROR_CODES.AVAILABLE_IN_SW] = "This method is available in a service worker context.", 
    _a[ERROR_CODES.SHOULD_BE_INHERITED] = "This method should be overriden by extended classes.", 
    _a[ERROR_CODES.BAD_SENDER_ID] = "Please ensure that 'messagingSenderId' is set correctly in the options passed into firebase.initializeApp().", 
    _a[ERROR_CODES.PERMISSION_DEFAULT] = "The required permissions were not granted and dismissed instead.", 
    _a[ERROR_CODES.PERMISSION_BLOCKED] = "The required permissions were not granted and blocked instead.", 
    _a[ERROR_CODES.UNSUPPORTED_BROWSER] = "This browser doesn't support the API's required to use the firebase SDK.", 
    _a[ERROR_CODES.NOTIFICATIONS_BLOCKED] = "Notifications have been blocked.", _a[ERROR_CODES.FAILED_DEFAULT_REGISTRATION] = "We are unable to register the default service worker. {$browserErrorMessage}", 
    _a[ERROR_CODES.SW_REGISTRATION_EXPECTED] = "A service worker registration was the expected input.", 
    _a[ERROR_CODES.GET_SUBSCRIPTION_FAILED] = "There was an error when trying to get any existing Push Subscriptions.", 
    _a[ERROR_CODES.INVALID_SAVED_TOKEN] = "Unable to access details of the saved token.", 
    _a[ERROR_CODES.SW_REG_REDUNDANT] = "The service worker being used for push was made redundant.", 
    _a[ERROR_CODES.TOKEN_SUBSCRIBE_FAILED] = "A problem occured while subscribing the user to FCM: {$message}", 
    _a[ERROR_CODES.TOKEN_SUBSCRIBE_NO_TOKEN] = "FCM returned no token when subscribing the user to push.", 
    _a[ERROR_CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET] = "FCM returned an invalid response when getting an FCM token.", 
    _a[ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED] = "A problem occured while unsubscribing the user from FCM: {$message}", 
    _a[ERROR_CODES.TOKEN_UPDATE_FAILED] = "A problem occured while updating the user from FCM: {$message}", 
    _a[ERROR_CODES.TOKEN_UPDATE_NO_TOKEN] = "FCM returned no token when updating the user to push.", 
    _a[ERROR_CODES.USE_SW_BEFORE_GET_TOKEN] = "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", 
    _a[ERROR_CODES.INVALID_DELETE_TOKEN] = "You must pass a valid token into deleteToken(), i.e. the token from getToken().", 
    _a[ERROR_CODES.DELETE_TOKEN_NOT_FOUND] = "The deletion attempt for token could not be performed as the token was not found.", 
    _a[ERROR_CODES.DELETE_SCOPE_NOT_FOUND] = "The deletion attempt for service worker scope could not be performed as the scope was not found.", 
    _a[ERROR_CODES.BG_HANDLER_FUNCTION_EXPECTED] = "The input to setBackgroundMessageHandler() must be a function.", 
    _a[ERROR_CODES.NO_WINDOW_CLIENT_TO_MSG] = "An attempt was made to message a non-existant window client.", 
    _a[ERROR_CODES.UNABLE_TO_RESUBSCRIBE] = "There was an error while re-subscribing the FCM token for push messaging. Will have to resubscribe the user on next visit. {$message}", 
    _a[ERROR_CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE] = "Could not find an FCM token and as a result, unable to resubscribe. Will have to resubscribe the user on next visit.", 
    _a[ERROR_CODES.FAILED_TO_DELETE_TOKEN] = "Unable to delete the currently saved token.", 
    _a[ERROR_CODES.NO_SW_IN_REG] = "Even though the service worker registration was successful, there was a problem accessing the service worker itself.", 
    _a[ERROR_CODES.INCORRECT_GCM_SENDER_ID] = "Please change your web app manifest's 'gcm_sender_id' value to '103953800507' to use Firebase messaging.", 
    _a[ERROR_CODES.BAD_SCOPE] = "The service worker scope must be a string with at least one character.", 
    _a[ERROR_CODES.BAD_VAPID_KEY] = "The public VAPID key is not a Uint8Array with 65 bytes.", 
    _a[ERROR_CODES.BAD_SUBSCRIPTION] = "The subscription must be a valid PushSubscription.", 
    _a[ERROR_CODES.BAD_TOKEN] = "The FCM Token used for storage / lookup was not a valid token string.", 
    _a[ERROR_CODES.BAD_PUSH_SET] = "The FCM push set used for storage / lookup was not not a valid push set string.", 
    _a[ERROR_CODES.FAILED_DELETE_VAPID_KEY] = "The VAPID key could not be deleted.", 
    _a[ERROR_CODES.INVALID_PUBLIC_VAPID_KEY] = "The public VAPID key must be a string.", 
    _a[ERROR_CODES.PUBLIC_KEY_DECRYPTION_FAILED] = "The public VAPID key did not equal 65 bytes when decrypted.", 
    _a);
    var errorFactory = new util.ErrorFactory("messaging", "Messaging", ERROR_MAP);
    var _a;
    var DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([ 4, 51, 148, 247, 223, 161, 235, 177, 220, 3, 162, 94, 21, 113, 219, 72, 211, 46, 237, 237, 178, 52, 219, 183, 71, 58, 12, 143, 196, 204, 225, 111, 60, 140, 132, 223, 171, 182, 102, 62, 242, 12, 212, 139, 254, 227, 249, 118, 47, 20, 28, 99, 8, 106, 111, 45, 177, 26, 149, 176, 206, 55, 192, 156, 110 ]);
    var ENDPOINT = "https://fcm.googleapis.com";
    var MessageParameter;
    (function(MessageParameter) {
      MessageParameter["TYPE_OF_MSG"] = "firebase-messaging-msg-type";
      MessageParameter["DATA"] = "firebase-messaging-msg-data";
    })(MessageParameter || (MessageParameter = {}));
    var MessageType;
    (function(MessageType) {
      MessageType["PUSH_MSG_RECEIVED"] = "push-msg-received";
      MessageType["NOTIFICATION_CLICKED"] = "notification-clicked";
    })(MessageType || (MessageType = {}));
    function isArrayBufferEqual(a, b) {
      if (null == a || null == b) return false;
      if (a === b) return true;
      if (a.byteLength !== b.byteLength) return false;
      var viewA = new DataView(a);
      var viewB = new DataView(b);
      for (var i = 0; i < a.byteLength; i++) if (viewA.getUint8(i) !== viewB.getUint8(i)) return false;
      return true;
    }
    function toBase64(arrayBuffer) {
      var uint8Version = new Uint8Array(arrayBuffer);
      return btoa(String.fromCharCode.apply(null, uint8Version));
    }
    function arrayBufferToBase64(arrayBuffer) {
      var base64String = toBase64(arrayBuffer);
      return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    var IidModel = function() {
      function IidModel() {}
      IidModel.prototype.getToken = function(senderId, subscription, publicVapidKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var p256dh, auth, fcmSubscribeBody, applicationPubKey, headers, subscribeOptions, responseData, response, err_1, message;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              p256dh = arrayBufferToBase64(subscription.getKey("p256dh"));
              auth = arrayBufferToBase64(subscription.getKey("auth"));
              fcmSubscribeBody = "authorized_entity=" + senderId + "&endpoint=" + subscription.endpoint + "&encryption_key=" + p256dh + "&encryption_auth=" + auth;
              if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {
                applicationPubKey = arrayBufferToBase64(publicVapidKey);
                fcmSubscribeBody += "&application_pub_key=" + applicationPubKey;
              }
              headers = new Headers();
              headers.append("Content-Type", "application/x-www-form-urlencoded");
              subscribeOptions = {
                method: "POST",
                headers: headers,
                body: fcmSubscribeBody
              };
              _a.label = 1;

             case 1:
              _a.trys.push([ 1, 4, , 5 ]);
              return [ 4, fetch(ENDPOINT + "/fcm/connect/subscribe", subscribeOptions) ];

             case 2:
              response = _a.sent();
              return [ 4, response.json() ];

             case 3:
              responseData = _a.sent();
              return [ 3, 5 ];

             case 4:
              err_1 = _a.sent();
              throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_FAILED);

             case 5:
              if (responseData.error) {
                message = responseData.error.message;
                throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_FAILED, {
                  message: message
                });
              }
              if (!responseData.token) throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_NO_TOKEN);
              if (!responseData.pushSet) throw errorFactory.create(ERROR_CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET);
              return [ 2, {
                token: responseData.token,
                pushSet: responseData.pushSet
              } ];
            }
          });
        });
      };
      IidModel.prototype.updateToken = function(senderId, fcmToken, fcmPushSet, subscription, publicVapidKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var p256dh, auth, fcmUpdateBody, applicationPubKey, headers, updateOptions, responseData, response, err_2, message;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              p256dh = arrayBufferToBase64(subscription.getKey("p256dh"));
              auth = arrayBufferToBase64(subscription.getKey("auth"));
              fcmUpdateBody = "push_set=" + fcmPushSet + "&token=" + fcmToken + "&authorized_entity=" + senderId + "&endpoint=" + subscription.endpoint + "&encryption_key=" + p256dh + "&encryption_auth=" + auth;
              if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {
                applicationPubKey = arrayBufferToBase64(publicVapidKey);
                fcmUpdateBody += "&application_pub_key=" + applicationPubKey;
              }
              headers = new Headers();
              headers.append("Content-Type", "application/x-www-form-urlencoded");
              updateOptions = {
                method: "POST",
                headers: headers,
                body: fcmUpdateBody
              };
              _a.label = 1;

             case 1:
              _a.trys.push([ 1, 4, , 5 ]);
              return [ 4, fetch(ENDPOINT + "/fcm/connect/subscribe", updateOptions) ];

             case 2:
              response = _a.sent();
              return [ 4, response.json() ];

             case 3:
              responseData = _a.sent();
              return [ 3, 5 ];

             case 4:
              err_2 = _a.sent();
              throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_FAILED);

             case 5:
              if (responseData.error) {
                message = responseData.error.message;
                throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_FAILED, {
                  message: message
                });
              }
              if (!responseData.token) throw errorFactory.create(ERROR_CODES.TOKEN_UPDATE_NO_TOKEN);
              return [ 2, responseData.token ];
            }
          });
        });
      };
      IidModel.prototype.deleteToken = function(senderId, fcmToken, fcmPushSet) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var fcmUnsubscribeBody, headers, unsubscribeOptions, response, responseData, message, err_3;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              fcmUnsubscribeBody = "authorized_entity=" + senderId + "&token=" + fcmToken + "&pushSet=" + fcmPushSet;
              headers = new Headers();
              headers.append("Content-Type", "application/x-www-form-urlencoded");
              unsubscribeOptions = {
                method: "POST",
                headers: headers,
                body: fcmUnsubscribeBody
              };
              _a.label = 1;

             case 1:
              _a.trys.push([ 1, 4, , 5 ]);
              return [ 4, fetch(ENDPOINT + "/fcm/connect/unsubscribe", unsubscribeOptions) ];

             case 2:
              response = _a.sent();
              return [ 4, response.json() ];

             case 3:
              responseData = _a.sent();
              if (responseData.error) {
                message = responseData.error.message;
                throw errorFactory.create(ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED, {
                  message: message
                });
              }
              return [ 3, 5 ];

             case 4:
              err_3 = _a.sent();
              throw errorFactory.create(ERROR_CODES.TOKEN_UNSUBSCRIBE_FAILED);

             case 5:
              return [ 2 ];
            }
          });
        });
      };
      return IidModel;
    }();
    function base64ToArrayBuffer(base64String) {
      var padding = "=".repeat((4 - base64String.length % 4) % 4);
      var base64 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
      var rawData = atob(base64);
      var outputArray = new Uint8Array(rawData.length);
      for (var i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
      return outputArray;
    }
    var OLD_DB_NAME = "undefined";
    var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
    function handleDb(db) {
      if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) return;
      var transaction = db.transaction(OLD_OBJECT_STORE_NAME);
      var objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);
      var iidModel = new IidModel();
      var openCursorRequest = objectStore.openCursor();
      openCursorRequest.onerror = function(event) {
        console.warn("Unable to cleanup old IDB.", event);
      };
      openCursorRequest.onsuccess = function() {
        var cursor = openCursorRequest.result;
        if (cursor) {
          var tokenDetails = cursor.value;
          iidModel.deleteToken(tokenDetails.fcmSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet);
          cursor.continue();
        } else {
          db.close();
          indexedDB.deleteDatabase(OLD_DB_NAME);
        }
      };
    }
    function cleanV1() {
      var request = indexedDB.open(OLD_DB_NAME);
      request.onerror = function(event) {};
      request.onsuccess = function(event) {
        var db = request.result;
        handleDb(db);
      };
    }
    var DbInterface = function() {
      function DbInterface() {
        this.dbPromise = null;
      }
      DbInterface.prototype.get = function(key) {
        return this.createTransaction(function(objectStore) {
          return objectStore.get(key);
        });
      };
      DbInterface.prototype.getIndex = function(index, key) {
        function runRequest(objectStore) {
          var idbIndex = objectStore.index(index);
          return idbIndex.get(key);
        }
        return this.createTransaction(runRequest);
      };
      DbInterface.prototype.put = function(value) {
        return this.createTransaction(function(objectStore) {
          return objectStore.put(value);
        }, "readwrite");
      };
      DbInterface.prototype.delete = function(key) {
        return this.createTransaction(function(objectStore) {
          return objectStore.delete(key);
        }, "readwrite");
      };
      DbInterface.prototype.closeDatabase = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var db;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (!this.dbPromise) return [ 3, 2 ];
              return [ 4, this.dbPromise ];

             case 1:
              db = _a.sent();
              db.close();
              this.dbPromise = null;
              _a.label = 2;

             case 2:
              return [ 2 ];
            }
          });
        });
      };
      DbInterface.prototype.createTransaction = function(runRequest, mode) {
        void 0 === mode && (mode = "readonly");
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var db, transaction, request, result;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.getDb() ];

             case 1:
              db = _a.sent();
              transaction = db.transaction(this.objectStoreName, mode);
              request = transaction.objectStore(this.objectStoreName);
              return [ 4, promisify(runRequest(request)) ];

             case 2:
              result = _a.sent();
              return [ 2, new Promise(function(resolve, reject) {
                transaction.oncomplete = function() {
                  resolve(result);
                };
                transaction.onerror = function() {
                  reject(transaction.error);
                };
              }) ];
            }
          });
        });
      };
      DbInterface.prototype.getDb = function() {
        var _this = this;
        this.dbPromise || (this.dbPromise = new Promise(function(resolve, reject) {
          var request = indexedDB.open(_this.dbName, _this.dbVersion);
          request.onsuccess = function() {
            resolve(request.result);
          };
          request.onerror = function() {
            _this.dbPromise = null;
            reject(request.error);
          };
          request.onupgradeneeded = function(event) {
            return _this.onDbUpgrade(request, event);
          };
        }));
        return this.dbPromise;
      };
      return DbInterface;
    }();
    function promisify(request) {
      return new Promise(function(resolve, reject) {
        request.onsuccess = function() {
          resolve(request.result);
        };
        request.onerror = function() {
          reject(request.error);
        };
      });
    }
    var TokenDetailsModel = function(_super) {
      tslib_1.__extends(TokenDetailsModel, _super);
      function TokenDetailsModel() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.dbName = "fcm_token_details_db";
        _this.dbVersion = 3;
        _this.objectStoreName = "fcm_token_object_Store";
        return _this;
      }
      TokenDetailsModel.prototype.onDbUpgrade = function(request, event) {
        var db = request.result;
        switch (event.oldVersion) {
         case 0:
          var objectStore = db.createObjectStore(this.objectStoreName, {
            keyPath: "swScope"
          });
          objectStore.createIndex("fcmSenderId", "fcmSenderId", {
            unique: false
          });
          objectStore.createIndex("fcmToken", "fcmToken", {
            unique: true
          });

         case 1:
          cleanV1();

         case 2:
          var objectStore = request.transaction.objectStore(this.objectStoreName);
          var cursorRequest_1 = objectStore.openCursor();
          cursorRequest_1.onsuccess = function() {
            var cursor = cursorRequest_1.result;
            if (cursor) {
              var value = cursor.value;
              var newValue = tslib_1.__assign({}, value);
              value.createTime || (newValue.createTime = Date.now());
              "string" === typeof value.vapidKey && (newValue.vapidKey = base64ToArrayBuffer(value.vapidKey));
              "string" === typeof value.auth && (newValue.auth = base64ToArrayBuffer(value.auth).buffer);
              "string" === typeof value.auth && (newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer);
              cursor.update(newValue);
              cursor.continue();
            }
          };
        }
      };
      TokenDetailsModel.prototype.getTokenDetailsFromToken = function(fcmToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            if (!fcmToken) throw errorFactory.create(ERROR_CODES.BAD_TOKEN);
            validateInputs({
              fcmToken: fcmToken
            });
            return [ 2, this.getIndex("fcmToken", fcmToken) ];
          });
        });
      };
      TokenDetailsModel.prototype.getTokenDetailsFromSWScope = function(swScope) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            if (!swScope) throw errorFactory.create(ERROR_CODES.BAD_SCOPE);
            validateInputs({
              swScope: swScope
            });
            return [ 2, this.get(swScope) ];
          });
        });
      };
      TokenDetailsModel.prototype.saveTokenDetails = function(tokenDetails) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            if (!tokenDetails.swScope) throw errorFactory.create(ERROR_CODES.BAD_SCOPE);
            if (!tokenDetails.vapidKey) throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);
            if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);
            if (!tokenDetails.fcmSenderId) throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);
            if (!tokenDetails.fcmToken) throw errorFactory.create(ERROR_CODES.BAD_TOKEN);
            if (!tokenDetails.fcmPushSet) throw errorFactory.create(ERROR_CODES.BAD_PUSH_SET);
            validateInputs(tokenDetails);
            return [ 2, this.put(tokenDetails) ];
          });
        });
      };
      TokenDetailsModel.prototype.deleteToken = function(token) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var details;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if ("string" !== typeof token || 0 === token.length) return [ 2, Promise.reject(errorFactory.create(ERROR_CODES.INVALID_DELETE_TOKEN)) ];
              return [ 4, this.getTokenDetailsFromToken(token) ];

             case 1:
              details = _a.sent();
              if (!details) throw errorFactory.create(ERROR_CODES.DELETE_TOKEN_NOT_FOUND);
              return [ 4, this.delete(details.swScope) ];

             case 2:
              _a.sent();
              return [ 2, details ];
            }
          });
        });
      };
      return TokenDetailsModel;
    }(DbInterface);
    function validateInputs(input) {
      if (input.fcmToken && ("string" !== typeof input.fcmToken || 0 === input.fcmToken.length)) throw errorFactory.create(ERROR_CODES.BAD_TOKEN);
      if (input.swScope && ("string" !== typeof input.swScope || 0 === input.swScope.length)) throw errorFactory.create(ERROR_CODES.BAD_SCOPE);
      if (input.vapidKey && (!(input.vapidKey instanceof Uint8Array) || 65 !== input.vapidKey.length)) throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);
      if (input.endpoint && ("string" !== typeof input.endpoint || 0 === input.endpoint.length)) throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);
      if (input.auth && !(input.auth instanceof ArrayBuffer)) throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);
      if (input.p256dh && !(input.p256dh instanceof ArrayBuffer)) throw errorFactory.create(ERROR_CODES.BAD_SUBSCRIPTION);
      if (input.fcmSenderId && ("string" !== typeof input.fcmSenderId || 0 === input.fcmSenderId.length)) throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);
      if (input.fcmPushSet && ("string" !== typeof input.fcmPushSet || 0 === input.fcmPushSet.length)) throw errorFactory.create(ERROR_CODES.BAD_PUSH_SET);
    }
    var UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;
    var VapidDetailsModel = function(_super) {
      tslib_1.__extends(VapidDetailsModel, _super);
      function VapidDetailsModel() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.dbName = "fcm_vapid_details_db";
        _this.dbVersion = 1;
        _this.objectStoreName = "fcm_vapid_object_Store";
        return _this;
      }
      VapidDetailsModel.prototype.onDbUpgrade = function(request) {
        var db = request.result;
        db.createObjectStore(this.objectStoreName, {
          keyPath: "swScope"
        });
      };
      VapidDetailsModel.prototype.getVapidFromSWScope = function(swScope) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var result;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if ("string" !== typeof swScope || 0 === swScope.length) throw errorFactory.create(ERROR_CODES.BAD_SCOPE);
              return [ 4, this.get(swScope) ];

             case 1:
              result = _a.sent();
              return [ 2, result ? result.vapidKey : void 0 ];
            }
          });
        });
      };
      VapidDetailsModel.prototype.saveVapidDetails = function(swScope, vapidKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var details;
          return tslib_1.__generator(this, function(_a) {
            if ("string" !== typeof swScope || 0 === swScope.length) throw errorFactory.create(ERROR_CODES.BAD_SCOPE);
            if (null === vapidKey || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) throw errorFactory.create(ERROR_CODES.BAD_VAPID_KEY);
            details = {
              swScope: swScope,
              vapidKey: vapidKey
            };
            return [ 2, this.put(details) ];
          });
        });
      };
      VapidDetailsModel.prototype.deleteVapidDetails = function(swScope) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var vapidKey;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.getVapidFromSWScope(swScope) ];

             case 1:
              vapidKey = _a.sent();
              if (!vapidKey) throw errorFactory.create(ERROR_CODES.DELETE_SCOPE_NOT_FOUND);
              return [ 4, this.delete(swScope) ];

             case 2:
              _a.sent();
              return [ 2, vapidKey ];
            }
          });
        });
      };
      return VapidDetailsModel;
    }(DbInterface);
    var SENDER_ID_OPTION_NAME = "messagingSenderId";
    var TOKEN_EXPIRATION_MILLIS = 6048e5;
    var BaseController = function() {
      function BaseController(app) {
        var _this = this;
        if (!app.options[SENDER_ID_OPTION_NAME] || "string" !== typeof app.options[SENDER_ID_OPTION_NAME]) throw errorFactory.create(ERROR_CODES.BAD_SENDER_ID);
        this.messagingSenderId = app.options[SENDER_ID_OPTION_NAME];
        this.tokenDetailsModel = new TokenDetailsModel();
        this.vapidDetailsModel = new VapidDetailsModel();
        this.iidModel = new IidModel();
        this.app = app;
        this.INTERNAL = {
          delete: function() {
            return _this.delete();
          }
        };
      }
      BaseController.prototype.getToken = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var currentPermission, swReg, publicVapidKey, pushSubscription, tokenDetails;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              currentPermission = this.getNotificationPermission_();
              if ("denied" === currentPermission) throw errorFactory.create(ERROR_CODES.NOTIFICATIONS_BLOCKED);
              if ("granted" !== currentPermission) return [ 2, null ];
              return [ 4, this.getSWRegistration_() ];

             case 1:
              swReg = _a.sent();
              return [ 4, this.getPublicVapidKey_() ];

             case 2:
              publicVapidKey = _a.sent();
              return [ 4, this.getPushSubscription(swReg, publicVapidKey) ];

             case 3:
              pushSubscription = _a.sent();
              return [ 4, this.tokenDetailsModel.getTokenDetailsFromSWScope(swReg.scope) ];

             case 4:
              tokenDetails = _a.sent();
              if (tokenDetails) return [ 2, this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails) ];
              return [ 2, this.getNewToken(swReg, pushSubscription, publicVapidKey) ];
            }
          });
        });
      };
      BaseController.prototype.manageExistingToken = function(swReg, pushSubscription, publicVapidKey, tokenDetails) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var isTokenValid, now;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              isTokenValid = isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);
              if (isTokenValid) {
                now = Date.now();
                return now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS ? [ 2, tokenDetails.fcmToken ] : [ 2, this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails) ];
              }
              return [ 4, this.deleteTokenFromDB(tokenDetails.fcmToken) ];

             case 1:
              _a.sent();
              return [ 2, this.getNewToken(swReg, pushSubscription, publicVapidKey) ];
            }
          });
        });
      };
      BaseController.prototype.updateToken = function(swReg, pushSubscription, publicVapidKey, tokenDetails) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var updatedToken, allDetails, e_1;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              _a.trys.push([ 0, 4, , 6 ]);
              return [ 4, this.iidModel.updateToken(this.messagingSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet, pushSubscription, publicVapidKey) ];

             case 1:
              updatedToken = _a.sent();
              allDetails = {
                swScope: swReg.scope,
                vapidKey: publicVapidKey,
                fcmSenderId: this.messagingSenderId,
                fcmToken: updatedToken,
                fcmPushSet: tokenDetails.fcmPushSet,
                createTime: Date.now(),
                endpoint: pushSubscription.endpoint,
                auth: pushSubscription.getKey("auth"),
                p256dh: pushSubscription.getKey("p256dh")
              };
              return [ 4, this.tokenDetailsModel.saveTokenDetails(allDetails) ];

             case 2:
              _a.sent();
              return [ 4, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey) ];

             case 3:
              _a.sent();
              return [ 2, updatedToken ];

             case 4:
              e_1 = _a.sent();
              return [ 4, this.deleteToken(tokenDetails.fcmToken) ];

             case 5:
              _a.sent();
              throw e_1;

             case 6:
              return [ 2 ];
            }
          });
        });
      };
      BaseController.prototype.getNewToken = function(swReg, pushSubscription, publicVapidKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var tokenDetails, allDetails;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.iidModel.getToken(this.messagingSenderId, pushSubscription, publicVapidKey) ];

             case 1:
              tokenDetails = _a.sent();
              allDetails = {
                swScope: swReg.scope,
                vapidKey: publicVapidKey,
                fcmSenderId: this.messagingSenderId,
                fcmToken: tokenDetails.token,
                fcmPushSet: tokenDetails.pushSet,
                createTime: Date.now(),
                endpoint: pushSubscription.endpoint,
                auth: pushSubscription.getKey("auth"),
                p256dh: pushSubscription.getKey("p256dh")
              };
              return [ 4, this.tokenDetailsModel.saveTokenDetails(allDetails) ];

             case 2:
              _a.sent();
              return [ 4, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey) ];

             case 3:
              _a.sent();
              return [ 2, tokenDetails.token ];
            }
          });
        });
      };
      BaseController.prototype.deleteToken = function(token) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var registration, pushSubscription;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.deleteTokenFromDB(token) ];

             case 1:
              _a.sent();
              return [ 4, this.getSWRegistration_() ];

             case 2:
              registration = _a.sent();
              if (!registration) return [ 3, 4 ];
              return [ 4, registration.pushManager.getSubscription() ];

             case 3:
              pushSubscription = _a.sent();
              if (pushSubscription) return [ 2, pushSubscription.unsubscribe() ];
              _a.label = 4;

             case 4:
              return [ 2, true ];
            }
          });
        });
      };
      BaseController.prototype.deleteTokenFromDB = function(token) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var details;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.tokenDetailsModel.deleteToken(token) ];

             case 1:
              details = _a.sent();
              return [ 4, this.iidModel.deleteToken(details.fcmSenderId, details.fcmToken, details.fcmPushSet) ];

             case 2:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      BaseController.prototype.getPushSubscription = function(swRegistration, publicVapidKey) {
        return swRegistration.pushManager.getSubscription().then(function(subscription) {
          if (subscription) return subscription;
          return swRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: publicVapidKey
          });
        });
      };
      BaseController.prototype.requestPermission = function() {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);
      };
      BaseController.prototype.useServiceWorker = function(registration) {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);
      };
      BaseController.prototype.usePublicVapidKey = function(b64PublicKey) {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);
      };
      BaseController.prototype.onMessage = function(nextOrObserver, error, completed) {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);
      };
      BaseController.prototype.onTokenRefresh = function(nextOrObserver, error, completed) {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_WINDOW);
      };
      BaseController.prototype.setBackgroundMessageHandler = function(callback) {
        throw errorFactory.create(ERROR_CODES.AVAILABLE_IN_SW);
      };
      BaseController.prototype.delete = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, Promise.all([ this.tokenDetailsModel.closeDatabase(), this.vapidDetailsModel.closeDatabase() ]) ];

             case 1:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      BaseController.prototype.getNotificationPermission_ = function() {
        return Notification.permission;
      };
      BaseController.prototype.getTokenDetailsModel = function() {
        return this.tokenDetailsModel;
      };
      BaseController.prototype.getVapidDetailsModel = function() {
        return this.vapidDetailsModel;
      };
      BaseController.prototype.getIidModel = function() {
        return this.iidModel;
      };
      return BaseController;
    }();
    function isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails) {
      if (!tokenDetails.vapidKey || !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)) return false;
      var isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;
      var isAuthEqual = isArrayBufferEqual(pushSubscription.getKey("auth"), tokenDetails.auth);
      var isP256dhEqual = isArrayBufferEqual(pushSubscription.getKey("p256dh"), tokenDetails.p256dh);
      return isEndpointEqual && isAuthEqual && isP256dhEqual;
    }
    var FCM_MSG = "FCM_MSG";
    var SwController = function(_super) {
      tslib_1.__extends(SwController, _super);
      function SwController(app) {
        var _this = _super.call(this, app) || this;
        _this.bgMessageHandler = null;
        self.addEventListener("push", function(e) {
          _this.onPush(e);
        });
        self.addEventListener("pushsubscriptionchange", function(e) {
          _this.onSubChange(e);
        });
        self.addEventListener("notificationclick", function(e) {
          _this.onNotificationClick(e);
        });
        return _this;
      }
      SwController.prototype.onPush = function(event) {
        event.waitUntil(this.onPush_(event));
      };
      SwController.prototype.onSubChange = function(event) {
        event.waitUntil(this.onSubChange_(event));
      };
      SwController.prototype.onNotificationClick = function(event) {
        event.waitUntil(this.onNotificationClick_(event));
      };
      SwController.prototype.onPush_ = function(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var msgPayload, hasVisibleClients, notificationDetails, notificationTitle, reg, actions, maxActions;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (!event.data) return [ 2 ];
              try {
                msgPayload = event.data.json();
              } catch (err) {
                return [ 2 ];
              }
              return [ 4, this.hasVisibleClients_() ];

             case 1:
              hasVisibleClients = _a.sent();
              if (hasVisibleClients) return [ 2, this.sendMessageToWindowClients_(msgPayload) ];
              notificationDetails = this.getNotificationData_(msgPayload);
              if (!notificationDetails) return [ 3, 3 ];
              notificationTitle = notificationDetails.title || "";
              return [ 4, this.getSWRegistration_() ];

             case 2:
              reg = _a.sent();
              actions = notificationDetails.actions;
              maxActions = Notification.maxActions;
              actions && maxActions && actions.length > maxActions && console.warn("This browser only supports " + maxActions + " actions.The remaining actions will not be displayed.");
              return [ 2, reg.showNotification(notificationTitle, notificationDetails) ];

             case 3:
              if (!this.bgMessageHandler) return [ 3, 5 ];
              return [ 4, this.bgMessageHandler(msgPayload) ];

             case 4:
              _a.sent();
              return [ 2 ];

             case 5:
              return [ 2 ];
            }
          });
        });
      };
      SwController.prototype.onSubChange_ = function(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var registration, err_1, err_2, tokenDetailsModel, tokenDetails;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              _a.trys.push([ 0, 2, , 3 ]);
              return [ 4, this.getSWRegistration_() ];

             case 1:
              registration = _a.sent();
              return [ 3, 3 ];

             case 2:
              err_1 = _a.sent();
              throw errorFactory.create(ERROR_CODES.UNABLE_TO_RESUBSCRIBE, {
                message: err_1
              });

             case 3:
              _a.trys.push([ 3, 5, , 8 ]);
              return [ 4, registration.pushManager.getSubscription() ];

             case 4:
              _a.sent();
              return [ 3, 8 ];

             case 5:
              err_2 = _a.sent();
              tokenDetailsModel = this.getTokenDetailsModel();
              return [ 4, tokenDetailsModel.getTokenDetailsFromSWScope(registration.scope) ];

             case 6:
              tokenDetails = _a.sent();
              if (!tokenDetails) throw err_2;
              return [ 4, this.deleteToken(tokenDetails.fcmToken) ];

             case 7:
              _a.sent();
              throw err_2;

             case 8:
              return [ 2 ];
            }
          });
        });
      };
      SwController.prototype.onNotificationClick_ = function(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var msgPayload, link, windowClient, internalMsg;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (!(event.notification && event.notification.data && event.notification.data[FCM_MSG])) return [ 2 ];
              if (event.action) return [ 2 ];
              event.stopImmediatePropagation();
              event.notification.close();
              msgPayload = event.notification.data[FCM_MSG];
              if (!msgPayload.notification) return [ 2 ];
              link = msgPayload.fcmOptions && msgPayload.fcmOptions.link || msgPayload.notification.click_action;
              if (!link) return [ 2 ];
              return [ 4, this.getWindowClient_(link) ];

             case 1:
              windowClient = _a.sent();
              if (!!windowClient) return [ 3, 3 ];
              return [ 4, self.clients.openWindow(link) ];

             case 2:
              windowClient = _a.sent();
              return [ 3, 5 ];

             case 3:
              return [ 4, windowClient.focus() ];

             case 4:
              windowClient = _a.sent();
              _a.label = 5;

             case 5:
              if (!windowClient) return [ 2 ];
              delete msgPayload.notification;
              delete msgPayload.fcmOptions;
              internalMsg = createNewMsg(MessageType.NOTIFICATION_CLICKED, msgPayload);
              return [ 2, this.attemptToMessageClient_(windowClient, internalMsg) ];
            }
          });
        });
      };
      SwController.prototype.getNotificationData_ = function(msgPayload) {
        if (!msgPayload) return;
        if ("object" !== typeof msgPayload.notification) return;
        var notificationInformation = tslib_1.__assign({}, msgPayload.notification);
        notificationInformation.data = tslib_1.__assign({}, msgPayload.notification.data, (_a = {}, 
        _a[FCM_MSG] = msgPayload, _a));
        return notificationInformation;
        var _a;
      };
      SwController.prototype.setBackgroundMessageHandler = function(callback) {
        if (!callback || "function" !== typeof callback) throw errorFactory.create(ERROR_CODES.BG_HANDLER_FUNCTION_EXPECTED);
        this.bgMessageHandler = callback;
      };
      SwController.prototype.getWindowClient_ = function(url) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var parsedURL, clientList, suitableClient, i, parsedClientUrl;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              parsedURL = new URL(url, self.location.href).href;
              return [ 4, getClientList() ];

             case 1:
              clientList = _a.sent();
              suitableClient = null;
              for (i = 0; i < clientList.length; i++) {
                parsedClientUrl = new URL(clientList[i].url, self.location.href).href;
                if (parsedClientUrl === parsedURL) {
                  suitableClient = clientList[i];
                  break;
                }
              }
              return [ 2, suitableClient ];
            }
          });
        });
      };
      SwController.prototype.attemptToMessageClient_ = function(client, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            if (!client) throw errorFactory.create(ERROR_CODES.NO_WINDOW_CLIENT_TO_MSG);
            client.postMessage(message);
            return [ 2 ];
          });
        });
      };
      SwController.prototype.hasVisibleClients_ = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var clientList;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, getClientList() ];

             case 1:
              clientList = _a.sent();
              return [ 2, clientList.some(function(client) {
                return "visible" === client.visibilityState;
              }) ];
            }
          });
        });
      };
      SwController.prototype.sendMessageToWindowClients_ = function(msgPayload) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          var clientList, internalMsg;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, getClientList() ];

             case 1:
              clientList = _a.sent();
              internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);
              return [ 4, Promise.all(clientList.map(function(client) {
                return _this.attemptToMessageClient_(client, internalMsg);
              })) ];

             case 2:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      SwController.prototype.getSWRegistration_ = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            return [ 2, self.registration ];
          });
        });
      };
      SwController.prototype.getPublicVapidKey_ = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var swReg, vapidKeyFromDatabase;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.getSWRegistration_() ];

             case 1:
              swReg = _a.sent();
              if (!swReg) throw errorFactory.create(ERROR_CODES.SW_REGISTRATION_EXPECTED);
              return [ 4, this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope) ];

             case 2:
              vapidKeyFromDatabase = _a.sent();
              if (null == vapidKeyFromDatabase) return [ 2, DEFAULT_PUBLIC_VAPID_KEY ];
              return [ 2, vapidKeyFromDatabase ];
            }
          });
        });
      };
      return SwController;
    }(BaseController);
    function getClientList() {
      return self.clients.matchAll({
        type: "window",
        includeUncontrolled: true
      });
    }
    function createNewMsg(msgType, msgData) {
      return _a = {}, _a[MessageParameter.TYPE_OF_MSG] = msgType, _a[MessageParameter.DATA] = msgData, 
      _a;
      var _a;
    }
    var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
    var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
    var WindowController = function(_super) {
      tslib_1.__extends(WindowController, _super);
      function WindowController(app) {
        var _this = _super.call(this, app) || this;
        _this.registrationToUse = null;
        _this.publicVapidKeyToUse = null;
        _this.manifestCheckPromise = null;
        _this.messageObserver = null;
        _this.tokenRefreshObserver = null;
        _this.onMessageInternal = util.createSubscribe(function(observer) {
          _this.messageObserver = observer;
        });
        _this.onTokenRefreshInternal = util.createSubscribe(function(observer) {
          _this.tokenRefreshObserver = observer;
        });
        _this.setupSWMessageListener_();
        return _this;
      }
      WindowController.prototype.getToken = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              this.manifestCheckPromise || (this.manifestCheckPromise = manifestCheck());
              return [ 4, this.manifestCheckPromise ];

             case 1:
              _a.sent();
              return [ 2, _super.prototype.getToken.call(this) ];
            }
          });
        });
      };
      WindowController.prototype.requestPermission = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var permissionResult;
          return tslib_1.__generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if ("granted" === this.getNotificationPermission_()) return [ 2 ];
              return [ 4, Notification.requestPermission() ];

             case 1:
              permissionResult = _a.sent();
              if ("granted" === permissionResult) return [ 2 ];
              throw "denied" === permissionResult ? errorFactory.create(ERROR_CODES.PERMISSION_BLOCKED) : errorFactory.create(ERROR_CODES.PERMISSION_DEFAULT);
            }
          });
        });
      };
      WindowController.prototype.useServiceWorker = function(registration) {
        if (!(registration instanceof ServiceWorkerRegistration)) throw errorFactory.create(ERROR_CODES.SW_REGISTRATION_EXPECTED);
        if (null != this.registrationToUse) throw errorFactory.create(ERROR_CODES.USE_SW_BEFORE_GET_TOKEN);
        this.registrationToUse = registration;
      };
      WindowController.prototype.usePublicVapidKey = function(publicKey) {
        if ("string" !== typeof publicKey) throw errorFactory.create(ERROR_CODES.INVALID_PUBLIC_VAPID_KEY);
        if (null != this.publicVapidKeyToUse) throw errorFactory.create(ERROR_CODES.USE_PUBLIC_KEY_BEFORE_GET_TOKEN);
        var parsedKey = base64ToArrayBuffer(publicKey);
        if (65 !== parsedKey.length) throw errorFactory.create(ERROR_CODES.PUBLIC_KEY_DECRYPTION_FAILED);
        this.publicVapidKeyToUse = parsedKey;
      };
      WindowController.prototype.onMessage = function(nextOrObserver, error, completed) {
        return "function" === typeof nextOrObserver ? this.onMessageInternal(nextOrObserver, error, completed) : this.onMessageInternal(nextOrObserver);
      };
      WindowController.prototype.onTokenRefresh = function(nextOrObserver, error, completed) {
        return "function" === typeof nextOrObserver ? this.onTokenRefreshInternal(nextOrObserver, error, completed) : this.onTokenRefreshInternal(nextOrObserver);
      };
      WindowController.prototype.waitForRegistrationToActivate_ = function(registration) {
        var serviceWorker = registration.installing || registration.waiting || registration.active;
        return new Promise(function(resolve, reject) {
          if (!serviceWorker) {
            reject(errorFactory.create(ERROR_CODES.NO_SW_IN_REG));
            return;
          }
          if ("activated" === serviceWorker.state) {
            resolve(registration);
            return;
          }
          if ("redundant" === serviceWorker.state) {
            reject(errorFactory.create(ERROR_CODES.SW_REG_REDUNDANT));
            return;
          }
          var stateChangeListener = function() {
            if ("activated" === serviceWorker.state) resolve(registration); else {
              if ("redundant" !== serviceWorker.state) return;
              reject(errorFactory.create(ERROR_CODES.SW_REG_REDUNDANT));
            }
            serviceWorker.removeEventListener("statechange", stateChangeListener);
          };
          serviceWorker.addEventListener("statechange", stateChangeListener);
        });
      };
      WindowController.prototype.getSWRegistration_ = function() {
        var _this = this;
        if (this.registrationToUse) return this.waitForRegistrationToActivate_(this.registrationToUse);
        this.registrationToUse = null;
        return navigator.serviceWorker.register(DEFAULT_SW_PATH, {
          scope: DEFAULT_SW_SCOPE
        }).catch(function(err) {
          throw errorFactory.create(ERROR_CODES.FAILED_DEFAULT_REGISTRATION, {
            browserErrorMessage: err.message
          });
        }).then(function(registration) {
          return _this.waitForRegistrationToActivate_(registration).then(function() {
            _this.registrationToUse = registration;
            registration.update();
            return registration;
          });
        });
      };
      WindowController.prototype.getPublicVapidKey_ = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          return tslib_1.__generator(this, function(_a) {
            if (this.publicVapidKeyToUse) return [ 2, this.publicVapidKeyToUse ];
            return [ 2, DEFAULT_PUBLIC_VAPID_KEY ];
          });
        });
      };
      WindowController.prototype.setupSWMessageListener_ = function() {
        var _this = this;
        navigator.serviceWorker.addEventListener("message", function(event) {
          if (!event.data || !event.data[MessageParameter.TYPE_OF_MSG]) return;
          var workerPageMessage = event.data;
          switch (workerPageMessage[MessageParameter.TYPE_OF_MSG]) {
           case MessageType.PUSH_MSG_RECEIVED:
           case MessageType.NOTIFICATION_CLICKED:
            var pushMessage = workerPageMessage[MessageParameter.DATA];
            _this.messageObserver && _this.messageObserver.next(pushMessage);
          }
        }, false);
      };
      return WindowController;
    }(BaseController);
    function manifestCheck() {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var manifestTag, manifestContent, response, e_1;
        return tslib_1.__generator(this, function(_a) {
          switch (_a.label) {
           case 0:
            manifestTag = document.querySelector('link[rel="manifest"]');
            if (!manifestTag) return [ 2 ];
            _a.label = 1;

           case 1:
            _a.trys.push([ 1, 4, , 5 ]);
            return [ 4, fetch(manifestTag.href) ];

           case 2:
            response = _a.sent();
            return [ 4, response.json() ];

           case 3:
            manifestContent = _a.sent();
            return [ 3, 5 ];

           case 4:
            e_1 = _a.sent();
            return [ 2 ];

           case 5:
            if (!manifestContent || !manifestContent.gcm_sender_id) return [ 2 ];
            if ("103953800507" !== manifestContent.gcm_sender_id) throw errorFactory.create(ERROR_CODES.INCORRECT_GCM_SENDER_ID);
            return [ 2 ];
          }
        });
      });
    }
    function registerMessaging(instance) {
      var messagingName = "messaging";
      var factoryMethod = function(app) {
        if (!isSupported()) throw errorFactory.create(ERROR_CODES.UNSUPPORTED_BROWSER);
        return self && "ServiceWorkerGlobalScope" in self ? new SwController(app) : new WindowController(app);
      };
      var namespaceExports = {
        isSupported: isSupported
      };
      instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);
    }
    registerMessaging(firebase);
    function isSupported() {
      return self && "ServiceWorkerGlobalScope" in self ? isSWControllerSupported() : isWindowControllerSupported();
    }
    function isWindowControllerSupported() {
      return navigator.cookieEnabled && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
    }
    function isSWControllerSupported() {
      return "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
    }
    exports.registerMessaging = registerMessaging;
    exports.isSupported = isSupported;
  }, {
    "@firebase/app": 7,
    "@firebase/util": 16,
    tslib: 61
  } ],
  14: [ function(require, module, exports) {
    (function(global) {
      "use strict";
      require("whatwg-fetch");
      var setTimeoutFunc = setTimeout;
      function noop() {}
      function bind(fn, thisArg) {
        return function() {
          fn.apply(thisArg, arguments);
        };
      }
      function Promise(fn) {
        if (!(this instanceof Promise)) throw new TypeError("Promises must be constructed via new");
        if ("function" !== typeof fn) throw new TypeError("not a function");
        this._state = 0;
        this._handled = false;
        this._value = void 0;
        this._deferreds = [];
        doResolve(fn, this);
      }
      function handle(self, deferred) {
        while (3 === self._state) self = self._value;
        if (0 === self._state) {
          self._deferreds.push(deferred);
          return;
        }
        self._handled = true;
        Promise._immediateFn(function() {
          var cb = 1 === self._state ? deferred.onFulfilled : deferred.onRejected;
          if (null === cb) {
            (1 === self._state ? resolve : reject)(deferred.promise, self._value);
            return;
          }
          var ret;
          try {
            ret = cb(self._value);
          } catch (e) {
            reject(deferred.promise, e);
            return;
          }
          resolve(deferred.promise, ret);
        });
      }
      function resolve(self, newValue) {
        try {
          if (newValue === self) throw new TypeError("A promise cannot be resolved with itself.");
          if (newValue && ("object" === typeof newValue || "function" === typeof newValue)) {
            var then = newValue.then;
            if (newValue instanceof Promise) {
              self._state = 3;
              self._value = newValue;
              finale(self);
              return;
            }
            if ("function" === typeof then) {
              doResolve(bind(then, newValue), self);
              return;
            }
          }
          self._state = 1;
          self._value = newValue;
          finale(self);
        } catch (e) {
          reject(self, e);
        }
      }
      function reject(self, newValue) {
        self._state = 2;
        self._value = newValue;
        finale(self);
      }
      function finale(self) {
        2 === self._state && 0 === self._deferreds.length && Promise._immediateFn(function() {
          self._handled || Promise._unhandledRejectionFn(self._value);
        });
        for (var i = 0, len = self._deferreds.length; i < len; i++) handle(self, self._deferreds[i]);
        self._deferreds = null;
      }
      function Handler(onFulfilled, onRejected, promise) {
        this.onFulfilled = "function" === typeof onFulfilled ? onFulfilled : null;
        this.onRejected = "function" === typeof onRejected ? onRejected : null;
        this.promise = promise;
      }
      function doResolve(fn, self) {
        var done = false;
        try {
          fn(function(value) {
            if (done) return;
            done = true;
            resolve(self, value);
          }, function(reason) {
            if (done) return;
            done = true;
            reject(self, reason);
          });
        } catch (ex) {
          if (done) return;
          done = true;
          reject(self, ex);
        }
      }
      Promise.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise.prototype.then = function(onFulfilled, onRejected) {
        var prom = new this.constructor(noop);
        handle(this, new Handler(onFulfilled, onRejected, prom));
        return prom;
      };
      Promise.prototype["finally"] = function(callback) {
        var constructor = this.constructor;
        return this.then(function(value) {
          return constructor.resolve(callback()).then(function() {
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function() {
            return constructor.reject(reason);
          });
        });
      };
      Promise.all = function(arr) {
        return new Promise(function(resolve, reject) {
          if (!arr || "undefined" === typeof arr.length) throw new TypeError("Promise.all accepts an array");
          var args = Array.prototype.slice.call(arr);
          if (0 === args.length) return resolve([]);
          var remaining = args.length;
          function res(i, val) {
            try {
              if (val && ("object" === typeof val || "function" === typeof val)) {
                var then = val.then;
                if ("function" === typeof then) {
                  then.call(val, function(val) {
                    res(i, val);
                  }, reject);
                  return;
                }
              }
              args[i] = val;
              0 === --remaining && resolve(args);
            } catch (ex) {
              reject(ex);
            }
          }
          for (var i = 0; i < args.length; i++) res(i, args[i]);
        });
      };
      Promise.resolve = function(value) {
        if (value && "object" === typeof value && value.constructor === Promise) return value;
        return new Promise(function(resolve) {
          resolve(value);
        });
      };
      Promise.reject = function(value) {
        return new Promise(function(resolve, reject) {
          reject(value);
        });
      };
      Promise.race = function(values) {
        return new Promise(function(resolve, reject) {
          for (var i = 0, len = values.length; i < len; i++) values[i].then(resolve, reject);
        });
      };
      Promise._immediateFn = "function" === typeof setImmediate && function(fn) {
        setImmediate(fn);
      } || function(fn) {
        setTimeoutFunc(fn, 0);
      };
      Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
        "undefined" !== typeof console && console && console.warn("Possible Unhandled Promise Rejection:", err);
      };
      var globalNS = function() {
        if ("undefined" !== typeof self) return self;
        if ("undefined" !== typeof window) return window;
        if ("undefined" !== typeof global) return global;
        throw new Error("unable to locate global object");
      }();
      globalNS.Promise || (globalNS.Promise = Promise);
      function createCommonjsModule(fn, module) {
        return module = {
          exports: {}
        }, fn(module, module.exports), module.exports;
      }
      var _global = createCommonjsModule(function(module) {
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global);
      });
      var _core = createCommonjsModule(function(module) {
        var core = module.exports = {
          version: "2.5.5"
        };
        "number" == typeof __e && (__e = core);
      });
      var _core_1 = _core.version;
      var _isObject = function(it) {
        return "object" === typeof it ? null !== it : "function" === typeof it;
      };
      var _anObject = function(it) {
        if (!_isObject(it)) throw TypeError(it + " is not an object!");
        return it;
      };
      var _fails = function(exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
      var _descriptors = !_fails(function() {
        return 7 != Object.defineProperty({}, "a", {
          get: function() {
            return 7;
          }
        }).a;
      });
      var document = _global.document;
      var is = _isObject(document) && _isObject(document.createElement);
      var _domCreate = function(it) {
        return is ? document.createElement(it) : {};
      };
      var _ie8DomDefine = !_descriptors && !_fails(function() {
        return 7 != Object.defineProperty(_domCreate("div"), "a", {
          get: function() {
            return 7;
          }
        }).a;
      });
      var _toPrimitive = function(it, S) {
        if (!_isObject(it)) return it;
        var fn, val;
        if (S && "function" == typeof (fn = it.toString) && !_isObject(val = fn.call(it))) return val;
        if ("function" == typeof (fn = it.valueOf) && !_isObject(val = fn.call(it))) return val;
        if (!S && "function" == typeof (fn = it.toString) && !_isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
      var dP = Object.defineProperty;
      var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        _anObject(O);
        P = _toPrimitive(P, true);
        _anObject(Attributes);
        if (_ie8DomDefine) try {
          return dP(O, P, Attributes);
        } catch (e) {}
        if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
        "value" in Attributes && (O[P] = Attributes.value);
        return O;
      };
      var _objectDp = {
        f: f
      };
      var _propertyDesc = function(bitmap, value) {
        return {
          enumerable: !(1 & bitmap),
          configurable: !(2 & bitmap),
          writable: !(4 & bitmap),
          value: value
        };
      };
      var _hide = _descriptors ? function(object, key, value) {
        return _objectDp.f(object, key, _propertyDesc(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
      var hasOwnProperty = {}.hasOwnProperty;
      var _has = function(it, key) {
        return hasOwnProperty.call(it, key);
      };
      var id = 0;
      var px = Math.random();
      var _uid = function(key) {
        return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
      };
      var _redefine = createCommonjsModule(function(module) {
        var SRC = _uid("src");
        var TO_STRING = "toString";
        var $toString = Function[TO_STRING];
        var TPL = ("" + $toString).split(TO_STRING);
        _core.inspectSource = function(it) {
          return $toString.call(it);
        };
        (module.exports = function(O, key, val, safe) {
          var isFunction = "function" == typeof val;
          isFunction && (_has(val, "name") || _hide(val, "name", key));
          if (O[key] === val) return;
          isFunction && (_has(val, SRC) || _hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key))));
          if (O === _global) O[key] = val; else if (safe) O[key] ? O[key] = val : _hide(O, key, val); else {
            delete O[key];
            _hide(O, key, val);
          }
        })(Function.prototype, TO_STRING, function toString() {
          return "function" == typeof this && this[SRC] || $toString.call(this);
        });
      });
      var _aFunction = function(it) {
        if ("function" != typeof it) throw TypeError(it + " is not a function!");
        return it;
      };
      var _ctx = function(fn, that, length) {
        _aFunction(fn);
        if (void 0 === that) return fn;
        switch (length) {
         case 1:
          return function(a) {
            return fn.call(that, a);
          };

         case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };

         case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
      var PROTOTYPE = "prototype";
      var $export = function(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
        var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
        var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
        var key, own, out, exp;
        IS_GLOBAL && (source = name);
        for (key in source) {
          own = !IS_FORCED && target && void 0 !== target[key];
          out = (own ? target : source)[key];
          exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && "function" == typeof out ? _ctx(Function.call, out) : out;
          target && _redefine(target, key, out, type & $export.U);
          exports[key] != out && _hide(exports, key, exp);
          IS_PROTO && expProto[key] != out && (expProto[key] = out);
        }
      };
      _global.core = _core;
      $export.F = 1;
      $export.G = 2;
      $export.S = 4;
      $export.P = 8;
      $export.B = 16;
      $export.W = 32;
      $export.U = 64;
      $export.R = 128;
      var _export = $export;
      var toString = {}.toString;
      var _cof = function(it) {
        return toString.call(it).slice(8, -1);
      };
      var _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
        return "String" == _cof(it) ? it.split("") : Object(it);
      };
      var _defined = function(it) {
        if (void 0 == it) throw TypeError("Can't call method on  " + it);
        return it;
      };
      var _toObject = function(it) {
        return Object(_defined(it));
      };
      var ceil = Math.ceil;
      var floor = Math.floor;
      var _toInteger = function(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
      var min = Math.min;
      var _toLength = function(it) {
        return it > 0 ? min(_toInteger(it), 9007199254740991) : 0;
      };
      var _isArray = Array.isArray || function isArray(arg) {
        return "Array" == _cof(arg);
      };
      var SHARED = "__core-js_shared__";
      var store = _global[SHARED] || (_global[SHARED] = {});
      var _shared = function(key) {
        return store[key] || (store[key] = {});
      };
      var _wks = createCommonjsModule(function(module) {
        var store = _shared("wks");
        var Symbol = _global.Symbol;
        var USE_SYMBOL = "function" == typeof Symbol;
        var $exports = module.exports = function(name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)("Symbol." + name));
        };
        $exports.store = store;
      });
      var SPECIES = _wks("species");
      var _arraySpeciesConstructor = function(original) {
        var C;
        if (_isArray(original)) {
          C = original.constructor;
          "function" != typeof C || C !== Array && !_isArray(C.prototype) || (C = void 0);
          if (_isObject(C)) {
            C = C[SPECIES];
            null === C && (C = void 0);
          }
        }
        return void 0 === C ? Array : C;
      };
      var _arraySpeciesCreate = function(original, length) {
        return new (_arraySpeciesConstructor(original))(length);
      };
      var _arrayMethods = function(TYPE, $create) {
        var IS_MAP = 1 == TYPE;
        var IS_FILTER = 2 == TYPE;
        var IS_SOME = 3 == TYPE;
        var IS_EVERY = 4 == TYPE;
        var IS_FIND_INDEX = 6 == TYPE;
        var NO_HOLES = 5 == TYPE || IS_FIND_INDEX;
        var create = $create || _arraySpeciesCreate;
        return function($this, callbackfn, that) {
          var O = _toObject($this);
          var self = _iobject(O);
          var f = _ctx(callbackfn, that, 3);
          var length = _toLength(self.length);
          var index = 0;
          var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
          var val, res;
          for (;length > index; index++) if (NO_HOLES || index in self) {
            val = self[index];
            res = f(val, index, O);
            if (TYPE) if (IS_MAP) result[index] = res; else if (res) switch (TYPE) {
             case 3:
              return true;

             case 5:
              return val;

             case 6:
              return index;

             case 2:
              result.push(val);
            } else if (IS_EVERY) return false;
          }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
      var UNSCOPABLES = _wks("unscopables");
      var ArrayProto = Array.prototype;
      void 0 == ArrayProto[UNSCOPABLES] && _hide(ArrayProto, UNSCOPABLES, {});
      var _addToUnscopables = function(key) {
        ArrayProto[UNSCOPABLES][key] = true;
      };
      var $find = _arrayMethods(5);
      var KEY = "find";
      var forced = true;
      KEY in [] && Array(1)[KEY](function() {
        forced = false;
      });
      _export(_export.P + _export.F * forced, "Array", {
        find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      _addToUnscopables(KEY);
      var find = _core.Array.find;
      var $find$1 = _arrayMethods(6);
      var KEY$1 = "findIndex";
      var forced$1 = true;
      KEY$1 in [] && Array(1)[KEY$1](function() {
        forced$1 = false;
      });
      _export(_export.P + _export.F * forced$1, "Array", {
        findIndex: function findIndex(callbackfn) {
          return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      _addToUnscopables(KEY$1);
      var findIndex = _core.Array.findIndex;
      var _toIobject = function(it) {
        return _iobject(_defined(it));
      };
      var max = Math.max;
      var min$1 = Math.min;
      var _toAbsoluteIndex = function(index, length) {
        index = _toInteger(index);
        return index < 0 ? max(index + length, 0) : min$1(index, length);
      };
      var _arrayIncludes = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = _toIobject($this);
          var length = _toLength(O.length);
          var index = _toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++];
            if (value != value) return true;
          } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
          return !IS_INCLUDES && -1;
        };
      };
      var shared = _shared("keys");
      var _sharedKey = function(key) {
        return shared[key] || (shared[key] = _uid(key));
      };
      var arrayIndexOf = _arrayIncludes(false);
      var IE_PROTO = _sharedKey("IE_PROTO");
      var _objectKeysInternal = function(object, names) {
        var O = _toIobject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O) key != IE_PROTO && _has(O, key) && result.push(key);
        while (names.length > i) _has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
        return result;
      };
      var _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      var _objectKeys = Object.keys || function keys(O) {
        return _objectKeysInternal(O, _enumBugKeys);
      };
      var f$1 = Object.getOwnPropertySymbols;
      var _objectGops = {
        f: f$1
      };
      var f$2 = {}.propertyIsEnumerable;
      var _objectPie = {
        f: f$2
      };
      var $assign = Object.assign;
      var _objectAssign = !$assign || _fails(function() {
        var A = {};
        var B = {};
        var S = Symbol();
        var K = "abcdefghijklmnopqrst";
        A[S] = 7;
        K.split("").forEach(function(k) {
          B[k] = k;
        });
        return 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K;
      }) ? function assign(target, source) {
        var T = _toObject(target);
        var aLen = arguments.length;
        var index = 1;
        var getSymbols = _objectGops.f;
        var isEnum = _objectPie.f;
        while (aLen > index) {
          var S = _iobject(arguments[index++]);
          var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) isEnum.call(S, key = keys[j++]) && (T[key] = S[key]);
        }
        return T;
      } : $assign;
      _export(_export.S + _export.F, "Object", {
        assign: _objectAssign
      });
      var assign = _core.Object.assign;
      var MATCH = _wks("match");
      var _isRegexp = function(it) {
        var isRegExp;
        return _isObject(it) && (void 0 !== (isRegExp = it[MATCH]) ? !!isRegExp : "RegExp" == _cof(it));
      };
      var _stringContext = function(that, searchString, NAME) {
        if (_isRegexp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
        return String(_defined(that));
      };
      var MATCH$1 = _wks("match");
      var _failsIsRegexp = function(KEY) {
        var re = /./;
        try {
          "/./"[KEY](re);
        } catch (e) {
          try {
            re[MATCH$1] = false;
            return !"/./"[KEY](re);
          } catch (f) {}
        }
        return true;
      };
      var STARTS_WITH = "startsWith";
      var $startsWith = ""[STARTS_WITH];
      _export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), "String", {
        startsWith: function startsWith(searchString) {
          var that = _stringContext(this, searchString, STARTS_WITH);
          var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = String(searchString);
          return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
        }
      });
      var startsWith = _core.String.startsWith;
      var _stringRepeat = function repeat(count) {
        var str = String(_defined(this));
        var res = "";
        var n = _toInteger(count);
        if (n < 0 || Infinity == n) throw RangeError("Count can't be negative");
        for (;n > 0; (n >>>= 1) && (str += str)) 1 & n && (res += str);
        return res;
      };
      _export(_export.P, "String", {
        repeat: _stringRepeat
      });
      var repeat = _core.String.repeat;
      var _meta = createCommonjsModule(function(module) {
        var META = _uid("meta");
        var setDesc = _objectDp.f;
        var id = 0;
        var isExtensible = Object.isExtensible || function() {
          return true;
        };
        var FREEZE = !_fails(function() {
          return isExtensible(Object.preventExtensions({}));
        });
        var setMeta = function(it) {
          setDesc(it, META, {
            value: {
              i: "O" + ++id,
              w: {}
            }
          });
        };
        var fastKey = function(it, create) {
          if (!_isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
          if (!_has(it, META)) {
            if (!isExtensible(it)) return "F";
            if (!create) return "E";
            setMeta(it);
          }
          return it[META].i;
        };
        var getWeak = function(it, create) {
          if (!_has(it, META)) {
            if (!isExtensible(it)) return true;
            if (!create) return false;
            setMeta(it);
          }
          return it[META].w;
        };
        var onFreeze = function(it) {
          FREEZE && meta.NEED && isExtensible(it) && !_has(it, META) && setMeta(it);
          return it;
        };
        var meta = module.exports = {
          KEY: META,
          NEED: false,
          fastKey: fastKey,
          getWeak: getWeak,
          onFreeze: onFreeze
        };
      });
      var _meta_1 = _meta.KEY;
      var _meta_2 = _meta.NEED;
      var _meta_3 = _meta.fastKey;
      var _meta_4 = _meta.getWeak;
      var _meta_5 = _meta.onFreeze;
      var def = _objectDp.f;
      var TAG = _wks("toStringTag");
      var _setToStringTag = function(it, tag, stat) {
        it && !_has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
          configurable: true,
          value: tag
        });
      };
      var f$3 = _wks;
      var _wksExt = {
        f: f$3
      };
      var _library = false;
      var defineProperty = _objectDp.f;
      var _wksDefine = function(name) {
        var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
        "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
          value: _wksExt.f(name)
        });
      };
      var _enumKeys = function(it) {
        var result = _objectKeys(it);
        var getSymbols = _objectGops.f;
        if (getSymbols) {
          var symbols = getSymbols(it);
          var isEnum = _objectPie.f;
          var i = 0;
          var key;
          while (symbols.length > i) isEnum.call(it, key = symbols[i++]) && result.push(key);
        }
        return result;
      };
      var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
        _anObject(O);
        var keys = _objectKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;
        while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
        return O;
      };
      var document$1 = _global.document;
      var _html = document$1 && document$1.documentElement;
      var IE_PROTO$1 = _sharedKey("IE_PROTO");
      var Empty = function() {};
      var PROTOTYPE$1 = "prototype";
      var createDict = function() {
        var iframe = _domCreate("iframe");
        var i = _enumBugKeys.length;
        var lt = "<";
        var gt = ">";
        var iframeDocument;
        iframe.style.display = "none";
        _html.appendChild(iframe);
        iframe.src = "javascript:";
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
        iframeDocument.close();
        createDict = iframeDocument.F;
        while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
        return createDict();
      };
      var _objectCreate = Object.create || function create(O, Properties) {
        var result;
        if (null !== O) {
          Empty[PROTOTYPE$1] = _anObject(O);
          result = new Empty();
          Empty[PROTOTYPE$1] = null;
          result[IE_PROTO$1] = O;
        } else result = createDict();
        return void 0 === Properties ? result : _objectDps(result, Properties);
      };
      var hiddenKeys = _enumBugKeys.concat("length", "prototype");
      var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return _objectKeysInternal(O, hiddenKeys);
      };
      var _objectGopn = {
        f: f$4
      };
      var gOPN = _objectGopn.f;
      var toString$1 = {}.toString;
      var windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return gOPN(it);
        } catch (e) {
          return windowNames.slice();
        }
      };
      var f$5 = function getOwnPropertyNames(it) {
        return windowNames && "[object Window]" == toString$1.call(it) ? getWindowNames(it) : gOPN(_toIobject(it));
      };
      var _objectGopnExt = {
        f: f$5
      };
      var gOPD = Object.getOwnPropertyDescriptor;
      var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = _toIobject(O);
        P = _toPrimitive(P, true);
        if (_ie8DomDefine) try {
          return gOPD(O, P);
        } catch (e) {}
        if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
      };
      var _objectGopd = {
        f: f$6
      };
      var META = _meta.KEY;
      var gOPD$1 = _objectGopd.f;
      var dP$1 = _objectDp.f;
      var gOPN$1 = _objectGopnExt.f;
      var $Symbol = _global.Symbol;
      var $JSON = _global.JSON;
      var _stringify = $JSON && $JSON.stringify;
      var PROTOTYPE$2 = "prototype";
      var HIDDEN = _wks("_hidden");
      var TO_PRIMITIVE = _wks("toPrimitive");
      var isEnum = {}.propertyIsEnumerable;
      var SymbolRegistry = _shared("symbol-registry");
      var AllSymbols = _shared("symbols");
      var OPSymbols = _shared("op-symbols");
      var ObjectProto = Object[PROTOTYPE$2];
      var USE_NATIVE = "function" == typeof $Symbol;
      var QObject = _global.QObject;
      var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;
      var setSymbolDesc = _descriptors && _fails(function() {
        return 7 != _objectCreate(dP$1({}, "a", {
          get: function() {
            return dP$1(this, "a", {
              value: 7
            }).a;
          }
        })).a;
      }) ? function(it, key, D) {
        var protoDesc = gOPD$1(ObjectProto, key);
        protoDesc && delete ObjectProto[key];
        dP$1(it, key, D);
        protoDesc && it !== ObjectProto && dP$1(ObjectProto, key, protoDesc);
      } : dP$1;
      var wrap = function(tag) {
        var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
        sym._k = tag;
        return sym;
      };
      var isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
        return "symbol" == typeof it;
      } : function(it) {
        return it instanceof $Symbol;
      };
      var $defineProperty = function defineProperty(it, key, D) {
        it === ObjectProto && $defineProperty(OPSymbols, key, D);
        _anObject(it);
        key = _toPrimitive(key, true);
        _anObject(D);
        if (_has(AllSymbols, key)) {
          if (D.enumerable) {
            _has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = false);
            D = _objectCreate(D, {
              enumerable: _propertyDesc(0, false)
            });
          } else {
            _has(it, HIDDEN) || dP$1(it, HIDDEN, _propertyDesc(1, {}));
            it[HIDDEN][key] = true;
          }
          return setSymbolDesc(it, key, D);
        }
        return dP$1(it, key, D);
      };
      var $defineProperties = function defineProperties(it, P) {
        _anObject(it);
        var keys = _enumKeys(P = _toIobject(P));
        var i = 0;
        var l = keys.length;
        var key;
        while (l > i) $defineProperty(it, key = keys[i++], P[key]);
        return it;
      };
      var $create = function create(it, P) {
        return void 0 === P ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(key) {
        var E = isEnum.call(this, key = _toPrimitive(key, true));
        if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
        return !(E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key]) || E;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
        it = _toIobject(it);
        key = _toPrimitive(key, true);
        if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
        var D = gOPD$1(it, key);
        !D || !_has(AllSymbols, key) || _has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = true);
        return D;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(it) {
        var names = gOPN$1(_toIobject(it));
        var result = [];
        var i = 0;
        var key;
        while (names.length > i) _has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
        return result;
      };
      var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
        var IS_OP = it === ObjectProto;
        var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
        var result = [];
        var i = 0;
        var key;
        while (names.length > i) !_has(AllSymbols, key = names[i++]) || IS_OP && !_has(ObjectProto, key) || result.push(AllSymbols[key]);
        return result;
      };
      if (!USE_NATIVE) {
        $Symbol = function Symbol() {
          if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
          var tag = _uid(arguments.length > 0 ? arguments[0] : void 0);
          var $set = function(value) {
            this === ObjectProto && $set.call(OPSymbols, value);
            _has(this, HIDDEN) && _has(this[HIDDEN], tag) && (this[HIDDEN][tag] = false);
            setSymbolDesc(this, tag, _propertyDesc(1, value));
          };
          _descriptors && setter && setSymbolDesc(ObjectProto, tag, {
            configurable: true,
            set: $set
          });
          return wrap(tag);
        };
        _redefine($Symbol[PROTOTYPE$2], "toString", function toString() {
          return this._k;
        });
        _objectGopd.f = $getOwnPropertyDescriptor;
        _objectDp.f = $defineProperty;
        _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
        _objectPie.f = $propertyIsEnumerable;
        _objectGops.f = $getOwnPropertySymbols;
        _descriptors && !_library && _redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
        _wksExt.f = function(name) {
          return wrap(_wks(name));
        };
      }
      _export(_export.G + _export.W + _export.F * !USE_NATIVE, {
        Symbol: $Symbol
      });
      for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; ) _wks(es6Symbols[j++]);
      for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k; ) _wksDefine(wellKnownSymbols[k++]);
      _export(_export.S + _export.F * !USE_NATIVE, "Symbol", {
        for: function(key) {
          return _has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
        },
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
          for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
        },
        useSetter: function() {
          setter = true;
        },
        useSimple: function() {
          setter = false;
        }
      });
      _export(_export.S + _export.F * !USE_NATIVE, "Object", {
        create: $create,
        defineProperty: $defineProperty,
        defineProperties: $defineProperties,
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        getOwnPropertyNames: $getOwnPropertyNames,
        getOwnPropertySymbols: $getOwnPropertySymbols
      });
      $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function() {
        var S = $Symbol();
        return "[null]" != _stringify([ S ]) || "{}" != _stringify({
          a: S
        }) || "{}" != _stringify(Object(S));
      })), "JSON", {
        stringify: function stringify(it) {
          var args = [ it ];
          var i = 1;
          var replacer, $replacer;
          while (arguments.length > i) args.push(arguments[i++]);
          $replacer = replacer = args[1];
          if (!_isObject(replacer) && void 0 === it || isSymbol(it)) return;
          _isArray(replacer) || (replacer = function(key, value) {
            "function" == typeof $replacer && (value = $replacer.call(this, key, value));
            if (!isSymbol(value)) return value;
          });
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        }
      });
      $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
      _setToStringTag($Symbol, "Symbol");
      _setToStringTag(Math, "Math", true);
      _setToStringTag(_global.JSON, "JSON", true);
      var TAG$1 = _wks("toStringTag");
      var ARG = "Arguments" == _cof(function() {
        return arguments;
      }());
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (e) {}
      };
      var _classof = function(it) {
        var O, T, B;
        return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG$1)) ? T : ARG ? _cof(O) : "Object" == (B = _cof(O)) && "function" == typeof O.callee ? "Arguments" : B;
      };
      var test = {};
      test[_wks("toStringTag")] = "z";
      test + "" != "[object z]" && _redefine(Object.prototype, "toString", function toString() {
        return "[object " + _classof(this) + "]";
      }, true);
      _wksDefine("asyncIterator");
      _wksDefine("observable");
      var symbol = _core.Symbol;
      var _stringAt = function(TO_STRING) {
        return function(that, pos) {
          var s = String(_defined(that));
          var i = _toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
          a = s.charCodeAt(i);
          return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : b - 56320 + (a - 55296 << 10) + 65536;
        };
      };
      var _iterators = {};
      var IteratorPrototype = {};
      _hide(IteratorPrototype, _wks("iterator"), function() {
        return this;
      });
      var _iterCreate = function(Constructor, NAME, next) {
        Constructor.prototype = _objectCreate(IteratorPrototype, {
          next: _propertyDesc(1, next)
        });
        _setToStringTag(Constructor, NAME + " Iterator");
      };
      var IE_PROTO$2 = _sharedKey("IE_PROTO");
      var ObjectProto$1 = Object.prototype;
      var _objectGpo = Object.getPrototypeOf || function(O) {
        O = _toObject(O);
        if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
        if ("function" == typeof O.constructor && O instanceof O.constructor) return O.constructor.prototype;
        return O instanceof Object ? ObjectProto$1 : null;
      };
      var ITERATOR = _wks("iterator");
      var BUGGY = !([].keys && "next" in [].keys());
      var FF_ITERATOR = "@@iterator";
      var KEYS = "keys";
      var VALUES = "values";
      var returnThis = function() {
        return this;
      };
      var _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        _iterCreate(Constructor, NAME, next);
        var getMethod = function(kind) {
          if (!BUGGY && kind in proto) return proto[kind];
          switch (kind) {
           case KEYS:
            return function keys() {
              return new Constructor(this, kind);
            };

           case VALUES:
            return function values() {
              return new Constructor(this, kind);
            };
          }
          return function entries() {
            return new Constructor(this, kind);
          };
        };
        var TAG = NAME + " Iterator";
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0;
        var $anyNative = "Array" == NAME && proto.entries || $native;
        var methods, key, IteratorPrototype;
        if ($anyNative) {
          IteratorPrototype = _objectGpo($anyNative.call(new Base()));
          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            _setToStringTag(IteratorPrototype, TAG, true);
            _library || "function" == typeof IteratorPrototype[ITERATOR] || _hide(IteratorPrototype, ITERATOR, returnThis);
          }
        }
        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;
          $default = function values() {
            return $native.call(this);
          };
        }
        _library && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || _hide(proto, ITERATOR, $default);
        _iterators[NAME] = $default;
        _iterators[TAG] = returnThis;
        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) key in proto || _redefine(proto, key, methods[key]); else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }
        return methods;
      };
      var $at = _stringAt(true);
      _iterDefine(String, "String", function(iterated) {
        this._t = String(iterated);
        this._i = 0;
      }, function() {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length) return {
          value: void 0,
          done: true
        };
        point = $at(O, index);
        this._i += point.length;
        return {
          value: point,
          done: false
        };
      });
      var _iterStep = function(done, value) {
        return {
          value: value,
          done: !!done
        };
      };
      var es6_array_iterator = _iterDefine(Array, "Array", function(iterated, kind) {
        this._t = _toIobject(iterated);
        this._i = 0;
        this._k = kind;
      }, function() {
        var O = this._t;
        var kind = this._k;
        var index = this._i++;
        if (!O || index >= O.length) {
          this._t = void 0;
          return _iterStep(1);
        }
        if ("keys" == kind) return _iterStep(0, index);
        if ("values" == kind) return _iterStep(0, O[index]);
        return _iterStep(0, [ index, O[index] ]);
      }, "values");
      _iterators.Arguments = _iterators.Array;
      _addToUnscopables("keys");
      _addToUnscopables("values");
      _addToUnscopables("entries");
      var ITERATOR$1 = _wks("iterator");
      var TO_STRING_TAG = _wks("toStringTag");
      var ArrayValues = _iterators.Array;
      var DOMIterables = {
        CSSRuleList: true,
        CSSStyleDeclaration: false,
        CSSValueList: false,
        ClientRectList: false,
        DOMRectList: false,
        DOMStringList: false,
        DOMTokenList: true,
        DataTransferItemList: false,
        FileList: false,
        HTMLAllCollection: false,
        HTMLCollection: false,
        HTMLFormElement: false,
        HTMLSelectElement: false,
        MediaList: true,
        MimeTypeArray: false,
        NamedNodeMap: false,
        NodeList: true,
        PaintRequestList: false,
        Plugin: false,
        PluginArray: false,
        SVGLengthList: false,
        SVGNumberList: false,
        SVGPathSegList: false,
        SVGPointList: false,
        SVGStringList: false,
        SVGTransformList: false,
        SourceBufferList: false,
        StyleSheetList: true,
        TextTrackCueList: false,
        TextTrackList: false,
        TouchList: false
      };
      for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
        var NAME = collections[i];
        var explicit = DOMIterables[NAME];
        var Collection = _global[NAME];
        var proto = Collection && Collection.prototype;
        var key;
        if (proto) {
          proto[ITERATOR$1] || _hide(proto, ITERATOR$1, ArrayValues);
          proto[TO_STRING_TAG] || _hide(proto, TO_STRING_TAG, NAME);
          _iterators[NAME] = ArrayValues;
          if (explicit) for (key in es6_array_iterator) proto[key] || _redefine(proto, key, es6_array_iterator[key], true);
        }
      }
      var iterator = _wksExt.f("iterator");
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "whatwg-fetch": 62
  } ],
  15: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _interopDefault(ex) {
      return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
    }
    var firebase = _interopDefault(require("@firebase/app"));
    var domainBase = "https://firebasestorage.googleapis.com";
    var downloadBase = "https://firebasestorage.googleapis.com";
    var apiBaseUrl = "/v0";
    var apiUploadBaseUrl = "/v0";
    var configOption = "storageBucket";
    var defaultMaxOperationRetryTime = 12e4;
    var defaultMaxUploadRetryTime = 6e4;
    var minSafeInteger = -9007199254740991;
    var FirebaseStorageError = function() {
      function FirebaseStorageError(code, message) {
        this.code_ = prependCode(code);
        this.message_ = "Firebase Storage: " + message;
        this.serverResponse_ = null;
        this.name_ = "FirebaseError";
      }
      FirebaseStorageError.prototype.codeProp = function() {
        return this.code;
      };
      FirebaseStorageError.prototype.codeEquals = function(code) {
        return prependCode(code) === this.codeProp();
      };
      FirebaseStorageError.prototype.serverResponseProp = function() {
        return this.serverResponse_;
      };
      FirebaseStorageError.prototype.setServerResponseProp = function(serverResponse) {
        this.serverResponse_ = serverResponse;
      };
      Object.defineProperty(FirebaseStorageError.prototype, "name", {
        get: function() {
          return this.name_;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FirebaseStorageError.prototype, "code", {
        get: function() {
          return this.code_;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FirebaseStorageError.prototype, "message", {
        get: function() {
          return this.message_;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FirebaseStorageError.prototype, "serverResponse", {
        get: function() {
          return this.serverResponse_;
        },
        enumerable: true,
        configurable: true
      });
      return FirebaseStorageError;
    }();
    var Code = {
      UNKNOWN: "unknown",
      OBJECT_NOT_FOUND: "object-not-found",
      BUCKET_NOT_FOUND: "bucket-not-found",
      PROJECT_NOT_FOUND: "project-not-found",
      QUOTA_EXCEEDED: "quota-exceeded",
      UNAUTHENTICATED: "unauthenticated",
      UNAUTHORIZED: "unauthorized",
      RETRY_LIMIT_EXCEEDED: "retry-limit-exceeded",
      INVALID_CHECKSUM: "invalid-checksum",
      CANCELED: "canceled",
      INVALID_EVENT_NAME: "invalid-event-name",
      INVALID_URL: "invalid-url",
      INVALID_DEFAULT_BUCKET: "invalid-default-bucket",
      NO_DEFAULT_BUCKET: "no-default-bucket",
      CANNOT_SLICE_BLOB: "cannot-slice-blob",
      SERVER_FILE_WRONG_SIZE: "server-file-wrong-size",
      NO_DOWNLOAD_URL: "no-download-url",
      INVALID_ARGUMENT: "invalid-argument",
      INVALID_ARGUMENT_COUNT: "invalid-argument-count",
      APP_DELETED: "app-deleted",
      INVALID_ROOT_OPERATION: "invalid-root-operation",
      INVALID_FORMAT: "invalid-format",
      INTERNAL_ERROR: "internal-error"
    };
    function prependCode(code) {
      return "storage/" + code;
    }
    function unknown() {
      var message = "An unknown error occurred, please check the error payload for server response.";
      return new FirebaseStorageError(Code.UNKNOWN, message);
    }
    function objectNotFound(path) {
      return new FirebaseStorageError(Code.OBJECT_NOT_FOUND, "Object '" + path + "' does not exist.");
    }
    function quotaExceeded(bucket) {
      return new FirebaseStorageError(Code.QUOTA_EXCEEDED, "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
    }
    function unauthenticated() {
      var message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
      return new FirebaseStorageError(Code.UNAUTHENTICATED, message);
    }
    function unauthorized(path) {
      return new FirebaseStorageError(Code.UNAUTHORIZED, "User does not have permission to access '" + path + "'.");
    }
    function retryLimitExceeded() {
      return new FirebaseStorageError(Code.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.");
    }
    function canceled() {
      return new FirebaseStorageError(Code.CANCELED, "User canceled the upload/download.");
    }
    function invalidUrl(url) {
      return new FirebaseStorageError(Code.INVALID_URL, "Invalid URL '" + url + "'.");
    }
    function invalidDefaultBucket(bucket) {
      return new FirebaseStorageError(Code.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + bucket + "'.");
    }
    function cannotSliceBlob() {
      return new FirebaseStorageError(Code.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.");
    }
    function serverFileWrongSize() {
      return new FirebaseStorageError(Code.SERVER_FILE_WRONG_SIZE, "Server recorded incorrect upload file size, please retry the upload.");
    }
    function noDownloadURL() {
      return new FirebaseStorageError(Code.NO_DOWNLOAD_URL, "The given file does not have any download URLs.");
    }
    function invalidArgument(index, fnName, message) {
      return new FirebaseStorageError(Code.INVALID_ARGUMENT, "Invalid argument in `" + fnName + "` at index " + index + ": " + message);
    }
    function invalidArgumentCount(argMin, argMax, fnName, real) {
      var countPart;
      var plural;
      if (argMin === argMax) {
        countPart = argMin;
        plural = 1 === argMin ? "argument" : "arguments";
      } else {
        countPart = "between " + argMin + " and " + argMax;
        plural = "arguments";
      }
      return new FirebaseStorageError(Code.INVALID_ARGUMENT_COUNT, "Invalid argument count in `" + fnName + "`: Expected " + countPart + " " + plural + ", received " + real + ".");
    }
    function appDeleted() {
      return new FirebaseStorageError(Code.APP_DELETED, "The Firebase app was deleted.");
    }
    function invalidRootOperation(name) {
      return new FirebaseStorageError(Code.INVALID_ROOT_OPERATION, "The operation '" + name + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
    }
    function invalidFormat(format, message) {
      return new FirebaseStorageError(Code.INVALID_FORMAT, "String does not match format '" + format + "': " + message);
    }
    function internalError(message) {
      throw new FirebaseStorageError(Code.INTERNAL_ERROR, "Internal error: " + message);
    }
    var StringFormat = {
      RAW: "raw",
      BASE64: "base64",
      BASE64URL: "base64url",
      DATA_URL: "data_url"
    };
    function formatValidator(stringFormat) {
      switch (stringFormat) {
       case StringFormat.RAW:
       case StringFormat.BASE64:
       case StringFormat.BASE64URL:
       case StringFormat.DATA_URL:
        return;

       default:
        throw "Expected one of the event types: [" + StringFormat.RAW + ", " + StringFormat.BASE64 + ", " + StringFormat.BASE64URL + ", " + StringFormat.DATA_URL + "].";
      }
    }
    var StringData = function() {
      function StringData(data, opt_contentType) {
        this.data = data;
        this.contentType = opt_contentType || null;
      }
      return StringData;
    }();
    function dataFromString(format, string) {
      switch (format) {
       case StringFormat.RAW:
        return new StringData(utf8Bytes_(string));

       case StringFormat.BASE64:
       case StringFormat.BASE64URL:
        return new StringData(base64Bytes_(format, string));

       case StringFormat.DATA_URL:
        return new StringData(dataURLBytes_(string), dataURLContentType_(string));
      }
      throw unknown();
    }
    function utf8Bytes_(string) {
      var b = [];
      for (var i = 0; i < string.length; i++) {
        var c = string.charCodeAt(i);
        if (c <= 127) b.push(c); else if (c <= 2047) b.push(192 | c >> 6, 128 | 63 & c); else if (55296 == (64512 & c)) {
          var valid = i < string.length - 1 && 56320 == (64512 & string.charCodeAt(i + 1));
          if (valid) {
            var hi = c;
            var lo = string.charCodeAt(++i);
            c = 65536 | (1023 & hi) << 10 | 1023 & lo;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | 63 & c);
          } else b.push(239, 191, 189);
        } else 56320 == (64512 & c) ? b.push(239, 191, 189) : b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | 63 & c);
      }
      return new Uint8Array(b);
    }
    function percentEncodedBytes_(string) {
      var decoded;
      try {
        decoded = decodeURIComponent(string);
      } catch (e) {
        throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
      }
      return utf8Bytes_(decoded);
    }
    function base64Bytes_(format, string) {
      switch (format) {
       case StringFormat.BASE64:
        var hasMinus = -1 !== string.indexOf("-");
        var hasUnder = -1 !== string.indexOf("_");
        if (hasMinus || hasUnder) {
          var invalidChar = hasMinus ? "-" : "_";
          throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
        }
        break;

       case StringFormat.BASE64URL:
        var hasPlus = -1 !== string.indexOf("+");
        var hasSlash = -1 !== string.indexOf("/");
        if (hasPlus || hasSlash) {
          var invalidChar = hasPlus ? "+" : "/";
          throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
        }
        string = string.replace(/-/g, "+").replace(/_/g, "/");
      }
      var bytes;
      try {
        bytes = atob(string);
      } catch (e) {
        throw invalidFormat(format, "Invalid character found");
      }
      var array = new Uint8Array(bytes.length);
      for (var i = 0; i < bytes.length; i++) array[i] = bytes.charCodeAt(i);
      return array;
    }
    var DataURLParts = function() {
      function DataURLParts(dataURL) {
        this.base64 = false;
        this.contentType = null;
        var matches = dataURL.match(/^data:([^,]+)?,/);
        if (null === matches) throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
        var middle = matches[1] || null;
        if (null != middle) {
          this.base64 = endsWith(middle, ";base64");
          this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
        }
        this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
      }
      return DataURLParts;
    }();
    function dataURLBytes_(string) {
      var parts = new DataURLParts(string);
      return parts.base64 ? base64Bytes_(StringFormat.BASE64, parts.rest) : percentEncodedBytes_(parts.rest);
    }
    function dataURLContentType_(string) {
      var parts = new DataURLParts(string);
      return parts.contentType;
    }
    function endsWith(s, end) {
      var longEnough = s.length >= end.length;
      if (!longEnough) return false;
      return s.substring(s.length - end.length) === end;
    }
    var TaskEvent = {
      STATE_CHANGED: "state_changed"
    };
    var InternalTaskState = {
      RUNNING: "running",
      PAUSING: "pausing",
      PAUSED: "paused",
      SUCCESS: "success",
      CANCELING: "canceling",
      CANCELED: "canceled",
      ERROR: "error"
    };
    var TaskState = {
      RUNNING: "running",
      PAUSED: "paused",
      SUCCESS: "success",
      CANCELED: "canceled",
      ERROR: "error"
    };
    function taskStateFromInternalTaskState(state) {
      switch (state) {
       case InternalTaskState.RUNNING:
       case InternalTaskState.PAUSING:
       case InternalTaskState.CANCELING:
        return TaskState.RUNNING;

       case InternalTaskState.PAUSED:
        return TaskState.PAUSED;

       case InternalTaskState.SUCCESS:
        return TaskState.SUCCESS;

       case InternalTaskState.CANCELED:
        return TaskState.CANCELED;

       case InternalTaskState.ERROR:
       default:
        return TaskState.ERROR;
      }
    }
    function contains(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function forEach(obj, f) {
      for (var key in obj) contains(obj, key) && f(key, obj[key]);
    }
    function clone(obj) {
      if (null == obj) return {};
      var c = {};
      forEach(obj, function(key, val) {
        c[key] = val;
      });
      return c;
    }
    function make(resolver) {
      return new Promise(resolver);
    }
    function resolve(value) {
      return Promise.resolve(value);
    }
    function reject(error) {
      return Promise.reject(error);
    }
    function isDef(p) {
      return null != p;
    }
    function isJustDef(p) {
      return void 0 !== p;
    }
    function isFunction(p) {
      return "function" === typeof p;
    }
    function isObject(p) {
      return "object" === typeof p;
    }
    function isNonNullObject(p) {
      return isObject(p) && null !== p;
    }
    function isNonArrayObject(p) {
      return isObject(p) && !Array.isArray(p);
    }
    function isString(p) {
      return "string" === typeof p || p instanceof String;
    }
    function isNumber(p) {
      return "number" === typeof p || p instanceof Number;
    }
    function isNativeBlob(p) {
      return isNativeBlobDefined() && p instanceof Blob;
    }
    function isNativeBlobDefined() {
      return "undefined" !== typeof Blob;
    }
    var ErrorCode;
    (function(ErrorCode) {
      ErrorCode[ErrorCode["NO_ERROR"] = 0] = "NO_ERROR";
      ErrorCode[ErrorCode["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
      ErrorCode[ErrorCode["ABORT"] = 2] = "ABORT";
    })(ErrorCode || (ErrorCode = {}));
    var NetworkXhrIo = function() {
      function NetworkXhrIo() {
        var _this = this;
        this.sent_ = false;
        this.xhr_ = new XMLHttpRequest();
        this.errorCode_ = ErrorCode.NO_ERROR;
        this.sendPromise_ = make(function(resolve$$1, reject$$1) {
          _this.xhr_.addEventListener("abort", function(event) {
            _this.errorCode_ = ErrorCode.ABORT;
            resolve$$1(_this);
          });
          _this.xhr_.addEventListener("error", function(event) {
            _this.errorCode_ = ErrorCode.NETWORK_ERROR;
            resolve$$1(_this);
          });
          _this.xhr_.addEventListener("load", function(event) {
            resolve$$1(_this);
          });
        });
      }
      NetworkXhrIo.prototype.send = function(url, method, opt_body, opt_headers) {
        var _this = this;
        if (this.sent_) throw internalError("cannot .send() more than once");
        this.sent_ = true;
        this.xhr_.open(method, url, true);
        if (isDef(opt_headers)) {
          var headers = opt_headers;
          forEach(headers, function(key, val) {
            _this.xhr_.setRequestHeader(key, val.toString());
          });
        }
        isDef(opt_body) ? this.xhr_.send(opt_body) : this.xhr_.send();
        return this.sendPromise_;
      };
      NetworkXhrIo.prototype.getErrorCode = function() {
        if (!this.sent_) throw internalError("cannot .getErrorCode() before sending");
        return this.errorCode_;
      };
      NetworkXhrIo.prototype.getStatus = function() {
        if (!this.sent_) throw internalError("cannot .getStatus() before sending");
        try {
          return this.xhr_.status;
        } catch (e) {
          return -1;
        }
      };
      NetworkXhrIo.prototype.getResponseText = function() {
        if (!this.sent_) throw internalError("cannot .getResponseText() before sending");
        return this.xhr_.responseText;
      };
      NetworkXhrIo.prototype.abort = function() {
        this.xhr_.abort();
      };
      NetworkXhrIo.prototype.getResponseHeader = function(header) {
        return this.xhr_.getResponseHeader(header);
      };
      NetworkXhrIo.prototype.addUploadProgressListener = function(listener) {
        isDef(this.xhr_.upload) && this.xhr_.upload.addEventListener("progress", listener);
      };
      NetworkXhrIo.prototype.removeUploadProgressListener = function(listener) {
        isDef(this.xhr_.upload) && this.xhr_.upload.removeEventListener("progress", listener);
      };
      return NetworkXhrIo;
    }();
    var XhrIoPool = function() {
      function XhrIoPool() {}
      XhrIoPool.prototype.createXhrIo = function() {
        return new NetworkXhrIo();
      };
      return XhrIoPool;
    }();
    function jsonObjectOrNull(s) {
      var obj;
      try {
        obj = JSON.parse(s);
      } catch (e) {
        return null;
      }
      return isNonArrayObject(obj) ? obj : null;
    }
    var Location = function() {
      function Location(bucket, path) {
        this.bucket = bucket;
        this.path_ = path;
      }
      Object.defineProperty(Location.prototype, "path", {
        get: function() {
          return this.path_;
        },
        enumerable: true,
        configurable: true
      });
      Location.prototype.fullServerUrl = function() {
        var encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o/" + encode(this.path);
      };
      Location.prototype.bucketOnlyServerUrl = function() {
        var encode = encodeURIComponent;
        return "/b/" + encode(this.bucket) + "/o";
      };
      Location.makeFromBucketSpec = function(bucketString) {
        var bucketLocation;
        try {
          bucketLocation = Location.makeFromUrl(bucketString);
        } catch (e) {
          return new Location(bucketString, "");
        }
        if ("" === bucketLocation.path) return bucketLocation;
        throw invalidDefaultBucket(bucketString);
      };
      Location.makeFromUrl = function(url) {
        var location = null;
        var bucketDomain = "([A-Za-z0-9.\\-]+)";
        function gsModify(loc) {
          "/" === loc.path.charAt(loc.path.length - 1) && (loc.path_ = loc.path_.slice(0, -1));
        }
        var gsPath = "(/(.*))?$";
        var path = "(/([^?#]*).*)?$";
        var gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
        var gsIndices = {
          bucket: 1,
          path: 3
        };
        function httpModify(loc) {
          loc.path_ = decodeURIComponent(loc.path);
        }
        var version = "v[A-Za-z0-9_]+";
        var httpRegex = new RegExp("^https?://firebasestorage\\.googleapis\\.com/" + version + "/b/" + bucketDomain + "/o" + path, "i");
        var httpIndices = {
          bucket: 1,
          path: 3
        };
        var groups = [ {
          regex: gsRegex,
          indices: gsIndices,
          postModify: gsModify
        }, {
          regex: httpRegex,
          indices: httpIndices,
          postModify: httpModify
        } ];
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          var captures = group.regex.exec(url);
          if (captures) {
            var bucketValue = captures[group.indices.bucket];
            var pathValue = captures[group.indices.path];
            pathValue || (pathValue = "");
            location = new Location(bucketValue, pathValue);
            group.postModify(location);
            break;
          }
        }
        if (null == location) throw invalidUrl(url);
        return location;
      };
      return Location;
    }();
    function parent(path) {
      if (0 == path.length) return null;
      var index = path.lastIndexOf("/");
      if (-1 === index) return "";
      var newPath = path.slice(0, index);
      return newPath;
    }
    function child(path, childPath) {
      var canonicalChildPath = childPath.split("/").filter(function(component) {
        return component.length > 0;
      }).join("/");
      return 0 === path.length ? canonicalChildPath : path + "/" + canonicalChildPath;
    }
    function lastComponent(path) {
      var index = path.lastIndexOf("/", path.length - 2);
      return -1 === index ? path : path.slice(index + 1);
    }
    function makeNormalUrl(urlPart) {
      return domainBase + apiBaseUrl + urlPart;
    }
    function makeDownloadUrl(urlPart) {
      return downloadBase + apiBaseUrl + urlPart;
    }
    function makeUploadUrl(urlPart) {
      return domainBase + apiUploadBaseUrl + urlPart;
    }
    function makeQueryString(params) {
      var encode = encodeURIComponent;
      var queryPart = "?";
      forEach(params, function(key, val) {
        var nextPart = encode(key) + "=" + encode(val);
        queryPart = queryPart + nextPart + "&";
      });
      queryPart = queryPart.slice(0, -1);
      return queryPart;
    }
    function noXform_(metadata, value) {
      return value;
    }
    var Mapping = function() {
      function Mapping(server, opt_local, opt_writable, opt_xform) {
        this.server = server;
        this.local = opt_local || server;
        this.writable = !!opt_writable;
        this.xform = opt_xform || noXform_;
      }
      return Mapping;
    }();
    var mappings_ = null;
    function xformPath(fullPath) {
      var valid = isString(fullPath);
      if (!valid || fullPath.length < 2) return fullPath;
      fullPath = fullPath;
      return lastComponent(fullPath);
    }
    function getMappings() {
      if (mappings_) return mappings_;
      var mappings = [];
      mappings.push(new Mapping("bucket"));
      mappings.push(new Mapping("generation"));
      mappings.push(new Mapping("metageneration"));
      mappings.push(new Mapping("name", "fullPath", true));
      function mappingsXformPath(metadata, fullPath) {
        return xformPath(fullPath);
      }
      var nameMapping = new Mapping("name");
      nameMapping.xform = mappingsXformPath;
      mappings.push(nameMapping);
      function xformSize(metadata, size) {
        return isDef(size) ? +size : size;
      }
      var sizeMapping = new Mapping("size");
      sizeMapping.xform = xformSize;
      mappings.push(sizeMapping);
      mappings.push(new Mapping("timeCreated"));
      mappings.push(new Mapping("updated"));
      mappings.push(new Mapping("md5Hash", null, true));
      mappings.push(new Mapping("cacheControl", null, true));
      mappings.push(new Mapping("contentDisposition", null, true));
      mappings.push(new Mapping("contentEncoding", null, true));
      mappings.push(new Mapping("contentLanguage", null, true));
      mappings.push(new Mapping("contentType", null, true));
      mappings.push(new Mapping("metadata", "customMetadata", true));
      mappings_ = mappings;
      return mappings_;
    }
    function addRef(metadata, authWrapper) {
      function generateRef() {
        var bucket = metadata["bucket"];
        var path = metadata["fullPath"];
        var loc = new Location(bucket, path);
        return authWrapper.makeStorageReference(loc);
      }
      Object.defineProperty(metadata, "ref", {
        get: generateRef
      });
    }
    function fromResource(authWrapper, resource, mappings) {
      var metadata = {};
      metadata["type"] = "file";
      var len = mappings.length;
      for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
      }
      addRef(metadata, authWrapper);
      return metadata;
    }
    function fromResourceString(authWrapper, resourceString, mappings) {
      var obj = jsonObjectOrNull(resourceString);
      if (null === obj) return null;
      var resource = obj;
      return fromResource(authWrapper, resource, mappings);
    }
    function downloadUrlFromResourceString(metadata, resourceString) {
      var obj = jsonObjectOrNull(resourceString);
      if (null === obj) return null;
      if (!isString(obj["downloadTokens"])) return null;
      var tokens = obj["downloadTokens"];
      if (0 === tokens.length) return null;
      var encode = encodeURIComponent;
      var tokensList = tokens.split(",");
      var urls = tokensList.map(function(token) {
        var bucket = metadata["bucket"];
        var path = metadata["fullPath"];
        var urlPart = "/b/" + encode(bucket) + "/o/" + encode(path);
        var base = makeDownloadUrl(urlPart);
        var queryString = makeQueryString({
          alt: "media",
          token: token
        });
        return base + queryString;
      });
      return urls[0];
    }
    function toResourceString(metadata, mappings) {
      var resource = {};
      var len = mappings.length;
      for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        mapping.writable && (resource[mapping.server] = metadata[mapping.local]);
      }
      return JSON.stringify(resource);
    }
    function metadataValidator(p) {
      var validType = p && isObject(p);
      if (!validType) throw "Expected Metadata object.";
      for (var key in p) {
        var val = p[key];
        if ("customMetadata" === key) {
          if (!isObject(val)) throw "Expected object for 'customMetadata' mapping.";
        } else if (isNonNullObject(val)) throw "Mapping for '" + key + "' cannot be an object.";
      }
    }
    function validate(name, specs, passed) {
      var minArgs = specs.length;
      var maxArgs = specs.length;
      for (var i = 0; i < specs.length; i++) if (specs[i].optional) {
        minArgs = i;
        break;
      }
      var validLength = minArgs <= passed.length && passed.length <= maxArgs;
      if (!validLength) throw invalidArgumentCount(minArgs, maxArgs, name, passed.length);
      for (var i = 0; i < passed.length; i++) try {
        specs[i].validator(passed[i]);
      } catch (e) {
        throw e instanceof Error ? invalidArgument(i, name, e.message) : invalidArgument(i, name, e);
      }
    }
    var ArgSpec = function() {
      function ArgSpec(validator, opt_optional) {
        var self = this;
        this.validator = function(p) {
          if (self.optional && !isJustDef(p)) return;
          validator(p);
        };
        this.optional = !!opt_optional;
      }
      return ArgSpec;
    }();
    function and_(v1, v2) {
      return function(p) {
        v1(p);
        v2(p);
      };
    }
    function stringSpec(opt_validator, opt_optional) {
      function stringValidator(p) {
        if (!isString(p)) throw "Expected string.";
      }
      var validator;
      validator = opt_validator ? and_(stringValidator, opt_validator) : stringValidator;
      return new ArgSpec(validator, opt_optional);
    }
    function uploadDataSpec() {
      function validator(p) {
        var valid = p instanceof Uint8Array || p instanceof ArrayBuffer || isNativeBlobDefined() && p instanceof Blob;
        if (!valid) throw "Expected Blob or File.";
      }
      return new ArgSpec(validator);
    }
    function metadataSpec(opt_optional) {
      return new ArgSpec(metadataValidator, opt_optional);
    }
    function nonNegativeNumberSpec() {
      function validator(p) {
        var valid = isNumber(p) && p >= 0;
        if (!valid) throw "Expected a number 0 or greater.";
      }
      return new ArgSpec(validator);
    }
    function looseObjectSpec(opt_validator, opt_optional) {
      function validator(p) {
        var isLooseObject = null === p || isDef(p) && p instanceof Object;
        if (!isLooseObject) throw "Expected an Object.";
        void 0 !== opt_validator && null !== opt_validator && opt_validator(p);
      }
      return new ArgSpec(validator, opt_optional);
    }
    function nullFunctionSpec(opt_optional) {
      function validator(p) {
        var valid = null === p || isFunction(p);
        if (!valid) throw "Expected a Function.";
      }
      return new ArgSpec(validator, opt_optional);
    }
    function getBlobBuilder() {
      return "undefined" !== typeof BlobBuilder ? BlobBuilder : "undefined" !== typeof WebKitBlobBuilder ? WebKitBlobBuilder : void 0;
    }
    function getBlob() {
      var var_args = [];
      for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
      var BlobBuilder = getBlobBuilder();
      if (void 0 !== BlobBuilder) {
        var bb = new BlobBuilder();
        for (var i = 0; i < var_args.length; i++) bb.append(var_args[i]);
        return bb.getBlob();
      }
      if (isNativeBlobDefined()) return new Blob(var_args);
      throw Error("This browser doesn't seem to support creating Blobs");
    }
    function sliceBlob(blob, start, end) {
      if (blob.webkitSlice) return blob.webkitSlice(start, end);
      if (blob.mozSlice) return blob.mozSlice(start, end);
      if (blob.slice) return blob.slice(start, end);
      return null;
    }
    var FbsBlob = function() {
      function FbsBlob(data, opt_elideCopy) {
        var size = 0;
        var blobType = "";
        if (isNativeBlob(data)) {
          this.data_ = data;
          size = data.size;
          blobType = data.type;
        } else if (data instanceof ArrayBuffer) {
          if (opt_elideCopy) this.data_ = new Uint8Array(data); else {
            this.data_ = new Uint8Array(data.byteLength);
            this.data_.set(new Uint8Array(data));
          }
          size = this.data_.length;
        } else if (data instanceof Uint8Array) {
          if (opt_elideCopy) this.data_ = data; else {
            this.data_ = new Uint8Array(data.length);
            this.data_.set(data);
          }
          size = data.length;
        }
        this.size_ = size;
        this.type_ = blobType;
      }
      FbsBlob.prototype.size = function() {
        return this.size_;
      };
      FbsBlob.prototype.type = function() {
        return this.type_;
      };
      FbsBlob.prototype.slice = function(startByte, endByte) {
        if (isNativeBlob(this.data_)) {
          var realBlob = this.data_;
          var sliced = sliceBlob(realBlob, startByte, endByte);
          if (null === sliced) return null;
          return new FbsBlob(sliced);
        }
        var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
        return new FbsBlob(slice, true);
      };
      FbsBlob.getBlob = function() {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) var_args[_i] = arguments[_i];
        if (isNativeBlobDefined()) {
          var blobby = var_args.map(function(val) {
            return val instanceof FbsBlob ? val.data_ : val;
          });
          return new FbsBlob(getBlob.apply(null, blobby));
        }
        var uint8Arrays = var_args.map(function(val) {
          return isString(val) ? dataFromString(StringFormat.RAW, val).data : val.data_;
        });
        var finalLength_1 = 0;
        uint8Arrays.forEach(function(array) {
          finalLength_1 += array.byteLength;
        });
        var merged_1 = new Uint8Array(finalLength_1);
        var index_1 = 0;
        uint8Arrays.forEach(function(array) {
          for (var i = 0; i < array.length; i++) merged_1[index_1++] = array[i];
        });
        return new FbsBlob(merged_1, true);
      };
      FbsBlob.prototype.uploadData = function() {
        return this.data_;
      };
      return FbsBlob;
    }();
    function contains$1(array, elem) {
      return -1 !== array.indexOf(elem);
    }
    function clone$1(arraylike) {
      return Array.prototype.slice.call(arraylike);
    }
    function remove(array, elem) {
      var i = array.indexOf(elem);
      -1 !== i && array.splice(i, 1);
    }
    var RequestInfo = function() {
      function RequestInfo(url, method, handler, timeout) {
        this.url = url;
        this.method = method;
        this.handler = handler;
        this.timeout = timeout;
        this.urlParams = {};
        this.headers = {};
        this.body = null;
        this.errorHandler = null;
        this.progressCallback = null;
        this.successCodes = [ 200 ];
        this.additionalRetryCodes = [];
      }
      return RequestInfo;
    }();
    function handlerCheck(cndn) {
      if (!cndn) throw unknown();
    }
    function metadataHandler(authWrapper, mappings) {
      function handler(xhr, text) {
        var metadata = fromResourceString(authWrapper, text, mappings);
        handlerCheck(null !== metadata);
        return metadata;
      }
      return handler;
    }
    function downloadUrlHandler(authWrapper, mappings) {
      function handler(xhr, text) {
        var metadata = fromResourceString(authWrapper, text, mappings);
        handlerCheck(null !== metadata);
        return downloadUrlFromResourceString(metadata, text);
      }
      return handler;
    }
    function sharedErrorHandler(location) {
      function errorHandler(xhr, err) {
        var newErr;
        newErr = 401 === xhr.getStatus() ? unauthenticated() : 402 === xhr.getStatus() ? quotaExceeded(location.bucket) : 403 === xhr.getStatus() ? unauthorized(location.path) : err;
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
      }
      return errorHandler;
    }
    function objectErrorHandler(location) {
      var shared = sharedErrorHandler(location);
      function errorHandler(xhr, err) {
        var newErr = shared(xhr, err);
        404 === xhr.getStatus() && (newErr = objectNotFound(location.path));
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
      }
      return errorHandler;
    }
    function getMetadata(authWrapper, location, mappings) {
      var urlPart = location.fullServerUrl();
      var url = makeNormalUrl(urlPart);
      var method = "GET";
      var timeout = authWrapper.maxOperationRetryTime();
      var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
      requestInfo.errorHandler = objectErrorHandler(location);
      return requestInfo;
    }
    function getDownloadUrl(authWrapper, location, mappings) {
      var urlPart = location.fullServerUrl();
      var url = makeNormalUrl(urlPart);
      var method = "GET";
      var timeout = authWrapper.maxOperationRetryTime();
      var requestInfo = new RequestInfo(url, method, downloadUrlHandler(authWrapper, mappings), timeout);
      requestInfo.errorHandler = objectErrorHandler(location);
      return requestInfo;
    }
    function updateMetadata(authWrapper, location, metadata, mappings) {
      var urlPart = location.fullServerUrl();
      var url = makeNormalUrl(urlPart);
      var method = "PATCH";
      var body = toResourceString(metadata, mappings);
      var headers = {
        "Content-Type": "application/json; charset=utf-8"
      };
      var timeout = authWrapper.maxOperationRetryTime();
      var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
      requestInfo.headers = headers;
      requestInfo.body = body;
      requestInfo.errorHandler = objectErrorHandler(location);
      return requestInfo;
    }
    function deleteObject(authWrapper, location) {
      var urlPart = location.fullServerUrl();
      var url = makeNormalUrl(urlPart);
      var method = "DELETE";
      var timeout = authWrapper.maxOperationRetryTime();
      function handler(xhr, text) {}
      var requestInfo = new RequestInfo(url, method, handler, timeout);
      requestInfo.successCodes = [ 200, 204 ];
      requestInfo.errorHandler = objectErrorHandler(location);
      return requestInfo;
    }
    function determineContentType_(metadata, blob) {
      return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
    }
    function metadataForUpload_(location, blob, opt_metadata) {
      var metadata = clone(opt_metadata);
      metadata["fullPath"] = location.path;
      metadata["size"] = blob.size();
      metadata["contentType"] || (metadata["contentType"] = determineContentType_(null, blob));
      return metadata;
    }
    function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {
      var urlPart = location.bucketOnlyServerUrl();
      var headers = {
        "X-Goog-Upload-Protocol": "multipart"
      };
      function genBoundary() {
        var str = "";
        for (var i = 0; i < 2; i++) str += Math.random().toString().slice(2);
        return str;
      }
      var boundary = genBoundary();
      headers["Content-Type"] = "multipart/related; boundary=" + boundary;
      var metadata = metadataForUpload_(location, blob, opt_metadata);
      var metadataString = toResourceString(metadata, mappings);
      var preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata["contentType"] + "\r\n\r\n";
      var postBlobPart = "\r\n--" + boundary + "--";
      var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
      if (null === body) throw cannotSliceBlob();
      var urlParams = {
        name: metadata["fullPath"]
      };
      var url = makeUploadUrl(urlPart);
      var method = "POST";
      var timeout = authWrapper.maxUploadRetryTime();
      var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);
      requestInfo.urlParams = urlParams;
      requestInfo.headers = headers;
      requestInfo.body = body.uploadData();
      requestInfo.errorHandler = sharedErrorHandler(location);
      return requestInfo;
    }
    var ResumableUploadStatus = function() {
      function ResumableUploadStatus(current, total, finalized, metadata) {
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
      }
      return ResumableUploadStatus;
    }();
    function checkResumeHeader_(xhr, opt_allowed) {
      var status;
      try {
        status = xhr.getResponseHeader("X-Goog-Upload-Status");
      } catch (e) {
        handlerCheck(false);
      }
      var allowed = opt_allowed || [ "active" ];
      handlerCheck(contains$1(allowed, status));
      return status;
    }
    function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {
      var urlPart = location.bucketOnlyServerUrl();
      var metadata = metadataForUpload_(location, blob, opt_metadata);
      var urlParams = {
        name: metadata["fullPath"]
      };
      var url = makeUploadUrl(urlPart);
      var method = "POST";
      var headers = {
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": blob.size(),
        "X-Goog-Upload-Header-Content-Type": metadata["contentType"],
        "Content-Type": "application/json; charset=utf-8"
      };
      var body = toResourceString(metadata, mappings);
      var timeout = authWrapper.maxUploadRetryTime();
      function handler(xhr, text) {
        checkResumeHeader_(xhr);
        var url;
        try {
          url = xhr.getResponseHeader("X-Goog-Upload-URL");
        } catch (e) {
          handlerCheck(false);
        }
        handlerCheck(isString(url));
        return url;
      }
      var requestInfo = new RequestInfo(url, method, handler, timeout);
      requestInfo.urlParams = urlParams;
      requestInfo.headers = headers;
      requestInfo.body = body;
      requestInfo.errorHandler = sharedErrorHandler(location);
      return requestInfo;
    }
    function getResumableUploadStatus(authWrapper, location, url, blob) {
      var headers = {
        "X-Goog-Upload-Command": "query"
      };
      function handler(xhr, text) {
        var status = checkResumeHeader_(xhr, [ "active", "final" ]);
        var sizeString;
        try {
          sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
        } catch (e) {
          handlerCheck(false);
        }
        var size = parseInt(sizeString, 10);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), "final" === status);
      }
      var method = "POST";
      var timeout = authWrapper.maxUploadRetryTime();
      var requestInfo = new RequestInfo(url, method, handler, timeout);
      requestInfo.headers = headers;
      requestInfo.errorHandler = sharedErrorHandler(location);
      return requestInfo;
    }
    var resumableUploadChunkSize = 262144;
    function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {
      var status = new ResumableUploadStatus(0, 0);
      if (opt_status) {
        status.current = opt_status.current;
        status.total = opt_status.total;
      } else {
        status.current = 0;
        status.total = blob.size();
      }
      if (blob.size() !== status.total) throw serverFileWrongSize();
      var bytesLeft = status.total - status.current;
      var bytesToUpload = bytesLeft;
      chunkSize > 0 && (bytesToUpload = Math.min(bytesToUpload, chunkSize));
      var startByte = status.current;
      var endByte = startByte + bytesToUpload;
      var uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
      var headers = {
        "X-Goog-Upload-Command": uploadCommand,
        "X-Goog-Upload-Offset": status.current
      };
      var body = blob.slice(startByte, endByte);
      if (null === body) throw cannotSliceBlob();
      function handler(xhr, text) {
        var uploadStatus = checkResumeHeader_(xhr, [ "active", "final" ]);
        var newCurrent = status.current + bytesToUpload;
        var size = blob.size();
        var metadata;
        metadata = "final" === uploadStatus ? metadataHandler(authWrapper, mappings)(xhr, text) : null;
        return new ResumableUploadStatus(newCurrent, size, "final" === uploadStatus, metadata);
      }
      var method = "POST";
      var timeout = authWrapper.maxUploadRetryTime();
      var requestInfo = new RequestInfo(url, method, handler, timeout);
      requestInfo.headers = headers;
      requestInfo.body = body.uploadData();
      requestInfo.progressCallback = opt_progressCallback || null;
      requestInfo.errorHandler = sharedErrorHandler(location);
      return requestInfo;
    }
    var Observer = function() {
      function Observer(nextOrObserver, opt_error, opt_complete) {
        var asFunctions = isFunction(nextOrObserver) || isDef(opt_error) || isDef(opt_complete);
        if (asFunctions) {
          this.next = nextOrObserver;
          this.error = opt_error || null;
          this.complete = opt_complete || null;
        } else {
          var observer = nextOrObserver;
          this.next = observer.next || null;
          this.error = observer.error || null;
          this.complete = observer.complete || null;
        }
      }
      return Observer;
    }();
    var UploadTaskSnapshot = function() {
      function UploadTaskSnapshot(bytesTransferred, totalBytes, state, metadata, task, ref) {
        this.bytesTransferred = bytesTransferred;
        this.totalBytes = totalBytes;
        this.state = state;
        this.metadata = metadata;
        this.task = task;
        this.ref = ref;
      }
      return UploadTaskSnapshot;
    }();
    function async(f) {
      return function() {
        var argsToForward = [];
        for (var _i = 0; _i < arguments.length; _i++) argsToForward[_i] = arguments[_i];
        resolve(true).then(function() {
          f.apply(null, argsToForward);
        });
      };
    }
    var UploadTask = function() {
      function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {
        void 0 === metadata && (metadata = null);
        var _this = this;
        this.transferred_ = 0;
        this.needToFetchStatus_ = false;
        this.needToFetchMetadata_ = false;
        this.observers_ = [];
        this.error_ = null;
        this.uploadUrl_ = null;
        this.request_ = null;
        this.chunkMultiplier_ = 1;
        this.resolve_ = null;
        this.reject_ = null;
        this.ref_ = ref;
        this.authWrapper_ = authWrapper;
        this.location_ = location;
        this.blob_ = blob;
        this.metadata_ = metadata;
        this.mappings_ = mappings;
        this.resumable_ = this.shouldDoResumable_(this.blob_);
        this.state_ = InternalTaskState.RUNNING;
        this.errorHandler_ = function(error) {
          _this.request_ = null;
          _this.chunkMultiplier_ = 1;
          if (error.codeEquals(Code.CANCELED)) {
            _this.needToFetchStatus_ = true;
            _this.completeTransitions_();
          } else {
            _this.error_ = error;
            _this.transition_(InternalTaskState.ERROR);
          }
        };
        this.metadataErrorHandler_ = function(error) {
          _this.request_ = null;
          if (error.codeEquals(Code.CANCELED)) _this.completeTransitions_(); else {
            _this.error_ = error;
            _this.transition_(InternalTaskState.ERROR);
          }
        };
        this.promise_ = make(function(resolve$$1, reject$$1) {
          _this.resolve_ = resolve$$1;
          _this.reject_ = reject$$1;
          _this.start_();
        });
        this.promise_.then(null, function() {});
      }
      UploadTask.prototype.makeProgressCallback_ = function() {
        var _this = this;
        var sizeBefore = this.transferred_;
        return function(loaded, total) {
          _this.updateProgress_(sizeBefore + loaded);
        };
      };
      UploadTask.prototype.shouldDoResumable_ = function(blob) {
        return blob.size() > 262144;
      };
      UploadTask.prototype.start_ = function() {
        if (this.state_ !== InternalTaskState.RUNNING) return;
        if (null !== this.request_) return;
        this.resumable_ ? null === this.uploadUrl_ ? this.createResumable_() : this.needToFetchStatus_ ? this.fetchStatus_() : this.needToFetchMetadata_ ? this.fetchMetadata_() : this.continueUpload_() : this.oneShotUpload_();
      };
      UploadTask.prototype.resolveToken_ = function(callback) {
        var _this = this;
        this.authWrapper_.getAuthToken().then(function(authToken) {
          switch (_this.state_) {
           case InternalTaskState.RUNNING:
            callback(authToken);
            break;

           case InternalTaskState.CANCELING:
            _this.transition_(InternalTaskState.CANCELED);
            break;

           case InternalTaskState.PAUSING:
            _this.transition_(InternalTaskState.PAUSED);
          }
        });
      };
      UploadTask.prototype.createResumable_ = function() {
        var _this = this;
        this.resolveToken_(function(authToken) {
          var requestInfo = createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
          var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
          _this.request_ = createRequest;
          createRequest.getPromise().then(function(url) {
            _this.request_ = null;
            _this.uploadUrl_ = url;
            _this.needToFetchStatus_ = false;
            _this.completeTransitions_();
          }, _this.errorHandler_);
        });
      };
      UploadTask.prototype.fetchStatus_ = function() {
        var _this = this;
        var url = this.uploadUrl_;
        this.resolveToken_(function(authToken) {
          var requestInfo = getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);
          var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
          _this.request_ = statusRequest;
          statusRequest.getPromise().then(function(status) {
            status = status;
            _this.request_ = null;
            _this.updateProgress_(status.current);
            _this.needToFetchStatus_ = false;
            status.finalized && (_this.needToFetchMetadata_ = true);
            _this.completeTransitions_();
          }, _this.errorHandler_);
        });
      };
      UploadTask.prototype.continueUpload_ = function() {
        var _this = this;
        var chunkSize = resumableUploadChunkSize * this.chunkMultiplier_;
        var status = new ResumableUploadStatus(this.transferred_, this.blob_.size());
        var url = this.uploadUrl_;
        this.resolveToken_(function(authToken) {
          var requestInfo;
          try {
            requestInfo = continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());
          } catch (e) {
            _this.error_ = e;
            _this.transition_(InternalTaskState.ERROR);
            return;
          }
          var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
          _this.request_ = uploadRequest;
          uploadRequest.getPromise().then(function(newStatus) {
            _this.increaseMultiplier_();
            _this.request_ = null;
            _this.updateProgress_(newStatus.current);
            if (newStatus.finalized) {
              _this.metadata_ = newStatus.metadata;
              _this.transition_(InternalTaskState.SUCCESS);
            } else _this.completeTransitions_();
          }, _this.errorHandler_);
        });
      };
      UploadTask.prototype.increaseMultiplier_ = function() {
        var currentSize = resumableUploadChunkSize * this.chunkMultiplier_;
        currentSize < 33554432 && (this.chunkMultiplier_ *= 2);
      };
      UploadTask.prototype.fetchMetadata_ = function() {
        var _this = this;
        this.resolveToken_(function(authToken) {
          var requestInfo = getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);
          var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
          _this.request_ = metadataRequest;
          metadataRequest.getPromise().then(function(metadata) {
            _this.request_ = null;
            _this.metadata_ = metadata;
            _this.transition_(InternalTaskState.SUCCESS);
          }, _this.metadataErrorHandler_);
        });
      };
      UploadTask.prototype.oneShotUpload_ = function() {
        var _this = this;
        this.resolveToken_(function(authToken) {
          var requestInfo = multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
          var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
          _this.request_ = multipartRequest;
          multipartRequest.getPromise().then(function(metadata) {
            _this.request_ = null;
            _this.metadata_ = metadata;
            _this.updateProgress_(_this.blob_.size());
            _this.transition_(InternalTaskState.SUCCESS);
          }, _this.errorHandler_);
        });
      };
      UploadTask.prototype.updateProgress_ = function(transferred) {
        var old = this.transferred_;
        this.transferred_ = transferred;
        this.transferred_ !== old && this.notifyObservers_();
      };
      UploadTask.prototype.transition_ = function(state) {
        if (this.state_ === state) return;
        switch (state) {
         case InternalTaskState.CANCELING:
         case InternalTaskState.PAUSING:
          this.state_ = state;
          null !== this.request_ && this.request_.cancel();
          break;

         case InternalTaskState.RUNNING:
          var wasPaused = this.state_ === InternalTaskState.PAUSED;
          this.state_ = state;
          if (wasPaused) {
            this.notifyObservers_();
            this.start_();
          }
          break;

         case InternalTaskState.PAUSED:
          this.state_ = state;
          this.notifyObservers_();
          break;

         case InternalTaskState.CANCELED:
          this.error_ = canceled();
          this.state_ = state;
          this.notifyObservers_();
          break;

         case InternalTaskState.ERROR:
         case InternalTaskState.SUCCESS:
          this.state_ = state;
          this.notifyObservers_();
        }
      };
      UploadTask.prototype.completeTransitions_ = function() {
        switch (this.state_) {
         case InternalTaskState.PAUSING:
          this.transition_(InternalTaskState.PAUSED);
          break;

         case InternalTaskState.CANCELING:
          this.transition_(InternalTaskState.CANCELED);
          break;

         case InternalTaskState.RUNNING:
          this.start_();
        }
      };
      Object.defineProperty(UploadTask.prototype, "snapshot", {
        get: function() {
          var externalState = taskStateFromInternalTaskState(this.state_);
          return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);
        },
        enumerable: true,
        configurable: true
      });
      UploadTask.prototype.on = function(type, nextOrObserver, error, completed) {
        void 0 === nextOrObserver && (nextOrObserver = void 0);
        void 0 === error && (error = void 0);
        void 0 === completed && (completed = void 0);
        function typeValidator(_p) {
          if (type !== TaskEvent.STATE_CHANGED) throw "Expected one of the event types: [" + TaskEvent.STATE_CHANGED + "].";
        }
        var nextOrObserverMessage = "Expected a function or an Object with one of `next`, `error`, `complete` properties.";
        var nextValidator = nullFunctionSpec(true).validator;
        var observerValidator = looseObjectSpec(null, true).validator;
        function nextOrObserverValidator(p) {
          try {
            nextValidator(p);
            return;
          } catch (e) {}
          try {
            observerValidator(p);
            var anyDefined = isJustDef(p["next"]) || isJustDef(p["error"]) || isJustDef(p["complete"]);
            if (!anyDefined) throw "";
            return;
          } catch (e) {
            throw nextOrObserverMessage;
          }
        }
        var specs = [ stringSpec(typeValidator), looseObjectSpec(nextOrObserverValidator, true), nullFunctionSpec(true), nullFunctionSpec(true) ];
        validate("on", specs, arguments);
        var self = this;
        function makeBinder(specs) {
          function binder(nextOrObserver, error, opt_complete) {
            null !== specs && validate("on", specs, arguments);
            var observer = new Observer(nextOrObserver, error, completed);
            self.addObserver_(observer);
            return function() {
              self.removeObserver_(observer);
            };
          }
          return binder;
        }
        function binderNextOrObserverValidator(p) {
          if (null === p) throw nextOrObserverMessage;
          nextOrObserverValidator(p);
        }
        var binderSpecs = [ looseObjectSpec(binderNextOrObserverValidator), nullFunctionSpec(true), nullFunctionSpec(true) ];
        var typeOnly = !(isJustDef(nextOrObserver) || isJustDef(error) || isJustDef(completed));
        return typeOnly ? makeBinder(binderSpecs) : makeBinder(null)(nextOrObserver, error, completed);
      };
      UploadTask.prototype.then = function(onFulfilled, onRejected) {
        return this.promise_.then(onFulfilled, onRejected);
      };
      UploadTask.prototype.catch = function(onRejected) {
        return this.then(null, onRejected);
      };
      UploadTask.prototype.addObserver_ = function(observer) {
        this.observers_.push(observer);
        this.notifyObserver_(observer);
      };
      UploadTask.prototype.removeObserver_ = function(observer) {
        remove(this.observers_, observer);
      };
      UploadTask.prototype.notifyObservers_ = function() {
        var _this = this;
        this.finishPromise_();
        var observers = clone$1(this.observers_);
        observers.forEach(function(observer) {
          _this.notifyObserver_(observer);
        });
      };
      UploadTask.prototype.finishPromise_ = function() {
        if (null !== this.resolve_) {
          var triggered = true;
          switch (taskStateFromInternalTaskState(this.state_)) {
           case TaskState.SUCCESS:
            async(this.resolve_.bind(null, this.snapshot))();
            break;

           case TaskState.CANCELED:
           case TaskState.ERROR:
            var toCall = this.reject_;
            async(toCall.bind(null, this.error_))();
            break;

           default:
            triggered = false;
          }
          if (triggered) {
            this.resolve_ = null;
            this.reject_ = null;
          }
        }
      };
      UploadTask.prototype.notifyObserver_ = function(observer) {
        var externalState = taskStateFromInternalTaskState(this.state_);
        switch (externalState) {
         case TaskState.RUNNING:
         case TaskState.PAUSED:
          null !== observer.next && async(observer.next.bind(observer, this.snapshot))();
          break;

         case TaskState.SUCCESS:
          null !== observer.complete && async(observer.complete.bind(observer))();
          break;

         case TaskState.CANCELED:
         case TaskState.ERROR:
          null !== observer.error && async(observer.error.bind(observer, this.error_))();
          break;

         default:
          null !== observer.error && async(observer.error.bind(observer, this.error_))();
        }
      };
      UploadTask.prototype.resume = function() {
        validate("resume", [], arguments);
        var valid = this.state_ === InternalTaskState.PAUSED || this.state_ === InternalTaskState.PAUSING;
        valid && this.transition_(InternalTaskState.RUNNING);
        return valid;
      };
      UploadTask.prototype.pause = function() {
        validate("pause", [], arguments);
        var valid = this.state_ === InternalTaskState.RUNNING;
        valid && this.transition_(InternalTaskState.PAUSING);
        return valid;
      };
      UploadTask.prototype.cancel = function() {
        validate("cancel", [], arguments);
        var valid = this.state_ === InternalTaskState.RUNNING || this.state_ === InternalTaskState.PAUSING;
        valid && this.transition_(InternalTaskState.CANCELING);
        return valid;
      };
      return UploadTask;
    }();
    var Reference = function() {
      function Reference(authWrapper, location) {
        this.authWrapper = authWrapper;
        this.location = location instanceof Location ? location : Location.makeFromUrl(location);
      }
      Reference.prototype.toString = function() {
        validate("toString", [], arguments);
        return "gs://" + this.location.bucket + "/" + this.location.path;
      };
      Reference.prototype.newRef = function(authWrapper, location) {
        return new Reference(authWrapper, location);
      };
      Reference.prototype.mappings = function() {
        return getMappings();
      };
      Reference.prototype.child = function(childPath) {
        validate("child", [ stringSpec() ], arguments);
        var newPath = child(this.location.path, childPath);
        var location = new Location(this.location.bucket, newPath);
        return this.newRef(this.authWrapper, location);
      };
      Object.defineProperty(Reference.prototype, "parent", {
        get: function() {
          var newPath = parent(this.location.path);
          if (null === newPath) return null;
          var location = new Location(this.location.bucket, newPath);
          return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Reference.prototype, "root", {
        get: function() {
          var location = new Location(this.location.bucket, "");
          return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Reference.prototype, "bucket", {
        get: function() {
          return this.location.bucket;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Reference.prototype, "fullPath", {
        get: function() {
          return this.location.path;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Reference.prototype, "name", {
        get: function() {
          return lastComponent(this.location.path);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Reference.prototype, "storage", {
        get: function() {
          return this.authWrapper.service();
        },
        enumerable: true,
        configurable: true
      });
      Reference.prototype.put = function(data, metadata) {
        void 0 === metadata && (metadata = null);
        validate("put", [ uploadDataSpec(), metadataSpec(true) ], arguments);
        this.throwIfRoot_("put");
        return new UploadTask(this, this.authWrapper, this.location, this.mappings(), new FbsBlob(data), metadata);
      };
      Reference.prototype.putString = function(string, format, opt_metadata) {
        void 0 === format && (format = StringFormat.RAW);
        validate("putString", [ stringSpec(), stringSpec(formatValidator, true), metadataSpec(true) ], arguments);
        this.throwIfRoot_("putString");
        var data = dataFromString(format, string);
        var metadata = clone(opt_metadata);
        !isDef(metadata["contentType"]) && isDef(data.contentType) && (metadata["contentType"] = data.contentType);
        return new UploadTask(this, this.authWrapper, this.location, this.mappings(), new FbsBlob(data.data, true), metadata);
      };
      Reference.prototype.delete = function() {
        validate("delete", [], arguments);
        this.throwIfRoot_("delete");
        var self = this;
        return this.authWrapper.getAuthToken().then(function(authToken) {
          var requestInfo = deleteObject(self.authWrapper, self.location);
          return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
      };
      Reference.prototype.getMetadata = function() {
        validate("getMetadata", [], arguments);
        this.throwIfRoot_("getMetadata");
        var self = this;
        return this.authWrapper.getAuthToken().then(function(authToken) {
          var requestInfo = getMetadata(self.authWrapper, self.location, self.mappings());
          return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
      };
      Reference.prototype.updateMetadata = function(metadata) {
        validate("updateMetadata", [ metadataSpec() ], arguments);
        this.throwIfRoot_("updateMetadata");
        var self = this;
        return this.authWrapper.getAuthToken().then(function(authToken) {
          var requestInfo = updateMetadata(self.authWrapper, self.location, metadata, self.mappings());
          return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
      };
      Reference.prototype.getDownloadURL = function() {
        validate("getDownloadURL", [], arguments);
        this.throwIfRoot_("getDownloadURL");
        var self = this;
        return this.authWrapper.getAuthToken().then(function(authToken) {
          var requestInfo = getDownloadUrl(self.authWrapper, self.location, self.mappings());
          return self.authWrapper.makeRequest(requestInfo, authToken).getPromise().then(function(url) {
            if (null === url) throw noDownloadURL();
            return url;
          });
        });
      };
      Reference.prototype.throwIfRoot_ = function(name) {
        if ("" === this.location.path) throw invalidRootOperation(name);
      };
      return Reference;
    }();
    var FailRequest = function() {
      function FailRequest(error) {
        this.promise_ = reject(error);
      }
      FailRequest.prototype.getPromise = function() {
        return this.promise_;
      };
      FailRequest.prototype.cancel = function(appDelete) {
        void 0 === appDelete && (appDelete = false);
      };
      return FailRequest;
    }();
    var RequestMap = function() {
      function RequestMap() {
        this.map_ = {};
        this.id_ = minSafeInteger;
      }
      RequestMap.prototype.addRequest = function(r) {
        var id = this.id_;
        this.id_++;
        this.map_[id] = r;
        var self = this;
        function unmap() {
          delete self.map_[id];
        }
        r.getPromise().then(unmap, unmap);
      };
      RequestMap.prototype.clear = function() {
        forEach(this.map_, function(key, val) {
          val && val.cancel(true);
        });
        this.map_ = {};
      };
      return RequestMap;
    }();
    var AuthWrapper = function() {
      function AuthWrapper(app, maker, requestMaker, service, pool) {
        this.bucket_ = null;
        this.deleted_ = false;
        this.app_ = app;
        if (null !== this.app_) {
          var options = this.app_.options;
          isDef(options) && (this.bucket_ = AuthWrapper.extractBucket_(options));
        }
        this.storageRefMaker_ = maker;
        this.requestMaker_ = requestMaker;
        this.pool_ = pool;
        this.service_ = service;
        this.maxOperationRetryTime_ = defaultMaxOperationRetryTime;
        this.maxUploadRetryTime_ = defaultMaxUploadRetryTime;
        this.requestMap_ = new RequestMap();
      }
      AuthWrapper.extractBucket_ = function(config) {
        var bucketString = config[configOption] || null;
        if (null == bucketString) return null;
        var loc = Location.makeFromBucketSpec(bucketString);
        return loc.bucket;
      };
      AuthWrapper.prototype.getAuthToken = function() {
        return null !== this.app_ && isDef(this.app_.INTERNAL) && isDef(this.app_.INTERNAL.getToken) ? this.app_.INTERNAL.getToken().then(function(response) {
          return null !== response ? response.accessToken : null;
        }, function(_error) {
          return null;
        }) : resolve(null);
      };
      AuthWrapper.prototype.bucket = function() {
        if (this.deleted_) throw appDeleted();
        return this.bucket_;
      };
      AuthWrapper.prototype.service = function() {
        return this.service_;
      };
      AuthWrapper.prototype.makeStorageReference = function(loc) {
        return this.storageRefMaker_(this, loc);
      };
      AuthWrapper.prototype.makeRequest = function(requestInfo, authToken) {
        if (this.deleted_) return new FailRequest(appDeleted());
        var request = this.requestMaker_(requestInfo, authToken, this.pool_);
        this.requestMap_.addRequest(request);
        return request;
      };
      AuthWrapper.prototype.deleteApp = function() {
        this.deleted_ = true;
        this.app_ = null;
        this.requestMap_.clear();
      };
      AuthWrapper.prototype.maxUploadRetryTime = function() {
        return this.maxUploadRetryTime_;
      };
      AuthWrapper.prototype.setMaxUploadRetryTime = function(time) {
        this.maxUploadRetryTime_ = time;
      };
      AuthWrapper.prototype.maxOperationRetryTime = function() {
        return this.maxOperationRetryTime_;
      };
      AuthWrapper.prototype.setMaxOperationRetryTime = function(time) {
        this.maxOperationRetryTime_ = time;
      };
      return AuthWrapper;
    }();
    function start(f, callback, timeout) {
      var waitSeconds = 1;
      var timeoutId = null;
      var hitTimeout = false;
      var cancelState = 0;
      function canceled() {
        return 2 === cancelState;
      }
      var triggeredCallback = false;
      function triggerCallback() {
        if (!triggeredCallback) {
          triggeredCallback = true;
          callback.apply(null, arguments);
        }
      }
      function callWithDelay(millis) {
        timeoutId = setTimeout(function() {
          timeoutId = null;
          f(handler, canceled());
        }, millis);
      }
      function handler(success) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) var_args[_i - 1] = arguments[_i];
        if (triggeredCallback) return;
        if (success) {
          triggerCallback.apply(null, arguments);
          return;
        }
        var mustStop = canceled() || hitTimeout;
        if (mustStop) {
          triggerCallback.apply(null, arguments);
          return;
        }
        waitSeconds < 64 && (waitSeconds *= 2);
        var waitMillis;
        if (1 === cancelState) {
          cancelState = 2;
          waitMillis = 0;
        } else waitMillis = 1e3 * (waitSeconds + Math.random());
        callWithDelay(waitMillis);
      }
      var stopped = false;
      function stop(wasTimeout) {
        if (stopped) return;
        stopped = true;
        if (triggeredCallback) return;
        if (null !== timeoutId) {
          wasTimeout || (cancelState = 2);
          clearTimeout(timeoutId);
          callWithDelay(0);
        } else wasTimeout || (cancelState = 1);
      }
      callWithDelay(0);
      setTimeout(function() {
        hitTimeout = true;
        stop(true);
      }, timeout);
      return stop;
    }
    function stop(id) {
      id(false);
    }
    var NetworkRequest = function() {
      function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
        this.pendingXhr_ = null;
        this.backoffId_ = null;
        this.resolve_ = null;
        this.reject_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.url_ = url;
        this.method_ = method;
        this.headers_ = headers;
        this.body_ = body;
        this.successCodes_ = successCodes.slice();
        this.additionalRetryCodes_ = additionalRetryCodes.slice();
        this.callback_ = callback;
        this.errorCallback_ = errorCallback;
        this.progressCallback_ = progressCallback;
        this.timeout_ = timeout;
        this.pool_ = pool;
        var self = this;
        this.promise_ = make(function(resolve$$1, reject$$1) {
          self.resolve_ = resolve$$1;
          self.reject_ = reject$$1;
          self.start_();
        });
      }
      NetworkRequest.prototype.start_ = function() {
        var self = this;
        function doTheRequest(backoffCallback, canceled$$1) {
          if (canceled$$1) {
            backoffCallback(false, new RequestEndStatus(false, null, true));
            return;
          }
          var xhr = self.pool_.createXhrIo();
          self.pendingXhr_ = xhr;
          function progressListener(progressEvent) {
            var loaded = progressEvent.loaded;
            var total = progressEvent.lengthComputable ? progressEvent.total : -1;
            null !== self.progressCallback_ && self.progressCallback_(loaded, total);
          }
          null !== self.progressCallback_ && xhr.addUploadProgressListener(progressListener);
          xhr.send(self.url_, self.method_, self.body_, self.headers_).then(function(xhr) {
            null !== self.progressCallback_ && xhr.removeUploadProgressListener(progressListener);
            self.pendingXhr_ = null;
            xhr = xhr;
            var hitServer = xhr.getErrorCode() === ErrorCode.NO_ERROR;
            var status = xhr.getStatus();
            if (!hitServer || self.isRetryStatusCode_(status)) {
              var wasCanceled = xhr.getErrorCode() === ErrorCode.ABORT;
              backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
              return;
            }
            var successCode = contains$1(self.successCodes_, status);
            backoffCallback(true, new RequestEndStatus(successCode, xhr));
          });
        }
        function backoffDone(requestWentThrough, status) {
          var resolve$$1 = self.resolve_;
          var reject$$1 = self.reject_;
          var xhr = status.xhr;
          if (status.wasSuccessCode) try {
            var result = self.callback_(xhr, xhr.getResponseText());
            isJustDef(result) ? resolve$$1(result) : resolve$$1();
          } catch (e) {
            reject$$1(e);
          } else if (null !== xhr) {
            var err = unknown();
            err.setServerResponseProp(xhr.getResponseText());
            self.errorCallback_ ? reject$$1(self.errorCallback_(xhr, err)) : reject$$1(err);
          } else if (status.canceled) {
            var err = self.appDelete_ ? appDeleted() : canceled();
            reject$$1(err);
          } else {
            var err = retryLimitExceeded();
            reject$$1(err);
          }
        }
        this.canceled_ ? backoffDone(false, new RequestEndStatus(false, null, true)) : this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      };
      NetworkRequest.prototype.getPromise = function() {
        return this.promise_;
      };
      NetworkRequest.prototype.cancel = function(appDelete) {
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        null !== this.backoffId_ && stop(this.backoffId_);
        null !== this.pendingXhr_ && this.pendingXhr_.abort();
      };
      NetworkRequest.prototype.isRetryStatusCode_ = function(status) {
        var isFiveHundredCode = status >= 500 && status < 600;
        var extraRetryCodes = [ 408, 429 ];
        var isExtraRetryCode = contains$1(extraRetryCodes, status);
        var isRequestSpecificRetryCode = contains$1(this.additionalRetryCodes_, status);
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
      };
      return NetworkRequest;
    }();
    var RequestEndStatus = function() {
      function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {
        this.wasSuccessCode = wasSuccessCode;
        this.xhr = xhr;
        this.canceled = !!opt_canceled;
      }
      return RequestEndStatus;
    }();
    function addAuthHeader_(headers, authToken) {
      null !== authToken && authToken.length > 0 && (headers["Authorization"] = "Firebase " + authToken);
    }
    function addVersionHeader_(headers) {
      var number = "undefined" !== typeof firebase ? firebase.SDK_VERSION : "AppManager";
      headers["X-Firebase-Storage-Version"] = "webjs/" + number;
    }
    function makeRequest(requestInfo, authToken, pool) {
      var queryPart = makeQueryString(requestInfo.urlParams);
      var url = requestInfo.url + queryPart;
      var headers = clone(requestInfo.headers);
      addAuthHeader_(headers, authToken);
      addVersionHeader_(headers);
      return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
    }
    var Service = function() {
      function Service(app, pool, url) {
        this.bucket_ = null;
        function maker(authWrapper, loc) {
          return new Reference(authWrapper, loc);
        }
        this.authWrapper_ = new AuthWrapper(app, maker, makeRequest, this, pool);
        this.app_ = app;
        if (null != url) this.bucket_ = Location.makeFromBucketSpec(url); else {
          var authWrapperBucket = this.authWrapper_.bucket();
          null != authWrapperBucket && (this.bucket_ = new Location(authWrapperBucket, ""));
        }
        this.internals_ = new ServiceInternals(this);
      }
      Service.prototype.ref = function(path) {
        function validator(path) {
          if (/^[A-Za-z]+:\/\//.test(path)) throw "Expected child path but got a URL, use refFromURL instead.";
        }
        validate("ref", [ stringSpec(validator, true) ], arguments);
        if (null == this.bucket_) throw new Error("No Storage Bucket defined in Firebase Options.");
        var ref = new Reference(this.authWrapper_, this.bucket_);
        return null != path ? ref.child(path) : ref;
      };
      Service.prototype.refFromURL = function(url) {
        function validator(p) {
          if (!/^[A-Za-z]+:\/\//.test(p)) throw "Expected full URL but got a child path, use ref instead.";
          try {
            Location.makeFromUrl(p);
          } catch (e) {
            throw "Expected valid full URL but got an invalid one.";
          }
        }
        validate("refFromURL", [ stringSpec(validator, false) ], arguments);
        return new Reference(this.authWrapper_, url);
      };
      Object.defineProperty(Service.prototype, "maxUploadRetryTime", {
        get: function() {
          return this.authWrapper_.maxUploadRetryTime();
        },
        enumerable: true,
        configurable: true
      });
      Service.prototype.setMaxUploadRetryTime = function(time) {
        validate("setMaxUploadRetryTime", [ nonNegativeNumberSpec() ], arguments);
        this.authWrapper_.setMaxUploadRetryTime(time);
      };
      Object.defineProperty(Service.prototype, "maxOperationRetryTime", {
        get: function() {
          return this.authWrapper_.maxOperationRetryTime();
        },
        enumerable: true,
        configurable: true
      });
      Service.prototype.setMaxOperationRetryTime = function(time) {
        validate("setMaxOperationRetryTime", [ nonNegativeNumberSpec() ], arguments);
        this.authWrapper_.setMaxOperationRetryTime(time);
      };
      Object.defineProperty(Service.prototype, "app", {
        get: function() {
          return this.app_;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Service.prototype, "INTERNAL", {
        get: function() {
          return this.internals_;
        },
        enumerable: true,
        configurable: true
      });
      return Service;
    }();
    var ServiceInternals = function() {
      function ServiceInternals(service) {
        this.service_ = service;
      }
      ServiceInternals.prototype.delete = function() {
        this.service_.authWrapper_.deleteApp();
        return resolve(void 0);
      };
      return ServiceInternals;
    }();
    var STORAGE_TYPE = "storage";
    function factory(app, unused, opt_url) {
      return new Service(app, new XhrIoPool(), opt_url);
    }
    function registerStorage(instance) {
      var namespaceExports = {
        TaskState: TaskState,
        TaskEvent: TaskEvent,
        StringFormat: StringFormat,
        Storage: Service,
        Reference: Reference
      };
      instance.INTERNAL.registerService(STORAGE_TYPE, factory, namespaceExports, void 0, true);
    }
    registerStorage(firebase);
    exports.registerStorage = registerStorage;
  }, {
    "@firebase/app": 7
  } ],
  16: [ function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var tslib_1 = require("tslib");
    var CONSTANTS = {
      NODE_CLIENT: false,
      NODE_ADMIN: false,
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    var assert = function(assertion, message) {
      if (!assertion) throw assertionError(message);
    };
    var assertionError = function(message) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
    };
    var stringToByteArray = function(str) {
      var out = [], p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) out[p++] = c; else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = 63 & c | 128;
        } else if (55296 == (64512 & c) && i + 1 < str.length && 56320 == (64512 & str.charCodeAt(i + 1))) {
          c = 65536 + ((1023 & c) << 10) + (1023 & str.charCodeAt(++i));
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = 63 & c | 128;
        } else {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = 63 & c | 128;
        }
      }
      return out;
    };
    var byteArrayToString = function(bytes) {
      var out = [], pos = 0, c = 0;
      while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) out[c++] = String.fromCharCode(c1); else if (c1 > 191 && c1 < 224) {
          var c2 = bytes[pos++];
          out[c++] = String.fromCharCode((31 & c1) << 6 | 63 & c2);
        } else if (c1 > 239 && c1 < 365) {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          var c4 = bytes[pos++];
          var u = ((7 & c1) << 18 | (63 & c2) << 12 | (63 & c3) << 6 | 63 & c4) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (1023 & u));
        } else {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          out[c++] = String.fromCharCode((15 & c1) << 12 | (63 & c2) << 6 | 63 & c3);
        }
      }
      return out.join("");
    };
    var base64 = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: "function" === typeof atob,
      encodeByteArray: function(input, opt_webSafe) {
        if (!Array.isArray(input)) throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        var byteToCharMap = opt_webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
          var byte1 = input[i];
          var haveByte2 = i + 1 < input.length;
          var byte2 = haveByte2 ? input[i + 1] : 0;
          var haveByte3 = i + 2 < input.length;
          var byte3 = haveByte3 ? input[i + 2] : 0;
          var outByte1 = byte1 >> 2;
          var outByte2 = (3 & byte1) << 4 | byte2 >> 4;
          var outByte3 = (15 & byte2) << 2 | byte3 >> 6;
          var outByte4 = 63 & byte3;
          if (!haveByte3) {
            outByte4 = 64;
            haveByte2 || (outByte3 = 64);
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      encodeString: function(input, opt_webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) return btoa(input);
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
      },
      decodeString: function(input, opt_webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) return atob(input);
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
      },
      decodeStringToByteArray: function(input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length; ) {
          var byte1 = charToByteMap[input.charAt(i++)];
          var haveByte2 = i < input.length;
          var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          var haveByte3 = i < input.length;
          var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          var haveByte4 = i < input.length;
          var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          if (null == byte1 || null == byte2 || null == byte3 || null == byte4) throw Error();
          var outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (64 != byte3) {
            var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (64 != byte4) {
              var outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      init_: function() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (var i = 0; i < this.ENCODED_VALS.length; i++) {
            this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
            this.charToByteMap_[this.byteToCharMap_[i]] = i;
            this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
            if (i >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
            }
          }
        }
      }
    };
    var base64Encode = function(str) {
      var utf8Bytes = stringToByteArray(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    var base64Decode = function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    function deepExtend(target, source) {
      if (!(source instanceof Object)) return source;
      switch (source.constructor) {
       case Date:
        var dateValue = source;
        return new Date(dateValue.getTime());

       case Object:
        void 0 === target && (target = {});
        break;

       case Array:
        target = [];
        break;

       default:
        return source;
      }
      for (var prop in source) {
        if (!source.hasOwnProperty(prop)) continue;
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    function patchProperty(obj, prop, value) {
      obj[prop] = value;
    }
    var Deferred = function() {
      function Deferred() {
        var _this = this;
        this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
      }
      Deferred.prototype.wrapCallback = function(callback) {
        var _this = this;
        return function(error, value) {
          error ? _this.reject(error) : _this.resolve(value);
          if ("function" === typeof callback) {
            _this.promise.catch(function() {});
            1 === callback.length ? callback(error) : callback(error, value);
          }
        };
      };
      return Deferred;
    }();
    var getUA = function() {
      return "undefined" !== typeof navigator && "string" === typeof navigator["userAgent"] ? navigator["userAgent"] : "";
    };
    var isMobileCordova = function() {
      return "undefined" !== typeof window && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
    };
    var isReactNative = function() {
      return "object" === typeof navigator && "ReactNative" === navigator["product"];
    };
    var isNodeSdk = function() {
      return true === CONSTANTS.NODE_CLIENT || true === CONSTANTS.NODE_ADMIN;
    };
    var ERROR_NAME = "FirebaseError";
    var captureStackTrace = Error.captureStackTrace;
    function patchCapture(captureFake) {
      var result = captureStackTrace;
      captureStackTrace = captureFake;
      return result;
    }
    var FirebaseError = function() {
      function FirebaseError(code, message) {
        this.code = code;
        this.message = message;
        if (captureStackTrace) captureStackTrace(this, ErrorFactory.prototype.create); else try {
          throw Error.apply(this, arguments);
        } catch (err) {
          this.name = ERROR_NAME;
          Object.defineProperty(this, "stack", {
            get: function() {
              return err.stack;
            }
          });
        }
      }
      return FirebaseError;
    }();
    FirebaseError.prototype = Object.create(Error.prototype);
    FirebaseError.prototype.constructor = FirebaseError;
    FirebaseError.prototype.name = ERROR_NAME;
    var ErrorFactory = function() {
      function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
        this.pattern = /\{\$([^}]+)}/g;
      }
      ErrorFactory.prototype.create = function(code, data) {
        void 0 === data && (data = {});
        var template = this.errors[code];
        var fullCode = this.service + "/" + code;
        var message;
        message = void 0 === template ? "Error" : template.replace(this.pattern, function(match, key) {
          var value = data[key];
          return void 0 !== value ? value.toString() : "<" + key + "?>";
        });
        message = this.serviceName + ": " + message + " (" + fullCode + ").";
        var err = new FirebaseError(fullCode, message);
        for (var prop in data) {
          if (!data.hasOwnProperty(prop) || "_" === prop.slice(-1)) continue;
          err[prop] = data[prop];
        }
        return err;
      };
      return ErrorFactory;
    }();
    function jsonEval(str) {
      return JSON.parse(str);
    }
    function stringify(data) {
      return JSON.stringify(data);
    }
    var decode = function(token) {
      var header = {}, claims = {}, data = {}, signature = "";
      try {
        var parts = token.split(".");
        header = jsonEval(base64Decode(parts[0]) || "");
        claims = jsonEval(base64Decode(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {}
      return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
      };
    };
    var isValidTimestamp = function(token) {
      var claims = decode(token).claims, now = Math.floor(new Date().getTime() / 1e3), validSince, validUntil;
      if ("object" === typeof claims) {
        claims.hasOwnProperty("nbf") ? validSince = claims["nbf"] : claims.hasOwnProperty("iat") && (validSince = claims["iat"]);
        validUntil = claims.hasOwnProperty("exp") ? claims["exp"] : validSince + 86400;
      }
      return now && validSince && validUntil && now >= validSince && now <= validUntil;
    };
    var issuedAtTime = function(token) {
      var claims = decode(token).claims;
      if ("object" === typeof claims && claims.hasOwnProperty("iat")) return claims["iat"];
      return null;
    };
    var isValidFormat = function(token) {
      var decoded = decode(token), claims = decoded.claims;
      return !!decoded.signature && !!claims && "object" === typeof claims && claims.hasOwnProperty("iat");
    };
    var isAdmin = function(token) {
      var claims = decode(token).claims;
      return "object" === typeof claims && true === claims["admin"];
    };
    var contains = function(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    var safeGet = function(obj, key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) return obj[key];
    };
    var forEach = function(obj, fn) {
      for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && fn(key, obj[key]);
    };
    var extend = function(objTo, objFrom) {
      forEach(objFrom, function(key, value) {
        objTo[key] = value;
      });
      return objTo;
    };
    var clone = function(obj) {
      return extend({}, obj);
    };
    var isNonNullObject = function(obj) {
      return "object" === typeof obj && null !== obj;
    };
    var isEmpty = function(obj) {
      for (var key in obj) return false;
      return true;
    };
    var getCount = function(obj) {
      var rv = 0;
      for (var key in obj) rv++;
      return rv;
    };
    var map = function(obj, f, opt_obj) {
      var res = {};
      for (var key in obj) res[key] = f.call(opt_obj, obj[key], key, obj);
      return res;
    };
    var findKey = function(obj, fn, opt_this) {
      for (var key in obj) if (fn.call(opt_this, obj[key], key, obj)) return key;
      return;
    };
    var findValue = function(obj, fn, opt_this) {
      var key = findKey(obj, fn, opt_this);
      return key && obj[key];
    };
    var getAnyKey = function(obj) {
      for (var key in obj) return key;
    };
    var getValues = function(obj) {
      var res = [];
      var i = 0;
      for (var key in obj) res[i++] = obj[key];
      return res;
    };
    var every = function(obj, fn) {
      for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key) && !fn(key, obj[key])) return false;
      return true;
    };
    var querystring = function(querystringParams) {
      var params = [];
      forEach(querystringParams, function(key, value) {
        Array.isArray(value) ? value.forEach(function(arrayVal) {
          params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
        }) : params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
      });
      return params.length ? "&" + params.join("&") : "";
    };
    var querystringDecode = function(querystring) {
      var obj = {};
      var tokens = querystring.replace(/^\?/, "").split("&");
      tokens.forEach(function(token) {
        if (token) {
          var key = token.split("=");
          obj[key[0]] = key[1];
        }
      });
      return obj;
    };
    var Hash = function() {
      function Hash() {
        this.blockSize = -1;
      }
      return Hash;
    }();
    var Sha1 = function(_super) {
      tslib_1.__extends(Sha1, _super);
      function Sha1() {
        var _this = _super.call(this) || this;
        _this.chain_ = [];
        _this.buf_ = [];
        _this.W_ = [];
        _this.pad_ = [];
        _this.inbuf_ = 0;
        _this.total_ = 0;
        _this.blockSize = 64;
        _this.pad_[0] = 128;
        for (var i = 1; i < _this.blockSize; ++i) _this.pad_[i] = 0;
        _this.reset();
        return _this;
      }
      Sha1.prototype.reset = function() {
        this.chain_[0] = 1732584193;
        this.chain_[1] = 4023233417;
        this.chain_[2] = 2562383102;
        this.chain_[3] = 271733878;
        this.chain_[4] = 3285377520;
        this.inbuf_ = 0;
        this.total_ = 0;
      };
      Sha1.prototype.compress_ = function(buf, opt_offset) {
        opt_offset || (opt_offset = 0);
        var W = this.W_;
        if ("string" === typeof buf) for (var i = 0; i < 16; i++) {
          W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
          opt_offset += 4;
        } else for (var i = 0; i < 16; i++) {
          W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
          opt_offset += 4;
        }
        for (var i = 16; i < 80; i++) {
          var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = 4294967295 & (t << 1 | t >>> 31);
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        for (var i = 0; i < 80; i++) {
          if (i < 40) if (i < 20) {
            f = d ^ b & (c ^ d);
            k = 1518500249;
          } else {
            f = b ^ c ^ d;
            k = 1859775393;
          } else if (i < 60) {
            f = b & c | d & (b | c);
            k = 2400959708;
          } else {
            f = b ^ c ^ d;
            k = 3395469782;
          }
          var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
          e = d;
          d = c;
          c = 4294967295 & (b << 30 | b >>> 2);
          b = a;
          a = t;
        }
        this.chain_[0] = this.chain_[0] + a & 4294967295;
        this.chain_[1] = this.chain_[1] + b & 4294967295;
        this.chain_[2] = this.chain_[2] + c & 4294967295;
        this.chain_[3] = this.chain_[3] + d & 4294967295;
        this.chain_[4] = this.chain_[4] + e & 4294967295;
      };
      Sha1.prototype.update = function(bytes, opt_length) {
        if (null == bytes) return;
        void 0 === opt_length && (opt_length = bytes.length);
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        while (n < opt_length) {
          if (0 == inbuf) while (n <= lengthMinusBlock) {
            this.compress_(bytes, n);
            n += this.blockSize;
          }
          if ("string" === typeof bytes) while (n < opt_length) {
            buf[inbuf] = bytes.charCodeAt(n);
            ++inbuf;
            ++n;
            if (inbuf == this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          } else while (n < opt_length) {
            buf[inbuf] = bytes[n];
            ++inbuf;
            ++n;
            if (inbuf == this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
      };
      Sha1.prototype.digest = function() {
        var digest = [];
        var totalBits = 8 * this.total_;
        this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        for (var i = this.blockSize - 1; i >= 56; i--) {
          this.buf_[i] = 255 & totalBits;
          totalBits /= 256;
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) for (var j = 24; j >= 0; j -= 8) {
          digest[n] = this.chain_[i] >> j & 255;
          ++n;
        }
        return digest;
      };
      return Sha1;
    }(Hash);
    function createSubscribe(executor, onNoObservers) {
      var proxy = new ObserverProxy(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    var ObserverProxy = function() {
      function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        this.task.then(function() {
          executor(_this);
        }).catch(function(e) {
          _this.error(e);
        });
      }
      ObserverProxy.prototype.next = function(value) {
        this.forEachObserver(function(observer) {
          observer.next(value);
        });
      };
      ObserverProxy.prototype.error = function(error) {
        this.forEachObserver(function(observer) {
          observer.error(error);
        });
        this.close(error);
      };
      ObserverProxy.prototype.complete = function() {
        this.forEachObserver(function(observer) {
          observer.complete();
        });
        this.close();
      };
      ObserverProxy.prototype.subscribe = function(nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (void 0 === nextOrObserver && void 0 === error && void 0 === complete) throw new Error("Missing Observer.");
        observer = implementsAnyMethods(nextOrObserver, [ "next", "error", "complete" ]) ? nextOrObserver : {
          next: nextOrObserver,
          error: error,
          complete: complete
        };
        void 0 === observer.next && (observer.next = noop);
        void 0 === observer.error && (observer.error = noop);
        void 0 === observer.complete && (observer.complete = noop);
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        this.finalized && this.task.then(function() {
          try {
            _this.finalError ? observer.error(_this.finalError) : observer.complete();
          } catch (e) {}
          return;
        });
        this.observers.push(observer);
        return unsub;
      };
      ObserverProxy.prototype.unsubscribeOne = function(i) {
        if (void 0 === this.observers || void 0 === this.observers[i]) return;
        delete this.observers[i];
        this.observerCount -= 1;
        0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this);
      };
      ObserverProxy.prototype.forEachObserver = function(fn) {
        if (this.finalized) return;
        for (var i = 0; i < this.observers.length; i++) this.sendOne(i, fn);
      };
      ObserverProxy.prototype.sendOne = function(i, fn) {
        var _this = this;
        this.task.then(function() {
          if (void 0 !== _this.observers && void 0 !== _this.observers[i]) try {
            fn(_this.observers[i]);
          } catch (e) {
            "undefined" !== typeof console && console.error && console.error(e);
          }
        });
      };
      ObserverProxy.prototype.close = function(err) {
        var _this = this;
        if (this.finalized) return;
        this.finalized = true;
        void 0 !== err && (this.finalError = err);
        this.task.then(function() {
          _this.observers = void 0;
          _this.onNoObservers = void 0;
        });
      };
      return ObserverProxy;
    }();
    function async(fn, onError) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        Promise.resolve(true).then(function() {
          fn.apply(void 0, args);
        }).catch(function(error) {
          onError && onError(error);
        });
      };
    }
    function implementsAnyMethods(obj, methods) {
      if ("object" !== typeof obj || null === obj) return false;
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && "function" === typeof obj[method]) return true;
      }
      return false;
    }
    function noop() {}
    var validateArgCount = function(fnName, minCount, maxCount, argCount) {
      var argError;
      argCount < minCount ? argError = "at least " + minCount : argCount > maxCount && (argError = 0 === maxCount ? "none" : "no more than " + maxCount);
      if (argError) {
        var error = fnName + " failed: Was called with " + argCount + (1 === argCount ? " argument." : " arguments.") + " Expects " + argError + ".";
        throw new Error(error);
      }
    };
    function errorPrefix(fnName, argumentNumber, optional) {
      var argName = "";
      switch (argumentNumber) {
       case 1:
        argName = optional ? "first" : "First";
        break;

       case 2:
        argName = optional ? "second" : "Second";
        break;

       case 3:
        argName = optional ? "third" : "Third";
        break;

       case 4:
        argName = optional ? "fourth" : "Fourth";
        break;

       default:
        throw new Error("errorPrefix called with argumentNumber > 4.  Need to update it?");
      }
      var error = fnName + " failed: ";
      error += argName + " argument ";
      return error;
    }
    function validateNamespace(fnName, argumentNumber, namespace, optional) {
      if (optional && !namespace) return;
      if ("string" !== typeof namespace) throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid firebase namespace.");
    }
    function validateCallback(fnName, argumentNumber, callback, optional) {
      if (optional && !callback) return;
      if ("function" !== typeof callback) throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid function.");
    }
    function validateContextObject(fnName, argumentNumber, context, optional) {
      if (optional && !context) return;
      if ("object" !== typeof context || null === context) throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid context object.");
    }
    var stringToByteArray$1 = function(str) {
      var out = [], p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 55296 && c <= 56319) {
          var high = c - 55296;
          i++;
          assert(i < str.length, "Surrogate pair missing trail surrogate.");
          var low = str.charCodeAt(i) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) out[p++] = c; else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = 63 & c | 128;
        } else if (c < 65536) {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = 63 & c | 128;
        } else {
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = 63 & c | 128;
        }
      }
      return out;
    };
    var stringLength = function(str) {
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) p++; else if (c < 2048) p += 2; else if (c >= 55296 && c <= 56319) {
          p += 4;
          i++;
        } else p += 3;
      }
      return p;
    };
    exports.assert = assert;
    exports.assertionError = assertionError;
    exports.base64 = base64;
    exports.base64Decode = base64Decode;
    exports.base64Encode = base64Encode;
    exports.CONSTANTS = CONSTANTS;
    exports.deepCopy = deepCopy;
    exports.deepExtend = deepExtend;
    exports.patchProperty = patchProperty;
    exports.Deferred = Deferred;
    exports.getUA = getUA;
    exports.isMobileCordova = isMobileCordova;
    exports.isNodeSdk = isNodeSdk;
    exports.isReactNative = isReactNative;
    exports.ErrorFactory = ErrorFactory;
    exports.FirebaseError = FirebaseError;
    exports.patchCapture = patchCapture;
    exports.jsonEval = jsonEval;
    exports.stringify = stringify;
    exports.decode = decode;
    exports.isAdmin = isAdmin;
    exports.issuedAtTime = issuedAtTime;
    exports.isValidFormat = isValidFormat;
    exports.isValidTimestamp = isValidTimestamp;
    exports.clone = clone;
    exports.contains = contains;
    exports.every = every;
    exports.extend = extend;
    exports.findKey = findKey;
    exports.findValue = findValue;
    exports.forEach = forEach;
    exports.getAnyKey = getAnyKey;
    exports.getCount = getCount;
    exports.getValues = getValues;
    exports.isEmpty = isEmpty;
    exports.isNonNullObject = isNonNullObject;
    exports.map = map;
    exports.safeGet = safeGet;
    exports.querystring = querystring;
    exports.querystringDecode = querystringDecode;
    exports.Sha1 = Sha1;
    exports.async = async;
    exports.createSubscribe = createSubscribe;
    exports.errorPrefix = errorPrefix;
    exports.validateArgCount = validateArgCount;
    exports.validateCallback = validateCallback;
    exports.validateContextObject = validateContextObject;
    exports.validateNamespace = validateNamespace;
    exports.stringLength = stringLength;
    exports.stringToByteArray = stringToByteArray$1;
  }, {
    tslib: 61
  } ],
  17: [ function(require, module, exports) {
    (function(global) {
      (function() {
        var g, goog = goog || {}, k = this;
        function l(a) {
          return "string" == typeof a;
        }
        function n(a, b) {
          a = a.split(".");
          b = b || k;
          for (var c = 0; c < a.length; c++) if (b = b[a[c]], null == b) return null;
          return b;
        }
        function aa() {}
        function ba(a) {
          var b = typeof a;
          if ("object" == b) {
            if (!a) return "null";
            if (a instanceof Array) return "array";
            if (a instanceof Object) return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c) return "object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
          } else if ("function" == b && "undefined" == typeof a.call) return "object";
          return b;
        }
        function p(a) {
          return "array" == ba(a);
        }
        function ca(a) {
          var b = ba(a);
          return "array" == b || "object" == b && "number" == typeof a.length;
        }
        function da(a) {
          return "function" == ba(a);
        }
        function ea(a) {
          var b = typeof a;
          return "object" == b && null != a || "function" == b;
        }
        var q = "closure_uid_" + (1e9 * Math.random() >>> 0), fa = 0;
        function ha(a, b, c) {
          return a.call.apply(a.bind, arguments);
        }
        function ia(a, b, c) {
          if (!a) throw Error();
          if (2 < arguments.length) {
            var d = Array.prototype.slice.call(arguments, 2);
            return function() {
              var c = Array.prototype.slice.call(arguments);
              Array.prototype.unshift.apply(c, d);
              return a.apply(b, c);
            };
          }
          return function() {
            return a.apply(b, arguments);
          };
        }
        function r(a, b, c) {
          r = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ha : ia;
          return r.apply(null, arguments);
        }
        function ja(a, b) {
          var c = Array.prototype.slice.call(arguments, 1);
          return function() {
            var b = c.slice();
            b.push.apply(b, arguments);
            return a.apply(this, b);
          };
        }
        var t = Date.now || function() {
          return +new Date();
        };
        function u(a, b) {
          function c() {}
          c.prototype = b.prototype;
          a.H = b.prototype;
          a.prototype = new c();
          a.prototype.constructor = a;
          a.Ib = function(a, c, f) {
            for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++) d[e - 2] = arguments[e];
            return b.prototype[c].apply(a, d);
          };
        }
        function ka(a) {
          if (Error.captureStackTrace) Error.captureStackTrace(this, ka); else {
            var b = Error().stack;
            b && (this.stack = b);
          }
          a && (this.message = String(a));
        }
        u(ka, Error);
        ka.prototype.name = "CustomError";
        function la(a, b) {
          a = a.split("%s");
          for (var c = "", d = a.length - 1, e = 0; e < d; e++) c += a[e] + (e < b.length ? b[e] : "%s");
          ka.call(this, c + a[d]);
        }
        u(la, ka);
        la.prototype.name = "AssertionError";
        function ma(a, b) {
          throw new la("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
        }
        function w() {
          0 != na && (pa[this[q] || (this[q] = ++fa)] = this);
          this.i = this.i;
          this.m = this.m;
        }
        var na = 0, pa = {};
        w.prototype.i = !1;
        w.prototype.$ = function() {
          if (!this.i && (this.i = !0, this.w(), 0 != na)) {
            var a = this[q] || (this[q] = ++fa);
            if (0 != na && this.m && 0 < this.m.length) throw Error(this + " did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.");
            delete pa[a];
          }
        };
        w.prototype.w = function() {
          if (this.m) for (;this.m.length; ) this.m.shift()();
        };
        var qa = Array.prototype.indexOf ? function(a, b) {
          return Array.prototype.indexOf.call(a, b, void 0);
        } : function(a, b) {
          if (l(a)) return l(b) && 1 == b.length ? a.indexOf(b, 0) : -1;
          for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c;
          return -1;
        }, ra = Array.prototype.forEach ? function(a, b, c) {
          Array.prototype.forEach.call(a, b, c);
        } : function(a, b, c) {
          for (var d = a.length, e = l(a) ? a.split("") : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
        };
        function sa(a) {
          a: {
            var b = ta;
            for (var c = a.length, d = l(a) ? a.split("") : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) {
              b = e;
              break a;
            }
            b = -1;
          }
          return 0 > b ? null : l(a) ? a.charAt(b) : a[b];
        }
        function ua(a) {
          if (!p(a)) for (var b = a.length - 1; 0 <= b; b--) delete a[b];
          a.length = 0;
        }
        function va(a) {
          return Array.prototype.concat.apply([], arguments);
        }
        function wa(a) {
          var b = a.length;
          if (0 < b) {
            for (var c = Array(b), d = 0; d < b; d++) c[d] = a[d];
            return c;
          }
          return [];
        }
        function xa(a) {
          return /^[\s\xa0]*$/.test(a);
        }
        var ya = String.prototype.trim ? function(a) {
          return a.trim();
        } : function(a) {
          return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
        };
        function za(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        var x;
        a: {
          var Aa = k.navigator;
          if (Aa) {
            var Ba = Aa.userAgent;
            if (Ba) {
              x = Ba;
              break a;
            }
          }
          x = "";
        }
        function y(a) {
          return -1 != x.indexOf(a);
        }
        function Ca(a, b, c) {
          for (var d in a) b.call(c, a[d], d, a);
        }
        function Da(a) {
          var b = [], c = 0, d;
          for (d in a) b[c++] = a[d];
          return b;
        }
        function Ea(a) {
          var b = [], c = 0, d;
          for (d in a) b[c++] = d;
          return b;
        }
        function Fa(a) {
          var b = {}, c;
          for (c in a) b[c] = a[c];
          return b;
        }
        var Ga = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
        function Ha(a, b) {
          for (var c, d, e = 1; e < arguments.length; e++) {
            d = arguments[e];
            for (c in d) a[c] = d[c];
            for (var f = 0; f < Ga.length; f++) c = Ga[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
          }
        }
        function Ia(a) {
          Ia[" "](a);
          return a;
        }
        Ia[" "] = aa;
        function Ja(a, b) {
          var c = Ka;
          return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
        }
        var La = y("Opera"), z = y("Trident") || y("MSIE"), Ma = y("Edge"), Na = Ma || z, Oa = y("Gecko") && !(-1 != x.toLowerCase().indexOf("webkit") && !y("Edge")) && !(y("Trident") || y("MSIE")) && !y("Edge"), Pa = -1 != x.toLowerCase().indexOf("webkit") && !y("Edge");
        function Qa() {
          var a = k.document;
          return a ? a.documentMode : void 0;
        }
        var Ra;
        a: {
          var Sa = "", Ta = function() {
            var a = x;
            if (Oa) return /rv:([^\);]+)(\)|;)/.exec(a);
            if (Ma) return /Edge\/([\d\.]+)/.exec(a);
            if (z) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
            if (Pa) return /WebKit\/(\S+)/.exec(a);
            if (La) return /(?:Version)[ \/]?(\S+)/.exec(a);
          }();
          Ta && (Sa = Ta ? Ta[1] : "");
          if (z) {
            var Ua = Qa();
            if (null != Ua && Ua > parseFloat(Sa)) {
              Ra = String(Ua);
              break a;
            }
          }
          Ra = Sa;
        }
        var Ka = {};
        function Va(a) {
          return Ja(a, function() {
            for (var b = 0, c = ya(String(Ra)).split("."), d = ya(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
              var h = c[f] || "", m = d[f] || "";
              do {
                h = /(\d*)(\D*)(.*)/.exec(h) || [ "", "", "", "" ];
                m = /(\d*)(\D*)(.*)/.exec(m) || [ "", "", "", "" ];
                if (0 == h[0].length && 0 == m[0].length) break;
                b = za(0 == h[1].length ? 0 : parseInt(h[1], 10), 0 == m[1].length ? 0 : parseInt(m[1], 10)) || za(0 == h[2].length, 0 == m[2].length) || za(h[2], m[2]);
                h = h[3];
                m = m[3];
              } while (0 == b);
            }
            return 0 <= b;
          });
        }
        var Wa;
        var Xa = k.document;
        Wa = Xa && z ? Qa() || ("CSS1Compat" == Xa.compatMode ? parseInt(Ra, 10) : 5) : void 0;
        var Ya = Object.freeze || function(a) {
          return a;
        };
        var Za = !z || 9 <= Number(Wa), $a = z && !Va("9"), ab = function() {
          if (!k.addEventListener || !Object.defineProperty) return !1;
          var a = !1, b = Object.defineProperty({}, "passive", {
            get: function() {
              a = !0;
            }
          });
          k.addEventListener("test", aa, b);
          k.removeEventListener("test", aa, b);
          return a;
        }();
        function A(a, b) {
          this.type = a;
          this.a = this.target = b;
          this.Ra = !0;
        }
        A.prototype.b = function() {
          this.Ra = !1;
        };
        function bb(a, b) {
          A.call(this, a ? a.type : "");
          this.relatedTarget = this.a = this.target = null;
          this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
          this.key = "";
          this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;
          this.pointerId = 0;
          this.pointerType = "";
          this.c = null;
          if (a) {
            var c = this.type = a.type, d = a.changedTouches ? a.changedTouches[0] : null;
            this.target = a.target || a.srcElement;
            this.a = b;
            if (b = a.relatedTarget) {
              if (Oa) {
                a: {
                  try {
                    Ia(b.nodeName);
                    var e = !0;
                    break a;
                  } catch (f) {}
                  e = !1;
                }
                e || (b = null);
              }
            } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);
            this.relatedTarget = b;
            null === d ? (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, 
            this.screenX = a.screenX || 0, this.screenY = a.screenY || 0) : (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, 
            this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, 
            this.screenY = d.screenY || 0);
            this.button = a.button;
            this.key = a.key || "";
            this.ctrlKey = a.ctrlKey;
            this.altKey = a.altKey;
            this.shiftKey = a.shiftKey;
            this.metaKey = a.metaKey;
            this.pointerId = a.pointerId || 0;
            this.pointerType = l(a.pointerType) ? a.pointerType : cb[a.pointerType] || "";
            this.c = a;
            a.defaultPrevented && this.b();
          }
        }
        u(bb, A);
        var cb = Ya({
          2: "touch",
          3: "pen",
          4: "mouse"
        });
        bb.prototype.b = function() {
          bb.H.b.call(this);
          var a = this.c;
          if (a.preventDefault) a.preventDefault(); else if (a.returnValue = !1, $a) try {
            (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) && (a.keyCode = -1);
          } catch (b) {}
        };
        var db = "closure_listenable_" + (1e6 * Math.random() | 0), eb = 0;
        function fb(a, b, c, d, e) {
          this.listener = a;
          this.proxy = null;
          this.src = b;
          this.type = c;
          this.capture = !!d;
          this.ga = e;
          this.key = ++eb;
          this.Z = this.ba = !1;
        }
        function gb(a) {
          a.Z = !0;
          a.listener = null;
          a.proxy = null;
          a.src = null;
          a.ga = null;
        }
        function hb(a) {
          this.src = a;
          this.a = {};
          this.b = 0;
        }
        hb.prototype.add = function(a, b, c, d, e) {
          var f = a.toString();
          a = this.a[f];
          a || (a = this.a[f] = [], this.b++);
          var h = ib(a, b, d, e);
          -1 < h ? (b = a[h], c || (b.ba = !1)) : (b = new fb(b, this.src, f, !!d, e), b.ba = c, 
          a.push(b));
          return b;
        };
        function jb(a, b) {
          var c = b.type;
          if (c in a.a) {
            var d = a.a[c], e = qa(d, b), f;
            (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
            f && (gb(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
          }
        }
        function ib(a, b, c, d) {
          for (var e = 0; e < a.length; ++e) {
            var f = a[e];
            if (!f.Z && f.listener == b && f.capture == !!c && f.ga == d) return e;
          }
          return -1;
        }
        var kb = "closure_lm_" + (1e6 * Math.random() | 0), lb = {}, mb = 0;
        function nb(a, b, c, d, e) {
          if (d && d.once) return ob(a, b, c, d, e);
          if (p(b)) {
            for (var f = 0; f < b.length; f++) nb(a, b[f], c, d, e);
            return null;
          }
          c = pb(c);
          return a && a[db] ? a.Ia(b, c, ea(d) ? !!d.capture : !!d, e) : qb(a, b, c, !1, d, e);
        }
        function qb(a, b, c, d, e, f) {
          if (!b) throw Error("Invalid event type");
          var h = ea(e) ? !!e.capture : !!e, m = rb(a);
          m || (a[kb] = m = new hb(a));
          c = m.add(b, c, d, h, f);
          if (c.proxy) return c;
          d = sb();
          c.proxy = d;
          d.src = a;
          d.listener = c;
          if (a.addEventListener) ab || (e = h), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e); else if (a.attachEvent) a.attachEvent(tb(b.toString()), d); else {
            if (!a.addListener || !a.removeListener) throw Error("addEventListener and attachEvent are unavailable.");
            a.addListener(d);
          }
          mb++;
          return c;
        }
        function sb() {
          var a = ub, b = Za ? function(c) {
            return a.call(b.src, b.listener, c);
          } : function(c) {
            c = a.call(b.src, b.listener, c);
            if (!c) return c;
          };
          return b;
        }
        function ob(a, b, c, d, e) {
          if (p(b)) {
            for (var f = 0; f < b.length; f++) ob(a, b[f], c, d, e);
            return null;
          }
          c = pb(c);
          return a && a[db] ? a.Ja(b, c, ea(d) ? !!d.capture : !!d, e) : qb(a, b, c, !0, d, e);
        }
        function vb(a, b, c, d, e) {
          if (p(b)) for (var f = 0; f < b.length; f++) vb(a, b[f], c, d, e); else d = ea(d) ? !!d.capture : !!d, 
          c = pb(c), a && a[db] ? (a = a.f, b = String(b).toString(), b in a.a && (f = a.a[b], 
          c = ib(f, c, d, e), -1 < c && (gb(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], 
          a.b--)))) : a && (a = rb(a)) && (b = a.a[b.toString()], a = -1, b && (a = ib(b, c, d, e)), 
          (c = -1 < a ? b[a] : null) && wb(c));
        }
        function wb(a) {
          if ("number" != typeof a && a && !a.Z) {
            var b = a.src;
            if (b && b[db]) jb(b.f, a); else {
              var c = a.type, d = a.proxy;
              b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(tb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
              mb--;
              (c = rb(b)) ? (jb(c, a), 0 == c.b && (c.src = null, b[kb] = null)) : gb(a);
            }
          }
        }
        function tb(a) {
          return a in lb ? lb[a] : lb[a] = "on" + a;
        }
        function xb(a, b, c, d) {
          var e = !0;
          if ((a = rb(a)) && (b = a.a[b.toString()])) for (b = b.concat(), a = 0; a < b.length; a++) {
            var f = b[a];
            f && f.capture == c && !f.Z && (f = yb(f, d), e = e && !1 !== f);
          }
          return e;
        }
        function yb(a, b) {
          var c = a.listener, d = a.ga || a.src;
          a.ba && wb(a);
          return c.call(d, b);
        }
        function ub(a, b) {
          if (a.Z) return !0;
          if (!Za) {
            var c = b || n("window.event");
            b = new bb(c, this);
            var d = !0;
            if (!(0 > c.keyCode || void 0 != c.returnValue)) {
              a: {
                var e = !1;
                if (0 == c.keyCode) try {
                  c.keyCode = -1;
                  break a;
                } catch (h) {
                  e = !0;
                }
                (e || void 0 == c.returnValue) && (c.returnValue = !0);
              }
              c = [];
              for (e = b.a; e; e = e.parentNode) c.push(e);
              a = a.type;
              for (e = c.length - 1; 0 <= e; e--) {
                b.a = c[e];
                var f = xb(c[e], a, !0, b);
                d = d && f;
              }
              for (e = 0; e < c.length; e++) b.a = c[e], f = xb(c[e], a, !1, b), d = d && f;
            }
            return d;
          }
          return yb(a, new bb(b, this));
        }
        function rb(a) {
          a = a[kb];
          return a instanceof hb ? a : null;
        }
        var zb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
        function pb(a) {
          if (da(a)) return a;
          a[zb] || (a[zb] = function(b) {
            return a.handleEvent(b);
          });
          return a[zb];
        }
        function B() {
          w.call(this);
          this.f = new hb(this);
          this.N = this;
          this.J = null;
        }
        u(B, w);
        B.prototype[db] = !0;
        g = B.prototype;
        g.addEventListener = function(a, b, c, d) {
          nb(this, a, b, c, d);
        };
        g.removeEventListener = function(a, b, c, d) {
          vb(this, a, b, c, d);
        };
        g.dispatchEvent = function(a) {
          var b, c = this.J;
          if (c) for (b = []; c; c = c.J) b.push(c);
          c = this.N;
          var d = a.type || a;
          if (l(a)) a = new A(a, c); else if (a instanceof A) a.target = a.target || c; else {
            var e = a;
            a = new A(d, c);
            Ha(a, e);
          }
          e = !0;
          if (b) for (var f = b.length - 1; 0 <= f; f--) {
            var h = a.a = b[f];
            e = Ab(h, d, !0, a) && e;
          }
          h = a.a = c;
          e = Ab(h, d, !0, a) && e;
          e = Ab(h, d, !1, a) && e;
          if (b) for (f = 0; f < b.length; f++) h = a.a = b[f], e = Ab(h, d, !1, a) && e;
          return e;
        };
        g.w = function() {
          B.H.w.call(this);
          if (this.f) {
            var a = this.f, b = 0, c;
            for (c in a.a) {
              for (var d = a.a[c], e = 0; e < d.length; e++) ++b, gb(d[e]);
              delete a.a[c];
              a.b--;
            }
          }
          this.J = null;
        };
        g.Ia = function(a, b, c, d) {
          return this.f.add(String(a), b, !1, c, d);
        };
        g.Ja = function(a, b, c, d) {
          return this.f.add(String(a), b, !0, c, d);
        };
        function Ab(a, b, c, d) {
          b = a.f.a[String(b)];
          if (!b) return !0;
          b = b.concat();
          for (var e = !0, f = 0; f < b.length; ++f) {
            var h = b[f];
            if (h && !h.Z && h.capture == c) {
              var m = h.listener, v = h.ga || h.src;
              h.ba && jb(a.f, h);
              e = !1 !== m.call(v, d) && e;
            }
          }
          return e && 0 != d.Ra;
        }
        function Bb(a) {
          return !/^\s*$/.test(a) && /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/(?:"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)[\s\u2028\u2029]*(?=:|,|]|}|$)/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""));
        }
        function Cb(a) {
          a = String(a);
          if (Bb(a)) try {
            return eval("(" + a + ")");
          } catch (b) {}
          throw Error("Invalid JSON string: " + a);
        }
        function Db(a) {
          var b = [];
          Eb(new Fb(), a, b);
          return b.join("");
        }
        function Fb() {}
        function Eb(a, b, c) {
          if (null == b) c.push("null"); else {
            if ("object" == typeof b) {
              if (p(b)) {
                var d = b;
                b = d.length;
                c.push("[");
                for (var e = "", f = 0; f < b; f++) c.push(e), Eb(a, d[f], c), e = ",";
                c.push("]");
                return;
              }
              if (!(b instanceof String || b instanceof Number || b instanceof Boolean)) {
                c.push("{");
                e = "";
                for (d in b) Object.prototype.hasOwnProperty.call(b, d) && (f = b[d], "function" != typeof f && (c.push(e), 
                Gb(d, c), c.push(":"), Eb(a, f, c), e = ","));
                c.push("}");
                return;
              }
              b = b.valueOf();
            }
            switch (typeof b) {
             case "string":
              Gb(b, c);
              break;

             case "number":
              c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");
              break;

             case "boolean":
              c.push(String(b));
              break;

             case "function":
              c.push("null");
              break;

             default:
              throw Error("Unknown type: " + typeof b);
            }
          }
        }
        var Hb = {
          '"': '\\"',
          "\\": "\\\\",
          "/": "\\/",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "\t": "\\t",
          "\v": "\\u000b"
        }, Ib = /\uffff/.test("") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
        function Gb(a, b) {
          b.push('"', a.replace(Ib, function(a) {
            var b = Hb[a];
            b || (b = "\\u" + (65536 | a.charCodeAt(0)).toString(16).substr(1), Hb[a] = b);
            return b;
          }), '"');
        }
        function Jb(a, b) {
          this.c = a;
          this.f = b;
          this.b = 0;
          this.a = null;
        }
        Jb.prototype.get = function() {
          if (0 < this.b) {
            this.b--;
            var a = this.a;
            this.a = a.next;
            a.next = null;
          } else a = this.c();
          return a;
        };
        function Kb() {
          this.b = this.a = null;
        }
        var Nb = new Jb(function() {
          return new Lb();
        }, function(a) {
          a.reset();
        });
        Kb.prototype.add = function(a, b) {
          var c = Nb.get();
          c.set(a, b);
          this.b ? this.b.next = c : this.a = c;
          this.b = c;
        };
        function Ob() {
          var a = Pb, b = null;
          a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);
          return b;
        }
        function Lb() {
          this.next = this.b = this.a = null;
        }
        Lb.prototype.set = function(a, b) {
          this.a = a;
          this.b = b;
          this.next = null;
        };
        Lb.prototype.reset = function() {
          this.next = this.b = this.a = null;
        };
        function Qb(a) {
          k.setTimeout(function() {
            throw a;
          }, 0);
        }
        var Rb;
        function Sb() {
          var a = k.MessageChannel;
          "undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !y("Presto") && (a = function() {
            var a = document.createElement("IFRAME");
            a.style.display = "none";
            a.src = "";
            document.documentElement.appendChild(a);
            var b = a.contentWindow;
            a = b.document;
            a.open();
            a.write("");
            a.close();
            var c = "callImmediate" + Math.random(), d = "file:" == b.location.protocol ? "*" : b.location.protocol + "//" + b.location.host;
            a = r(function(a) {
              "*" != d && a.origin != d || a.data != c || this.port1.onmessage();
            }, this);
            b.addEventListener("message", a, !1);
            this.port1 = {};
            this.port2 = {
              postMessage: function() {
                b.postMessage(c, d);
              }
            };
          });
          if ("undefined" !== typeof a && !y("Trident") && !y("MSIE")) {
            var b = new a(), c = {}, d = c;
            b.port1.onmessage = function() {
              if (void 0 !== c.next) {
                c = c.next;
                var a = c.za;
                c.za = null;
                a();
              }
            };
            return function(a) {
              d.next = {
                za: a
              };
              d = d.next;
              b.port2.postMessage(0);
            };
          }
          return "undefined" !== typeof document && "onreadystatechange" in document.createElement("SCRIPT") ? function(a) {
            var b = document.createElement("SCRIPT");
            b.onreadystatechange = function() {
              b.onreadystatechange = null;
              b.parentNode.removeChild(b);
              b = null;
              a();
              a = null;
            };
            document.documentElement.appendChild(b);
          } : function(a) {
            k.setTimeout(a, 0);
          };
        }
        var Tb;
        function Ub() {
          if (-1 != String(k.Promise).indexOf("[native code]")) {
            var a = k.Promise.resolve(void 0);
            Tb = function() {
              a.then(Vb);
            };
          } else Tb = function() {
            var a = Vb;
            !da(k.setImmediate) || k.Window && k.Window.prototype && !y("Edge") && k.Window.prototype.setImmediate == k.setImmediate ? (Rb || (Rb = Sb()), 
            Rb(a)) : k.setImmediate(a);
          };
        }
        var Wb = !1, Pb = new Kb();
        function Vb() {
          for (var a; a = Ob(); ) {
            try {
              a.a.call(a.b);
            } catch (c) {
              Qb(c);
            }
            var b = Nb;
            b.f(a);
            100 > b.b && (b.b++, a.next = b.a, b.a = a);
          }
          Wb = !1;
        }
        function Xb(a, b) {
          B.call(this);
          this.b = a || 1;
          this.a = b || k;
          this.c = r(this.qb, this);
          this.g = t();
        }
        u(Xb, B);
        g = Xb.prototype;
        g.ea = !1;
        g.O = null;
        g.qb = function() {
          if (this.ea) {
            var a = t() - this.g;
            0 < a && a < .8 * this.b ? this.O = this.a.setTimeout(this.c, this.b - a) : (this.O && (this.a.clearTimeout(this.O), 
            this.O = null), this.dispatchEvent("tick"), this.ea && (this.O = this.a.setTimeout(this.c, this.b), 
            this.g = t()));
          }
        };
        g.start = function() {
          this.ea = !0;
          this.O || (this.O = this.a.setTimeout(this.c, this.b), this.g = t());
        };
        function Yb(a) {
          a.ea = !1;
          a.O && (a.a.clearTimeout(a.O), a.O = null);
        }
        g.w = function() {
          Xb.H.w.call(this);
          Yb(this);
          delete this.a;
        };
        function Zb(a, b, c) {
          if (da(a)) c && (a = r(a, c)); else {
            if (!a || "function" != typeof a.handleEvent) throw Error("Invalid listener argument");
            a = r(a.handleEvent, a);
          }
          return 2147483647 < Number(b) ? -1 : k.setTimeout(a, b || 0);
        }
        function $b(a, b, c) {
          w.call(this);
          this.f = null != c ? r(a, c) : a;
          this.c = b;
          this.b = r(this.kb, this);
          this.a = [];
        }
        u($b, w);
        g = $b.prototype;
        g.ha = !1;
        g.Y = null;
        g.cb = function(a) {
          this.a = arguments;
          this.Y ? this.ha = !0 : ac(this);
        };
        g.w = function() {
          $b.H.w.call(this);
          this.Y && (k.clearTimeout(this.Y), this.Y = null, this.ha = !1, this.a = []);
        };
        g.kb = function() {
          this.Y = null;
          this.ha && (this.ha = !1, ac(this));
        };
        function ac(a) {
          a.Y = Zb(a.b, a.c);
          a.f.apply(null, a.a);
        }
        function bc(a) {
          w.call(this);
          this.b = a;
          this.a = {};
        }
        u(bc, w);
        var cc = [];
        function dc(a, b, c, d) {
          p(c) || (c && (cc[0] = c.toString()), c = cc);
          for (var e = 0; e < c.length; e++) {
            var f = nb(b, c[e], d || a.handleEvent, !1, a.b || a);
            if (!f) break;
            a.a[f.key] = f;
          }
        }
        function ec(a) {
          Ca(a.a, function(a, c) {
            this.a.hasOwnProperty(c) && wb(a);
          }, a);
          a.a = {};
        }
        bc.prototype.w = function() {
          bc.H.w.call(this);
          ec(this);
        };
        bc.prototype.handleEvent = function() {
          throw Error("EventHandler.handleEvent not implemented");
        };
        function fc(a, b, c) {
          this.reset(a, b, c, void 0, void 0);
        }
        fc.prototype.a = null;
        var gc = 0;
        fc.prototype.reset = function(a, b, c, d, e) {
          "number" == typeof e || gc++;
          d || t();
          delete this.a;
        };
        function hc(a) {
          this.f = a;
          this.b = this.c = this.a = null;
        }
        function C(a, b) {
          this.name = a;
          this.value = b;
        }
        C.prototype.toString = function() {
          return this.name;
        };
        var ic = new C("SEVERE", 1e3), jc = new C("WARNING", 900), kc = new C("INFO", 800), lc = new C("CONFIG", 700), mc = new C("FINE", 500);
        function nc(a) {
          if (a.c) return a.c;
          if (a.a) return nc(a.a);
          ma("Root logger has no level set.");
          return null;
        }
        hc.prototype.log = function(a, b, c) {
          if (a.value >= nc(this).value) for (da(b) && (b = b()), a = new fc(a, String(b), this.f), 
          c && (a.a = c), c = this; c; ) c = c.a;
        };
        var oc = {}, pc = null;
        function qc(a) {
          pc || (pc = new hc(""), oc[""] = pc, pc.c = lc);
          var b;
          if (!(b = oc[a])) {
            b = new hc(a);
            var c = a.lastIndexOf("."), d = a.substr(c + 1);
            c = qc(a.substr(0, c));
            c.b || (c.b = {});
            c.b[d] = b;
            b.a = c;
            oc[a] = b;
          }
          return b;
        }
        function D(a, b) {
          a && a.log(jc, b, void 0);
        }
        function rc(a, b) {
          a && a.log(kc, b, void 0);
        }
        function E(a, b) {
          a && a.log(mc, b, void 0);
        }
        function sc() {
          this.a = qc("goog.labs.net.webChannel.WebChannelDebug");
          this.b = !0;
        }
        sc.prototype.Fa = function() {
          this.b = !1;
        };
        function tc(a, b, c, d, e, f) {
          F(a, function() {
            if (a.b) if (f) {
              var h = "";
              for (var m = f.split("&"), v = 0; v < m.length; v++) {
                var I = m[v].split("=");
                if (1 < I.length) {
                  var X = I[0];
                  I = I[1];
                  var Mb = X.split("_");
                  h = 2 <= Mb.length && "type" == Mb[1] ? h + (X + "=") + I + "&" : h + (X + "=redacted&");
                }
              }
            } else h = null; else h = f;
            return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
          });
        }
        function uc(a, b, c, d, e, f, h) {
          F(a, function() {
            return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
          });
        }
        function G(a, b, c, d) {
          F(a, function() {
            return "XMLHTTP TEXT (" + b + "): " + vc(a, c) + (d ? " " + d : "");
          });
        }
        function wc(a, b) {
          F(a, function() {
            return "TIMEOUT: " + b;
          });
        }
        function H(a, b) {
          E(a.a, b);
        }
        function xc(a, b, c) {
          (a = a.a) && a.log(ic, c || "Exception", b);
        }
        function F(a, b) {
          rc(a.a, b);
        }
        function J(a, b) {
          (a = a.a) && a.log(ic, b, void 0);
        }
        function vc(a, b) {
          if (!a.b) return b;
          if (!b) return null;
          try {
            var c = JSON.parse(b);
            if (c) for (var d = 0; d < c.length; d++) if (p(c[d])) {
              var e = c[d];
              if (!(2 > e.length)) {
                var f = e[1];
                if (p(f) && !(1 > f.length)) {
                  var h = f[0];
                  if ("noop" != h && "stop" != h && "close" != h) for (var m = 1; m < f.length; m++) f[m] = "";
                }
              }
            }
            return Db(c);
          } catch (v) {
            return H(a, "Exception parsing expected JS array - probably was not JS"), b;
          }
        }
        var yc = new B();
        function zc(a) {
          A.call(this, "serverreachability", a);
        }
        u(zc, A);
        function Ac(a) {
          yc.dispatchEvent(new zc(yc, a));
        }
        function Bc(a) {
          A.call(this, "statevent", a);
        }
        u(Bc, A);
        function K(a) {
          yc.dispatchEvent(new Bc(yc, a));
        }
        function Cc(a) {
          A.call(this, "timingevent", a);
        }
        u(Cc, A);
        function Dc(a, b, c) {
          yc.dispatchEvent(new Cc(yc, a, b, c));
        }
        function Ec(a, b) {
          if (!da(a)) throw Error("Fn must not be null and must be a function");
          return k.setTimeout(function() {
            a();
          }, b);
        }
        var Fc = {
          NO_ERROR: 0,
          rb: 1,
          yb: 2,
          xb: 3,
          ub: 4,
          wb: 5,
          zb: 6,
          Ua: 7,
          TIMEOUT: 8,
          Cb: 9
        };
        var Gc = {
          tb: "complete",
          Gb: "success",
          Va: "error",
          Ua: "abort",
          Eb: "ready",
          Fb: "readystatechange",
          TIMEOUT: "timeout",
          Ab: "incrementaldata",
          Db: "progress",
          vb: "downloadprogress",
          Hb: "uploadprogress"
        };
        function Hc() {}
        Hc.prototype.a = null;
        function Ic(a) {
          var b;
          (b = a.a) || (b = {}, Jc(a) && (b[0] = !0, b[1] = !0), b = a.a = b);
          return b;
        }
        function Kc() {}
        var Lc = {
          OPEN: "a",
          sb: "b",
          Va: "c",
          Bb: "d"
        };
        function Mc() {
          A.call(this, "d");
        }
        u(Mc, A);
        function Nc() {
          A.call(this, "c");
        }
        u(Nc, A);
        var Oc;
        function Pc() {}
        u(Pc, Hc);
        function Qc(a) {
          return (a = Jc(a)) ? new ActiveXObject(a) : new XMLHttpRequest();
        }
        function Jc(a) {
          if (!a.b && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
            for (var b = [ "MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ], c = 0; c < b.length; c++) {
              var d = b[c];
              try {
                return new ActiveXObject(d), a.b = d;
              } catch (e) {}
            }
            throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
          }
          return a.b;
        }
        Oc = new Pc();
        function L(a, b, c, d) {
          this.i = a;
          this.b = b;
          this.c = c;
          this.T = d || 1;
          this.L = new bc(this);
          this.R = Rc;
          a = Na ? 125 : void 0;
          this.S = new Xb(a);
          this.j = null;
          this.f = !1;
          this.l = this.g = this.h = this.J = this.D = this.U = this.s = null;
          this.u = [];
          this.a = null;
          this.G = 0;
          this.m = this.o = null;
          this.C = -1;
          this.B = !1;
          this.N = 0;
          this.I = null;
          this.v = this.X = this.K = !1;
        }
        var Rc = 45e3;
        function Sc(a, b) {
          switch (a) {
           case 0:
            return "Non-200 return code (" + b + ")";

           case 1:
            return "XMLHTTP failure (no data)";

           case 2:
            return "HttpConnection timeout";

           default:
            return "Unknown error";
          }
        }
        var Tc = {}, Uc = {};
        g = L.prototype;
        g.setTimeout = function(a) {
          this.R = a;
        };
        function Vc(a, b, c) {
          a.J = 1;
          a.h = Wc(M(b));
          a.l = c;
          a.K = !0;
          Xc(a, null);
        }
        function Yc(a, b, c, d) {
          a.J = 1;
          a.h = Wc(M(b));
          a.l = null;
          a.K = c;
          Xc(a, d);
        }
        function Xc(a, b) {
          a.D = t();
          Zc(a);
          a.g = M(a.h);
          $c(a.g, "t", a.T);
          a.G = 0;
          a.a = a.i.ca(a.i.ia() ? b : null);
          0 < a.N && (a.I = new $b(r(a.Sa, a, a.a), a.N));
          dc(a.L, a.a, "readystatechange", a.nb);
          b = a.j ? Fa(a.j) : {};
          a.l ? (a.o || (a.o = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", 
          a.a.fa(a.g, a.o, a.l, b)) : (a.o = "GET", a.a.fa(a.g, a.o, null, b));
          Ac(1);
          tc(a.b, a.o, a.g, a.c, a.T, a.l);
        }
        g.nb = function(a) {
          a = a.target;
          var b = this.I;
          b && 3 == N(a) ? (H(this.b, "Throttling readystatechange."), b.cb()) : this.Sa(a);
        };
        g.Sa = function(a) {
          try {
            a == this.a ? ad(this) : D(this.b.a, "Called back with an unexpected xmlhttp");
          } catch (c) {
            if (H(this.b, "Failed call to OnXmlHttpReadyStateChanged_"), this.a && this.a.V()) {
              var b = this;
              xc(this.b, c, function() {
                return "ResponseText: " + b.a.V();
              });
            } else xc(this.b, c, "No response text");
          }
        };
        function ad(a) {
          var b = N(a.a), c = a.a.Ga(), d = a.a.W();
          if (!(3 > b || 3 == b && !Na && !a.a.V())) {
            a.B || 4 != b || 7 == c || Ac(8 == c || 0 >= d ? 3 : 2);
            bd(a);
            var e = a.a.W();
            a.C = e;
            (c = a.a.V()) || H(a.b, function() {
              return "No response text for uri " + a.g + " status " + e;
            });
            a.f = 200 == e;
            uc(a.b, a.o, a.g, a.c, a.T, b, e);
            if (a.f) {
              (d = cd(a)) && (G(a.b, a.c, d, "Initial handshake response via X-HTTP-Initial-Response"), 
              a.v = !0, dd(a, d));
              a.K ? (ed(a, b, c), Na && a.f && 3 == b && fd(a)) : (G(a.b, a.c, c, null), dd(a, c));
              4 == b && gd(a);
              a.f && !a.B && (4 == b ? a.i.ta(a) : (a.f = !1, Zc(a)));
            } else 400 == e && 0 < c.indexOf("Unknown SID") ? (a.m = 3, K(12), D(a.b.a, "XMLHTTP Unknown SID (" + a.c + ")")) : (a.m = 0, 
            K(13), D(a.b.a, "XMLHTTP Bad status " + e + " (" + a.c + ")")), gd(a), hd(a);
          }
        }
        function cd(a) {
          return !a.X || a.v ? null : a.a && (a = id(a.a, "X-HTTP-Initial-Response")) && !xa(a) ? a : null;
        }
        function ed(a, b, c) {
          for (var d = !0; !a.B && a.G < c.length; ) {
            var e = jd(a, c);
            if (e == Uc) {
              4 == b && (a.m = 4, K(14), d = !1);
              G(a.b, a.c, null, "[Incomplete Response]");
              break;
            }
            if (e == Tc) {
              a.m = 4;
              K(15);
              G(a.b, a.c, c, "[Invalid Chunk]");
              d = !1;
              break;
            }
            G(a.b, a.c, e, null), dd(a, e);
          }
          4 == b && 0 == c.length && (a.m = 1, K(16), d = !1);
          a.f = a.f && d;
          d || (G(a.b, a.c, c, "[Invalid Chunked Response]"), gd(a), hd(a));
        }
        g.mb = function() {
          if (this.a) {
            var a = N(this.a), b = this.a.V();
            this.G < b.length && (bd(this), ed(this, a, b), this.f && 4 != a && Zc(this));
          }
        };
        function fd(a) {
          dc(a.L, a.S, "tick", a.mb);
          a.S.start();
        }
        function jd(a, b) {
          var c = a.G, d = b.indexOf("\n", c);
          if (-1 == d) return Uc;
          c = Number(b.substring(c, d));
          if (isNaN(c)) return Tc;
          d += 1;
          if (d + c > b.length) return Uc;
          b = b.substr(d, c);
          a.G = d + c;
          return b;
        }
        g.cancel = function() {
          this.B = !0;
          gd(this);
        };
        function Zc(a) {
          a.U = t() + a.R;
          kd(a, a.R);
        }
        function kd(a, b) {
          if (null != a.s) throw Error("WatchDog timer not null");
          a.s = Ec(r(a.lb, a), b);
        }
        function bd(a) {
          a.s && (k.clearTimeout(a.s), a.s = null);
        }
        g.lb = function() {
          this.s = null;
          var a = t();
          0 <= a - this.U ? (this.f && J(this.b, "Received watchdog timeout even though request loaded successfully"), 
          wc(this.b, this.g), 2 != this.J && (Ac(3), K(17)), gd(this), this.m = 2, hd(this)) : (D(this.b.a, "WatchDog timer called too early"), 
          kd(this, this.U - a));
        };
        function hd(a) {
          a.i.La() || a.B || a.i.ta(a);
        }
        function gd(a) {
          bd(a);
          var b = a.I;
          b && "function" == typeof b.$ && b.$();
          a.I = null;
          Yb(a.S);
          ec(a.L);
          a.a && (b = a.a, a.a = null, b.abort(), b.$());
        }
        function dd(a, b) {
          try {
            a.i.Oa(a, b), Ac(4);
          } catch (c) {
            xc(a.b, c, "Error in httprequest callback");
          }
        }
        function ld(a) {
          if (a.A && "function" == typeof a.A) return a.A();
          if (l(a)) return a.split("");
          if (ca(a)) {
            for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);
            return b;
          }
          return Da(a);
        }
        function md(a, b) {
          if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0); else if (ca(a) || l(a)) ra(a, b, void 0); else {
            if (a.M && "function" == typeof a.M) var c = a.M(); else if (a.A && "function" == typeof a.A) c = void 0; else if (ca(a) || l(a)) {
              c = [];
              for (var d = a.length, e = 0; e < d; e++) c.push(e);
            } else c = Ea(a);
            d = ld(a);
            e = d.length;
            for (var f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
          }
        }
        function O(a, b) {
          this.b = {};
          this.a = [];
          this.c = 0;
          var c = arguments.length;
          if (1 < c) {
            if (c % 2) throw Error("Uneven number of arguments");
            for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1]);
          } else if (a) if (a instanceof O) for (c = a.M(), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d])); else for (d in a) this.set(d, a[d]);
        }
        g = O.prototype;
        g.A = function() {
          nd(this);
          for (var a = [], b = 0; b < this.a.length; b++) a.push(this.b[this.a[b]]);
          return a;
        };
        g.M = function() {
          nd(this);
          return this.a.concat();
        };
        function od(a) {
          a.b = {};
          a.a.length = 0;
          a.c = 0;
        }
        function pd(a, b) {
          return !!P(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && nd(a), !0);
        }
        function nd(a) {
          if (a.c != a.a.length) {
            for (var b = 0, c = 0; b < a.a.length; ) {
              var d = a.a[b];
              P(a.b, d) && (a.a[c++] = d);
              b++;
            }
            a.a.length = c;
          }
          if (a.c != a.a.length) {
            var e = {};
            for (c = b = 0; b < a.a.length; ) d = a.a[b], P(e, d) || (a.a[c++] = d, e[d] = 1), 
            b++;
            a.a.length = c;
          }
        }
        g.get = function(a, b) {
          return P(this.b, a) ? this.b[a] : b;
        };
        g.set = function(a, b) {
          P(this.b, a) || (this.c++, this.a.push(a));
          this.b[a] = b;
        };
        g.forEach = function(a, b) {
          for (var c = this.M(), d = 0; d < c.length; d++) {
            var e = c[d], f = this.get(e);
            a.call(b, f, e, this);
          }
        };
        function P(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        var qd = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
        function rd(a, b) {
          if (a) {
            a = a.split("&");
            for (var c = 0; c < a.length; c++) {
              var d = a[c].indexOf("="), e = null;
              if (0 <= d) {
                var f = a[c].substring(0, d);
                e = a[c].substring(d + 1);
              } else f = a[c];
              b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
            }
          }
        }
        function Q(a, b) {
          this.b = this.j = this.f = "";
          this.i = null;
          this.g = this.a = "";
          this.h = !1;
          var c;
          a instanceof Q ? (this.h = void 0 !== b ? b : a.h, sd(this, a.f), this.j = a.j, 
          td(this, a.b), ud(this, a.i), this.a = a.a, vd(this, wd(a.c)), this.g = a.g) : a && (c = String(a).match(qd)) ? (this.h = !!b, 
          sd(this, c[1] || "", !0), this.j = xd(c[2] || ""), td(this, c[3] || "", !0), ud(this, c[4]), 
          this.a = xd(c[5] || "", !0), vd(this, c[6] || "", !0), this.g = xd(c[7] || "")) : (this.h = !!b, 
          this.c = new yd(null, this.h));
        }
        Q.prototype.toString = function() {
          var a = [], b = this.f;
          b && a.push(zd(b, Ad, !0), ":");
          var c = this.b;
          (c || "file" == b) && (a.push("//"), (b = this.j) && a.push(zd(b, Ad, !0), "@"), 
          a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.i, 
          null != c && a.push(":", String(c)));
          (c = this.a) && (this.b && "/" != c.charAt(0) && a.push("/"), a.push(zd(c, "/" == c.charAt(0) ? Bd : Cd, !0)));
          (c = this.c.toString()) && a.push("?", c);
          (c = this.g) && a.push("#", zd(c, Dd));
          return a.join("");
        };
        Q.prototype.resolve = function(a) {
          var b = M(this), c = !!a.f;
          c ? sd(b, a.f) : c = !!a.j;
          c ? b.j = a.j : c = !!a.b;
          c ? td(b, a.b) : c = null != a.i;
          var d = a.a;
          if (c) ud(b, a.i); else if (c = !!a.a) {
            if ("/" != d.charAt(0)) if (this.b && !this.a) d = "/" + d; else {
              var e = b.a.lastIndexOf("/");
              -1 != e && (d = b.a.substr(0, e + 1) + d);
            }
            e = d;
            if (".." == e || "." == e) d = ""; else if (-1 != e.indexOf("./") || -1 != e.indexOf("/.")) {
              d = 0 == e.lastIndexOf("/", 0);
              e = e.split("/");
              for (var f = [], h = 0; h < e.length; ) {
                var m = e[h++];
                "." == m ? d && h == e.length && f.push("") : ".." == m ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), 
                d && h == e.length && f.push("")) : (f.push(m), d = !0);
              }
              d = f.join("/");
            } else d = e;
          }
          c ? b.a = d : c = "" !== a.c.toString();
          c ? vd(b, wd(a.c)) : c = !!a.g;
          c && (b.g = a.g);
          return b;
        };
        function M(a) {
          return new Q(a);
        }
        function sd(a, b, c) {
          a.f = c ? xd(b, !0) : b;
          a.f && (a.f = a.f.replace(/:$/, ""));
        }
        function td(a, b, c) {
          a.b = c ? xd(b, !0) : b;
        }
        function ud(a, b) {
          if (b) {
            b = Number(b);
            if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);
            a.i = b;
          } else a.i = null;
        }
        function vd(a, b, c) {
          b instanceof yd ? (a.c = b, Ed(a.c, a.h)) : (c || (b = zd(b, Fd)), a.c = new yd(b, a.h));
        }
        function R(a, b, c) {
          a.c.set(b, c);
        }
        function $c(a, b, c) {
          p(c) || (c = [ String(c) ]);
          Gd(a.c, b, c);
        }
        function Wc(a) {
          R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ t()).toString(36));
          return a;
        }
        function Hd(a) {
          return a instanceof Q ? M(a) : new Q(a, void 0);
        }
        function Id(a, b, c, d) {
          var e = new Q(null, void 0);
          a && sd(e, a);
          b && td(e, b);
          c && ud(e, c);
          d && (e.a = d);
          return e;
        }
        function xd(a, b) {
          return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
        }
        function zd(a, b, c) {
          return l(a) ? (a = encodeURI(a).replace(b, Jd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), 
          a) : null;
        }
        function Jd(a) {
          a = a.charCodeAt(0);
          return "%" + (a >> 4 & 15).toString(16) + (15 & a).toString(16);
        }
        var Ad = /[#\/\?@]/g, Cd = /[#\?:]/g, Bd = /[#\?]/g, Fd = /[#\?@]/g, Dd = /#/g;
        function yd(a, b) {
          this.b = this.a = null;
          this.c = a || null;
          this.f = !!b;
        }
        function S(a) {
          a.a || (a.a = new O(), a.b = 0, a.c && rd(a.c, function(b, c) {
            a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
          }));
        }
        g = yd.prototype;
        g.add = function(a, b) {
          S(this);
          this.c = null;
          a = Kd(this, a);
          var c = this.a.get(a);
          c || this.a.set(a, c = []);
          c.push(b);
          this.b += 1;
          return this;
        };
        function Ld(a, b) {
          S(a);
          b = Kd(a, b);
          P(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, pd(a.a, b));
        }
        function Md(a, b) {
          S(a);
          b = Kd(a, b);
          return P(a.a.b, b);
        }
        g.forEach = function(a, b) {
          S(this);
          this.a.forEach(function(c, d) {
            ra(c, function(c) {
              a.call(b, c, d, this);
            }, this);
          }, this);
        };
        g.M = function() {
          S(this);
          for (var a = this.a.A(), b = this.a.M(), c = [], d = 0; d < b.length; d++) for (var e = a[d], f = 0; f < e.length; f++) c.push(b[d]);
          return c;
        };
        g.A = function(a) {
          S(this);
          var b = [];
          if (l(a)) Md(this, a) && (b = va(b, this.a.get(Kd(this, a)))); else {
            a = this.a.A();
            for (var c = 0; c < a.length; c++) b = va(b, a[c]);
          }
          return b;
        };
        g.set = function(a, b) {
          S(this);
          this.c = null;
          a = Kd(this, a);
          Md(this, a) && (this.b -= this.a.get(a).length);
          this.a.set(a, [ b ]);
          this.b += 1;
          return this;
        };
        g.get = function(a, b) {
          a = a ? this.A(a) : [];
          return 0 < a.length ? String(a[0]) : b;
        };
        function Gd(a, b, c) {
          Ld(a, b);
          0 < c.length && (a.c = null, a.a.set(Kd(a, b), wa(c)), a.b += c.length);
        }
        g.toString = function() {
          if (this.c) return this.c;
          if (!this.a) return "";
          for (var a = [], b = this.a.M(), c = 0; c < b.length; c++) {
            var d = b[c], e = encodeURIComponent(String(d));
            d = this.A(d);
            for (var f = 0; f < d.length; f++) {
              var h = e;
              "" !== d[f] && (h += "=" + encodeURIComponent(String(d[f])));
              a.push(h);
            }
          }
          return this.c = a.join("&");
        };
        function wd(a) {
          var b = new yd();
          b.c = a.c;
          a.a && (b.a = new O(a.a), b.b = a.b);
          return b;
        }
        function Kd(a, b) {
          b = String(b);
          a.f && (b = b.toLowerCase());
          return b;
        }
        function Ed(a, b) {
          b && !a.f && (S(a), a.c = null, a.a.forEach(function(a, b) {
            var c = b.toLowerCase();
            b != c && (Ld(this, b), Gd(this, c, a));
          }, a));
          a.f = b;
        }
        function Nd() {
          this.a = t();
        }
        var Od = null;
        Nd.prototype.set = function(a) {
          this.a = a;
        };
        Nd.prototype.reset = function() {
          this.set(t());
        };
        Nd.prototype.get = function() {
          return this.a;
        };
        function Pd() {
          Od || (Od = new Nd());
        }
        function Qd() {
          Od || (Od = new Nd());
        }
        u(Qd, Pd);
        function Rd(a, b) {
          this.a = a;
          this.b = b;
          this.c = this.i = null;
          this.h = !1;
          this.m = null;
          this.f = -1;
          this.l = this.g = null;
        }
        g = Rd.prototype;
        g.P = null;
        function Sd(a) {
          H(a.b, "TestConnection: starting stage 2");
          var b = a.a.I.a;
          if (null != b) H(a.b, function() {
            return "TestConnection: skipping stage 2, precomputed result is " + b ? "Buffered" : "Unbuffered";
          }), K(4), b ? (K(10), Td(a.a, a, !1)) : (K(11), Td(a.a, a, !0)); else {
            a.c = new L(a, a.b, void 0, void 0);
            a.c.j = a.i;
            var c = Ud(a.a, a.g, a.m);
            K(4);
            $c(c, "TYPE", "xmlhttp");
            var d = a.a.j, e = a.a.K;
            d && e && R(c, d, e);
            Yc(a.c, c, !1, a.g);
          }
        }
        g.ca = function(a) {
          return this.a.ca(a);
        };
        g.abort = function() {
          this.c && (this.c.cancel(), this.c = null);
          this.f = -1;
        };
        g.La = function() {
          return !1;
        };
        g.Oa = function(a, b) {
          this.f = a.C;
          if (0 == this.P) {
            H(this.b, "TestConnection: Got data for stage 1");
            if (!this.a.o && (a = a.a)) {
              var c = id(a, "X-Client-Wire-Protocol");
              this.l = c || null;
              this.a.j && ((a = id(a, "X-HTTP-Session-Id")) ? this.a.K = a : D(this.b.a, "Missing X_HTTP_SESSION_ID in the handshake response"));
            }
            if (b) {
              try {
                var d = this.a.la.a.parse(b);
              } catch (e) {
                xc(this.b, e);
                Vd(this.a, this);
                return;
              }
              this.g = d[0];
            } else H(this.b, "TestConnection: Null responseText"), Vd(this.a, this);
          } else 1 == this.P && (this.h ? K(6) : "11111" == b ? (K(5), this.h = !0, !z || 10 <= Number(Wa)) && (this.f = 200, 
          this.c.cancel(), H(this.b, "Test connection succeeded; using streaming connection"), 
          K(11), Td(this.a, this, !0)) : (K(7), this.h = !1));
        };
        g.ta = function() {
          this.f = this.c.C;
          this.c.f ? 0 == this.P ? (this.P = 1, H(this.b, "TestConnection: request complete for initial check"), 
          Sd(this)) : 1 == this.P && (H(this.b, "TestConnection: request complete for stage 2"), 
          this.h ? (H(this.b, "Test connection succeeded; using streaming connection"), K(11), 
          Td(this.a, this, !0)) : (H(this.b, "Test connection failed; not using streaming"), 
          K(10), Td(this.a, this, !1))) : (H(this.b, "TestConnection: request failed, in state " + this.P), 
          0 == this.P ? K(8) : 1 == this.P && K(9), Vd(this.a, this));
        };
        g.ia = function() {
          return this.a.ia();
        };
        g.qa = function() {
          return this.a.qa();
        };
        function Wd() {
          this.a = this.b = null;
        }
        function Xd() {
          this.a = new O();
        }
        function Yd(a) {
          var b = typeof a;
          return "object" == b && a || "function" == b ? "o" + (a[q] || (a[q] = ++fa)) : b.charAt(0) + a;
        }
        Xd.prototype.add = function(a) {
          this.a.set(Yd(a), a);
        };
        Xd.prototype.A = function() {
          return this.a.A();
        };
        function Zd(a, b) {
          this.a = a;
          this.b = b;
        }
        function $d(a) {
          this.g = a || ae;
          k.PerformanceNavigationTiming ? (a = k.performance.getEntriesByType("navigation"), 
          a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(k.oa && k.oa.Ma && k.oa.Ma() && k.oa.Ma().Jb);
          this.f = a ? this.g : 1;
          this.a = null;
          1 < this.f && (this.a = new Xd());
          this.b = null;
          this.c = [];
        }
        var ae = 10;
        function be(a, b) {
          a.a || -1 == b.indexOf("spdy") && -1 == b.indexOf("quic") && -1 == b.indexOf("h2") || (a.f = a.g, 
          a.a = new Xd(), a.b && (ce(a, a.b), a.b = null));
        }
        function de(a) {
          return !!a.b || !!a.a && a.a.a.c >= a.f;
        }
        function ee(a, b) {
          a.b ? a = a.b == b : a.a ? (b = Yd(b), a = P(a.a.a.b, b)) : a = !1;
          return a;
        }
        function ce(a, b) {
          a.a ? a.a.add(b) : a.b = b;
        }
        function fe(a, b) {
          if (a.b && a.b == b) a.b = null; else {
            var c;
            (c = a.a) && (c = Yd(b), c = P(a.a.a.b, c));
            c && pd(a.a.a, Yd(b));
          }
        }
        $d.prototype.cancel = function() {
          this.c = ge(this);
          this.b ? (this.b.cancel(), this.b = null) : this.a && 0 != this.a.a.c && (ra(this.a.A(), function(a) {
            a.cancel();
          }), od(this.a.a));
        };
        function ge(a) {
          if (null != a.b) return a.c.concat(a.b.u);
          if (null != a.a && 0 != a.a.a.c) {
            var b = a.c;
            ra(a.a.A(), function(a) {
              b = b.concat(a.u);
            });
            return b;
          }
          return wa(a.c);
        }
        function he(a, b) {
          a.c = a.c.concat(b);
        }
        function ie() {}
        ie.prototype.stringify = function(a) {
          return k.JSON.stringify(a, void 0);
        };
        ie.prototype.parse = function(a) {
          return k.JSON.parse(a, void 0);
        };
        function je() {
          this.a = new ie();
        }
        function ke(a, b, c) {
          var d = c || "";
          try {
            md(a, function(a, c) {
              var e = a;
              ea(a) && (e = Db(a));
              b.push(d + c + "=" + encodeURIComponent(e));
            });
          } catch (e) {
            throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
          }
        }
        function le(a, b) {
          var c = new sc();
          H(c, "TestLoadImage: loading " + a);
          var d = new Image();
          d.onload = ja(me, c, d, "TestLoadImage: loaded", !0, b);
          d.onerror = ja(me, c, d, "TestLoadImage: error", !1, b);
          d.onabort = ja(me, c, d, "TestLoadImage: abort", !1, b);
          d.ontimeout = ja(me, c, d, "TestLoadImage: timeout", !1, b);
          k.setTimeout(function() {
            d.ontimeout && d.ontimeout();
          }, 1e4);
          d.src = a;
        }
        function me(a, b, c, d, e) {
          try {
            H(a, c), b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, 
            e(d);
          } catch (f) {
            xc(a, f);
          }
        }
        function T(a) {
          B.call(this);
          this.headers = new O();
          this.s = a || null;
          this.c = !1;
          this.D = this.a = null;
          this.K = this.B = "";
          this.j = 0;
          this.g = "";
          this.h = this.I = this.u = this.G = !1;
          this.l = 0;
          this.C = null;
          this.L = ne;
          this.v = this.o = !1;
        }
        u(T, B);
        var ne = "";
        T.prototype.b = qc("goog.net.XhrIo");
        var oe = /^https?$/i, pe = [ "POST", "PUT" ];
        g = T.prototype;
        g.fa = function(a, b, c, d) {
          if (this.a) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.B + "; newUri=" + a);
          b = b ? b.toUpperCase() : "GET";
          this.B = a;
          this.g = "";
          this.j = 0;
          this.K = b;
          this.G = !1;
          this.c = !0;
          this.a = this.s ? Qc(this.s) : Qc(Oc);
          this.D = this.s ? Ic(this.s) : Ic(Oc);
          this.a.onreadystatechange = r(this.Na, this);
          try {
            E(this.b, U(this, "Opening Xhr")), this.I = !0, this.a.open(b, String(a), !0), this.I = !1;
          } catch (f) {
            E(this.b, U(this, "Error opening Xhr: " + f.message));
            qe(this, f);
            return;
          }
          a = c || "";
          var e = new O(this.headers);
          d && md(d, function(a, b) {
            e.set(b, a);
          });
          d = sa(e.M());
          c = k.FormData && a instanceof k.FormData;
          !(0 <= qa(pe, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
          e.forEach(function(a, b) {
            this.a.setRequestHeader(b, a);
          }, this);
          this.L && (this.a.responseType = this.L);
          "withCredentials" in this.a && this.a.withCredentials !== this.o && (this.a.withCredentials = this.o);
          try {
            re(this), 0 < this.l && (this.v = se(this.a), E(this.b, U(this, "Will abort after " + this.l + "ms if incomplete, xhr2 " + this.v)), 
            this.v ? (this.a.timeout = this.l, this.a.ontimeout = r(this.Ka, this)) : this.C = Zb(this.Ka, this.l, this)), 
            E(this.b, U(this, "Sending request")), this.u = !0, this.a.send(a), this.u = !1;
          } catch (f) {
            E(this.b, U(this, "Send error: " + f.message)), qe(this, f);
          }
        };
        function se(a) {
          return z && Va(9) && "number" == typeof a.timeout && void 0 !== a.ontimeout;
        }
        function ta(a) {
          return "content-type" == a.toLowerCase();
        }
        g.Ka = function() {
          "undefined" != typeof goog && this.a && (this.g = "Timed out after " + this.l + "ms, aborting", 
          this.j = 8, E(this.b, U(this, this.g)), this.dispatchEvent("timeout"), this.abort(8));
        };
        function qe(a, b) {
          a.c = !1;
          a.a && (a.h = !0, a.a.abort(), a.h = !1);
          a.g = b;
          a.j = 5;
          te(a);
          ue(a);
        }
        function te(a) {
          a.G || (a.G = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"));
        }
        g.abort = function(a) {
          this.a && this.c && (E(this.b, U(this, "Aborting")), this.c = !1, this.h = !0, this.a.abort(), 
          this.h = !1, this.j = a || 7, this.dispatchEvent("complete"), this.dispatchEvent("abort"), 
          ue(this));
        };
        g.w = function() {
          this.a && (this.c && (this.c = !1, this.h = !0, this.a.abort(), this.h = !1), ue(this, !0));
          T.H.w.call(this);
        };
        g.Na = function() {
          this.i || (this.I || this.u || this.h ? ve(this) : this.jb());
        };
        g.jb = function() {
          ve(this);
        };
        function ve(a) {
          if (a.c && "undefined" != typeof goog) if (a.D[1] && 4 == N(a) && 2 == a.W()) E(a.b, U(a, "Local request error detected and ignored")); else if (a.u && 4 == N(a)) Zb(a.Na, 0, a); else if (a.dispatchEvent("readystatechange"), 
          4 == N(a)) {
            E(a.b, U(a, "Request complete"));
            a.c = !1;
            try {
              var b = a.W();
              a: switch (b) {
               case 200:
               case 201:
               case 202:
               case 204:
               case 206:
               case 304:
               case 1223:
                var c = !0;
                break a;

               default:
                c = !1;
              }
              var d;
              if (!(d = c)) {
                var e;
                if (e = 0 === b) {
                  var f = String(a.B).match(qd)[1] || null;
                  if (!f && k.self && k.self.location) {
                    var h = k.self.location.protocol;
                    f = h.substr(0, h.length - 1);
                  }
                  e = !oe.test(f ? f.toLowerCase() : "");
                }
                d = e;
              }
              d ? (a.dispatchEvent("complete"), a.dispatchEvent("success")) : (a.j = 6, a.g = a.Ha() + " [" + a.W() + "]", 
              te(a));
            } finally {
              ue(a);
            }
          }
        }
        function ue(a, b) {
          if (a.a) {
            re(a);
            var c = a.a, d = a.D[0] ? aa : null;
            a.a = null;
            a.D = null;
            b || a.dispatchEvent("ready");
            try {
              c.onreadystatechange = d;
            } catch (e) {
              (a = a.b) && a.log(ic, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
            }
          }
        }
        function re(a) {
          a.a && a.v && (a.a.ontimeout = null);
          a.C && (k.clearTimeout(a.C), a.C = null);
        }
        function N(a) {
          return a.a ? a.a.readyState : 0;
        }
        g.W = function() {
          try {
            return 2 < N(this) ? this.a.status : -1;
          } catch (a) {
            return -1;
          }
        };
        g.Ha = function() {
          try {
            return 2 < N(this) ? this.a.statusText : "";
          } catch (a) {
            return E(this.b, "Can not get status: " + a.message), "";
          }
        };
        g.V = function() {
          try {
            return this.a ? this.a.responseText : "";
          } catch (a) {
            return E(this.b, "Can not get responseText: " + a.message), "";
          }
        };
        g.eb = function(a) {
          if (this.a) {
            var b = this.a.responseText;
            a && 0 == b.indexOf(a) && (b = b.substring(a.length));
            a: {
              a = b;
              if (k.JSON) try {
                var c = k.JSON.parse(a);
                break a;
              } catch (d) {}
              c = Cb(a);
            }
            return c;
          }
        };
        function id(a, b) {
          return a.a ? a.a.getResponseHeader(b) : null;
        }
        g.Ga = function() {
          return this.j;
        };
        g.hb = function() {
          return l(this.g) ? this.g : String(this.g);
        };
        function U(a, b) {
          return b + " [" + a.K + " " + a.B + " " + a.W() + "]";
        }
        function we(a) {
          var b = "";
          Ca(a, function(a, d) {
            b += d;
            b += ":";
            b += a;
            b += "\r\n";
          });
          return b;
        }
        function xe(a, b, c) {
          a: {
            for (d in c) {
              var d = !1;
              break a;
            }
            d = !0;
          }
          if (d) return a;
          c = we(c);
          if (l(a)) {
            b = encodeURIComponent(String(b));
            c = null != c ? "=" + encodeURIComponent(String(c)) : "";
            if (b += c) {
              c = a.indexOf("#");
              0 > c && (c = a.length);
              d = a.indexOf("?");
              if (0 > d || d > c) {
                d = c;
                var e = "";
              } else e = a.substring(d + 1, c);
              a = [ a.substr(0, d), e, a.substr(c) ];
              c = a[1];
              a[1] = b ? c ? c + "&" + b : b : c;
              a = a[0] + (a[1] ? "?" + a[1] : "") + a[2];
            }
            return a;
          }
          R(a, b, c);
          return a;
        }
        function ye(a) {
          this.ya = 0;
          this.g = [];
          this.a = new sc();
          this.I = new Wd();
          this.X = this.ua = this.D = this.ja = this.b = this.K = this.j = this.U = this.h = this.L = this.i = null;
          this.Za = this.R = 0;
          this.Xa = !!n("internalChannelParams.failFast", a);
          this.ka = this.C = this.s = this.l = this.m = this.f = null;
          this.u = this.xa = this.N = -1;
          this.T = this.B = this.v = 0;
          this.Wa = n("internalChannelParams.baseRetryDelayMs", a) || 5e3;
          this.$a = n("internalChannelParams.retryDelaySeedMs", a) || 1e4;
          this.Ya = n("internalChannelParams.forwardChannelMaxRetries", a) || 2;
          this.wa = n("internalChannelParams.forwardChannelRequestTimeoutMs", a) || 2e4;
          this.Ta = a && a.Kb || void 0;
          this.G = void 0;
          this.S = a && a.supportsCrossDomainXhr || !1;
          this.J = "";
          this.c = new $d(a && a.concurrentRequestLimit);
          this.la = new je();
          this.o = !a || void 0 === a.backgroundChannelTest || a.backgroundChannelTest;
          (this.va = a && a.fastHandshake || !1) && !this.o && (D(this.a.a, "Force backgroundChannelTest when fastHandshake is enabled."), 
          this.o = !0);
          a && a.Fa && this.a.Fa();
        }
        g = ye.prototype;
        g.na = 8;
        g.F = 1;
        function ze(a) {
          H(a.a, "disconnect()");
          Ae(a);
          if (3 == a.F) {
            var b = a.R++, c = M(a.D);
            R(c, "SID", a.J);
            R(c, "RID", b);
            R(c, "TYPE", "terminate");
            Be(a, c);
            b = new L(a, a.a, b, void 0);
            b.J = 2;
            b.h = Wc(M(c));
            c = !1;
            k.navigator && k.navigator.sendBeacon && (c = k.navigator.sendBeacon(b.h.toString(), ""));
            !c && k.Image && (new Image().src = b.h, c = !0);
            c || (b.a = b.i.ca(null), b.a.fa(b.h));
            b.D = t();
            Zc(b);
          }
          Ce(a);
        }
        function Ae(a) {
          a.C && (a.C.abort(), a.C = null);
          a.b && (a.b.cancel(), a.b = null);
          a.l && (k.clearTimeout(a.l), a.l = null);
          De(a);
          a.c.cancel();
          a.m && (k.clearTimeout(a.m), a.m = null);
        }
        function Ee(a, b) {
          1e3 == a.g.length && J(a.a, function() {
            return "Already have 1000 queued maps upon queueing " + Db(b);
          });
          a.g.push(new Zd(a.Za++, b));
          3 == a.F && Fe(a);
        }
        g.La = function() {
          return 0 == this.F;
        };
        function Fe(a) {
          de(a.c) || a.m || (a.m = Ec(r(a.Qa, a), 0), a.v = 0);
        }
        function Ge(a, b) {
          var c = a.c;
          if ((c.b ? 1 : c.a ? c.a.a.c : 0) >= a.c.f - (a.m ? 1 : 0)) return J(a.a, "Unexpected retry request is scheduled."), 
          !1;
          if (a.m) return H(a.a, "Use the retry request that is already scheduled."), a.g = b.u.concat(a.g), 
          !0;
          if (1 == a.F || 2 == a.F || a.v >= (a.Xa ? 0 : a.Ya)) return !1;
          H(a.a, "Going to retry POST");
          a.m = Ec(r(a.Qa, a, b), He(a, a.v));
          a.v++;
          return !0;
        }
        g.Qa = function(a) {
          this.m = null;
          H(this.a, "startForwardChannel_");
          if (1 == this.F) if (a) J(this.a, "Not supposed to retry the open"); else {
            H(this.a, "open_()");
            this.R = Math.floor(1e5 * Math.random());
            a = this.R++;
            var b = new L(this, this.a, a, void 0), c = this.i;
            this.L && (c ? (c = Fa(c), Ha(c, this.L)) : c = this.L);
            null === this.h && (b.j = c);
            var d = Ie(this, b), e = M(this.D);
            R(e, "RID", a);
            R(e, "CVER", 22);
            this.o && this.j && R(e, "X-HTTP-Session-Id", this.j);
            Be(this, e);
            this.h && c && xe(e, this.h, c);
            ce(this.c, b);
            this.va ? (R(e, "$req", d), R(e, "SID", "null"), b.X = !0, Vc(b, e, null)) : Vc(b, e, d);
            this.F = 2;
          } else 3 == this.F && (a ? Je(this, a) : 0 == this.g.length ? H(this.a, "startForwardChannel_ returned: nothing to send") : de(this.c) ? J(this.a, "startForwardChannel_ returned: connection already in progress") : (Je(this), 
          H(this.a, "startForwardChannel_ finished, sent request")));
        };
        function Je(a, b) {
          var c;
          c = b ? b.c : a.R++;
          var d = M(a.D);
          R(d, "SID", a.J);
          R(d, "RID", c);
          R(d, "AID", a.N);
          Be(a, d);
          a.h && a.i && xe(d, a.h, a.i);
          c = new L(a, a.a, c, a.v + 1);
          null === a.h && (c.j = a.i);
          b && (a.g = b.u.concat(a.g));
          b = Ie(a, c);
          c.setTimeout(Math.round(.5 * a.wa) + Math.round(.5 * a.wa * Math.random()));
          ce(a.c, c);
          Vc(c, d, b);
        }
        function Be(a, b) {
          a.f && md({}, function(a, d) {
            R(b, d, a);
          });
        }
        function Ie(a, b) {
          var c = Math.min(a.g.length, 1e3), d = a.f ? r(a.f.ab, a.f, a) : null;
          a: for (var e = a.g, f = -1; ;) {
            var h = [ "count=" + c ];
            -1 == f ? 0 < c ? (f = e[0].a, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
            for (var m = !0, v = 0; v < c; v++) {
              var I = e[v].a, X = e[v].b;
              I -= f;
              if (0 > I) f = Math.max(0, e[v].a - 100), m = !1; else try {
                ke(X, h, "req" + I + "_");
              } catch (Mb) {
                d && d(X);
              }
            }
            if (m) {
              d = h.join("&");
              break a;
            }
          }
          a = a.g.splice(0, c);
          b.u = a;
          return d;
        }
        function Ke(a) {
          if (!a.b && !a.l) {
            a.T = 1;
            var b = a.Pa;
            Tb || Ub();
            Wb || (Tb(), Wb = !0);
            Pb.add(b, a);
            a.B = 0;
          }
        }
        function Le(a) {
          if (a.b || a.l) return J(a.a, "Request already in progress"), !1;
          if (3 <= a.B) return !1;
          H(a.a, "Going to retry GET");
          a.T++;
          a.l = Ec(r(a.Pa, a), He(a, a.B));
          a.B++;
          return !0;
        }
        g.Pa = function() {
          this.l = null;
          H(this.a, "Creating new HttpRequest");
          this.b = new L(this, this.a, "rpc", this.T);
          null === this.h && (this.b.j = this.i);
          this.b.N = 0;
          var a = M(this.ua);
          R(a, "RID", "rpc");
          R(a, "SID", this.J);
          R(a, "CI", this.ka ? "0" : "1");
          R(a, "AID", this.N);
          Be(this, a);
          R(a, "TYPE", "xmlhttp");
          this.h && this.i && xe(a, this.h, this.i);
          this.G && this.b.setTimeout(this.G);
          Yc(this.b, a, !0, this.X);
          H(this.a, "New Request created");
        };
        function Td(a, b, c) {
          H(a.a, "Test Connection Finished");
          var d = b.l;
          d && be(a.c, d);
          a.ka = c;
          a.u = b.f;
          H(a.a, "connectChannel_()");
          a.D = Me(a, a.ja);
          Fe(a);
        }
        function Vd(a, b) {
          H(a.a, "Test Connection Failed");
          a.u = b.f;
          V(a, 2);
        }
        g.Oa = function(a, b) {
          if (0 != this.F && (this.b == a || ee(this.c, a))) if (this.u = a.C, !a.v && ee(this.c, a) && 3 == this.F) {
            try {
              var c = this.la.a.parse(b);
            } catch (f) {
              c = null;
            }
            if (p(c) && 3 == c.length) if (b = c, 0 == b[0]) a: if (H(this.a, "Server claims our backchannel is missing."), 
            this.l) H(this.a, "But we are currently starting the request."); else {
              if (this.b) {
                if (!(this.b.D + 3e3 < a.D)) break a;
                De(this), this.b.cancel(), this.b = null;
              } else D(this.a.a, "We do not have a BackChannel established");
              Le(this);
              K(18);
            } else this.xa = b[1], a = this.xa - this.N, 0 < a && (b = b[2], H(this.a, b + " bytes (in " + a + " arrays) are outstanding on the BackChannel"), 
            37500 > b && this.ka && 0 == this.B && !this.s && (this.s = Ec(r(this.ib, this), 6e3))); else H(this.a, "Bad POST response data returned"), 
            V(this, 11);
          } else if ((a.v || this.b == a) && De(this), !xa(b)) for (b = c = this.la.a.parse(b), 
          c = 0; c < b.length; c++) {
            var d = b[c];
            this.N = d[0];
            d = d[1];
            if (2 == this.F) if ("c" == d[0]) {
              this.J = d[1];
              this.X = d[2];
              var e = d[3];
              null != e && (this.na = e, F(this.a, "VER=" + this.na));
              e = d[4];
              null != e && (this.ya = e, F(this.a, "SVER=" + this.ya));
              d = d[5];
              null != d && "number" == typeof d && 0 < d && (this.G = d *= 1.5, F(this.a, "backChannelRequestTimeoutMs_=" + d));
              this.o && (d = a.a) && ((e = id(d, "X-Client-Wire-Protocol")) && be(this.c, e), 
              this.j && ((d = id(d, "X-HTTP-Session-Id")) ? (this.K = d, R(this.D, this.j, d)) : D(this.a.a, "Missing X_HTTP_SESSION_ID in the handshake response")));
              this.F = 3;
              this.f && this.f.Da();
              d = a;
              this.ua = Ud(this, this.X, this.ja);
              d.v ? (H(this.a, "Upgrade the handshake request to a backchannel."), fe(this.c, d), 
              (e = this.G) && d.setTimeout(e), d.s && (bd(d), Zc(d)), this.b = d) : Ke(this);
            } else "stop" != d[0] && "close" != d[0] || V(this, 7); else 3 == this.F && ("stop" == d[0] || "close" == d[0] ? "stop" == d[0] ? V(this, 7) : ze(this) : "noop" != d[0] && this.f && this.f.Ca(d), 
            this.B = 0);
          }
        };
        g.ib = function() {
          null != this.s && (this.s = null, this.b.cancel(), this.b = null, Le(this), K(19));
        };
        function De(a) {
          null != a.s && (k.clearTimeout(a.s), a.s = null);
        }
        g.ta = function(a) {
          H(this.a, "Request complete");
          var b = null;
          if (this.b == a) {
            De(this);
            this.b = null;
            var c = 2;
          } else {
            if (!ee(this.c, a)) return;
            b = a.u, fe(this.c, a), c = 1;
          }
          this.u = a.C;
          if (0 != this.F) if (a.f) 1 == c ? (Dc(a.l ? a.l.length : 0, t() - a.D, this.v), 
          Fe(this)) : Ke(this); else {
            var d = a.m;
            if (3 == d || 0 == d && 0 < this.u) H(this.a, "Not retrying due to error type"); else {
              var e = this;
              H(this.a, function() {
                return "Maybe retrying, last error: " + Sc(d, e.u);
              });
              if (1 == c && Ge(this, a) || 2 == c && Le(this)) return;
              H(this.a, "Exceeded max number of retries");
            }
            b && 0 < b.length && he(this.c, b);
            H(this.a, "Error: HTTP request failed");
            switch (d) {
             case 1:
              V(this, 5);
              break;

             case 4:
              V(this, 10);
              break;

             case 3:
              V(this, 6);
              break;

             default:
              V(this, 2);
            }
          }
        };
        function He(a, b) {
          var c = a.Wa + Math.floor(Math.random() * a.$a);
          a.qa() || (H(a.a, "Inactive channel"), c *= 2);
          return c * b;
        }
        function V(a, b) {
          F(a.a, "Error code " + b);
          if (2 == b) {
            var c = null;
            a.f && (c = null);
            var d = r(a.pb, a);
            c || (c = new Q("//www.google.com/images/cleardot.gif"), k.location && "http" == k.location.protocol || sd(c, "https"), 
            Wc(c));
            le(c.toString(), d);
          } else K(2);
          H(a.a, "HttpChannel: error - " + b);
          a.F = 0;
          a.f && a.f.Ba(b);
          Ce(a);
          Ae(a);
        }
        g.pb = function(a) {
          a ? (F(this.a, "Successfully pinged google.com"), K(2)) : (F(this.a, "Failed to ping google.com"), 
          K(1));
        };
        function Ce(a) {
          a.F = 0;
          a.u = -1;
          if (a.f) {
            var b = ge(a.c);
            0 == b.length && 0 == a.g.length || (H(a.a, function() {
              return "Number of undelivered maps, pending: " + b.length + ", outgoing: " + a.g.length;
            }), a.c.c.length = 0, wa(a.g), a.g.length = 0);
            a.f.Aa();
          }
        }
        function Me(a, b) {
          b = Ne(a, null, b);
          H(a.a, "GetForwardChannelUri: " + b);
          return b;
        }
        function Ud(a, b, c) {
          b = Ne(a, a.ia() ? b : null, c);
          H(a.a, "GetBackChannelUri: " + b);
          return b;
        }
        function Ne(a, b, c) {
          var d = Hd(c);
          if ("" != d.b) b && td(d, b + "." + d.b), ud(d, d.i); else {
            var e = k.location, f;
            f = b ? b + "." + e.hostname : e.hostname;
            d = Id(e.protocol, f, e.port, c);
          }
          a.U && Ca(a.U, function(a, b) {
            R(d, b, a);
          });
          b = a.j;
          c = a.K;
          b && c && R(d, b, c);
          R(d, "VER", a.na);
          Be(a, d);
          return d;
        }
        g.ca = function(a) {
          if (a && !this.S) throw Error("Can't create secondary domain capable XhrIo object.");
          a = new T(this.Ta);
          a.o = this.S;
          return a;
        };
        g.qa = function() {
          return !!this.f && !0;
        };
        g.ia = function() {
          return this.S;
        };
        new Qd();
        function Oe() {}
        g = Oe.prototype;
        g.Da = function() {};
        g.Ca = function() {};
        g.Ba = function() {};
        g.Aa = function() {};
        g.ab = function() {};
        function Pe(a) {
          for (var b = a, c = 1; c < arguments.length; c++) {
            var d = arguments[c];
            if (0 == d.lastIndexOf("/", 0)) b = d; else {
              var e;
              (e = "" == b) || (e = b.length - 1, e = 0 <= e && b.indexOf("/", e) == e);
              b += e ? d : "/" + d;
            }
          }
          return b;
        }
        function Qe() {
          if (z && !(10 <= Number(Wa))) throw Error("Environmental error: no available transport.");
        }
        Qe.prototype.a = function(a, b) {
          return new W(a, b);
        };
        function W(a, b) {
          B.call(this);
          this.a = new ye(b);
          this.b = a;
          this.o = b && b.testUrl ? b.testUrl : Pe(this.b, "test");
          this.c = qc("goog.labs.net.webChannel.WebChannelBaseTransport");
          this.g = b && b.messageUrlParams || null;
          a = b && b.messageHeaders || null;
          b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = {
            "X-Client-Protocol": "webchannel"
          });
          this.a.i = a;
          a = b && b.initMessageHeaders || null;
          b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = {
            "X-WebChannel-Content-Type": b.messageContentType
          });
          b && b.Ea && (a ? a["X-WebChannel-Client-Profile"] = b.Ea : a = {
            "X-WebChannel-Client-Profile": b.Ea
          });
          this.a.L = a;
          (a = b && b.httpHeadersOverwriteParam) && !xa(a) && (this.a.h = a);
          this.l = b && b.supportsCrossDomainXhr || !1;
          this.j = b && b.sendRawJson || !1;
          (b = b && b.httpSessionIdParam) && !xa(b) && (this.a.j = b, a = this.g, null !== a && b in a && (a = this.g, 
          b in a && delete a[b], D(this.c, "Ignore httpSessionIdParam also specified with messageUrlParams: " + b)));
          this.h = new Re(this);
        }
        u(W, B);
        g = W.prototype;
        g.addEventListener = function(a, b, c, d) {
          W.H.addEventListener.call(this, a, b, c, d);
        };
        g.removeEventListener = function(a, b, c, d) {
          W.H.removeEventListener.call(this, a, b, c, d);
        };
        g.fb = function() {
          this.a.f = this.h;
          this.l && (this.a.S = !0);
          var a = this.a, b = this.o, c = this.b, d = this.g || void 0;
          H(a.a, "connect()");
          K(0);
          a.ja = c;
          a.U = d || {};
          a.o && (H(a.a, "connect() bypassed channel-test."), a.I.b = [], a.I.a = !1);
          H(a.a, "connectTest_()");
          a.C = new Rd(a, a.a);
          null === a.h && (a.C.i = a.i);
          c = b;
          a.h && a.i && (c = xe(b, a.h, a.i));
          a = a.C;
          a.m = c;
          b = Me(a.a, a.m);
          K(3);
          c = a.a.I.b;
          null != c ? (a.g = c[0], a.P = 1, Sd(a)) : ($c(b, "MODE", "init"), !a.a.o && a.a.j && $c(b, "X-HTTP-Session-Id", a.a.j), 
          a.c = new L(a, a.b, void 0, void 0), a.c.j = a.i, Yc(a.c, b, !1, null), a.P = 0);
        };
        g.close = function() {
          ze(this.a);
        };
        g.gb = function(a) {
          if (l(a)) {
            var b = {};
            b.__data__ = a;
            Ee(this.a, b);
          } else this.j ? (b = {}, b.__data__ = Db(a), Ee(this.a, b)) : Ee(this.a, a);
        };
        g.w = function() {
          this.a.f = null;
          delete this.h;
          ze(this.a);
          delete this.a;
          W.H.w.call(this);
        };
        function Se(a) {
          Mc.call(this);
          var b = a.__sm__;
          if (b) {
            a: {
              for (var c in b) {
                a = c;
                break a;
              }
              a = void 0;
            }
            (this.c = a) ? (a = this.c, this.data = null !== b && a in b ? b[a] : void 0) : this.data = b;
          } else this.data = a;
        }
        u(Se, Mc);
        function Te() {
          Nc.call(this);
          this.status = 1;
        }
        u(Te, Nc);
        function Re(a) {
          this.a = a;
        }
        u(Re, Oe);
        Re.prototype.Da = function() {
          rc(this.a.c, "WebChannel opened on " + this.a.b);
          this.a.dispatchEvent("a");
        };
        Re.prototype.Ca = function(a) {
          this.a.dispatchEvent(new Se(a));
        };
        Re.prototype.Ba = function(a) {
          rc(this.a.c, "WebChannel aborted on " + this.a.b + " due to channel error: " + a);
          this.a.dispatchEvent(new Te(a));
        };
        Re.prototype.Aa = function() {
          rc(this.a.c, "WebChannel closed on " + this.a.b);
          this.a.dispatchEvent("b");
        };
        var Ue = ja(function(a, b) {
          function c() {}
          c.prototype = a.prototype;
          var d = new c();
          a.apply(d, Array.prototype.slice.call(arguments, 1));
          return d;
        }, Qe);
        function Ve() {
          this.b = [];
          this.a = [];
        }
        function We(a) {
          0 == a.b.length && (a.b = a.a, a.b.reverse(), a.a = []);
          return a.b.pop();
        }
        function Xe(a) {
          return a.b.length + a.a.length;
        }
        Ve.prototype.A = function() {
          for (var a = [], b = this.b.length - 1; 0 <= b; --b) a.push(this.b[b]);
          var c = this.a.length;
          for (b = 0; b < c; ++b) a.push(this.a[b]);
          return a;
        };
        function Ye(a, b) {
          w.call(this);
          this.h = a || 0;
          this.c = b || 10;
          if (this.h > this.c) throw Error(Ze);
          this.a = new Ve();
          this.b = new Xd();
          this.g = null;
          this.aa();
        }
        u(Ye, w);
        var Ze = "[goog.structs.Pool] Min can not be greater than max";
        g = Ye.prototype;
        g.da = function() {
          var a = t();
          if (!(null != this.g && 0 > a - this.g)) {
            for (var b; 0 < Xe(this.a) && (b = We(this.a), !this.sa(b)); ) this.aa();
            !b && $e(this) < this.c && (b = this.pa());
            b && (this.g = a, this.b.add(b));
            return b;
          }
        };
        g.ob = function(a) {
          return !!pd(this.b.a, Yd(a)) && (this.ma(a), !0);
        };
        g.ma = function(a) {
          pd(this.b.a, Yd(a));
          this.sa(a) && $e(this) < this.c ? this.a.a.push(a) : af(a);
        };
        g.aa = function() {
          for (var a = this.a; $e(this) < this.h; ) {
            var b = this.pa();
            a.a.push(b);
          }
          for (;$e(this) > this.c && 0 < Xe(this.a); ) af(We(a));
        };
        g.pa = function() {
          return {};
        };
        function af(a) {
          if ("function" == typeof a.$) a.$(); else for (var b in a) a[b] = null;
        }
        g.sa = function(a) {
          return "function" != typeof a.bb || a.bb();
        };
        function $e(a) {
          return Xe(a.a) + a.b.a.c;
        }
        g.w = function() {
          Ye.H.w.call(this);
          if (0 < this.b.a.c) throw Error("[goog.structs.Pool] Objects not released");
          delete this.b;
          for (var a = this.a; 0 != a.b.length || 0 != a.a.length; ) af(We(a));
          delete this.a;
        };
        function bf(a, b) {
          this.a = a;
          this.b = b;
        }
        function cf(a) {
          this.a = [];
          if (a) a: {
            if (a instanceof cf) {
              var b = a.M();
              a = a.A();
              if (0 >= this.a.length) {
                for (var c = this.a, d = 0; d < b.length; d++) c.push(new bf(b[d], a[d]));
                break a;
              }
            } else b = Ea(a), a = Da(a);
            for (d = 0; d < b.length; d++) df(this, b[d], a[d]);
          }
        }
        function df(a, b, c) {
          var d = a.a;
          d.push(new bf(b, c));
          b = d.length - 1;
          a = a.a;
          for (c = a[b]; 0 < b; ) {
            if (d = b - 1 >> 1, !(a[d].a > c.a)) break;
            a[b] = a[d], b = d;
          }
          a[b] = c;
        }
        cf.prototype.A = function() {
          for (var a = this.a, b = [], c = a.length, d = 0; d < c; d++) b.push(a[d].b);
          return b;
        };
        cf.prototype.M = function() {
          for (var a = this.a, b = [], c = a.length, d = 0; d < c; d++) b.push(a[d].a);
          return b;
        };
        function ef() {
          cf.call(this);
        }
        u(ef, cf);
        function Y(a, b) {
          this.f = new ef();
          Ye.call(this, a, b);
        }
        u(Y, Ye);
        g = Y.prototype;
        g.da = function(a, b) {
          if (!a) return Y.H.da.call(this);
          df(this.f, void 0 !== b ? b : 100, a);
          this.ra();
        };
        g.ra = function() {
          for (var a = this.f; 0 < a.a.length; ) {
            var b = this.da();
            if (!b) break;
            var c = a, d = c.a, e = d.length;
            var f = d[0];
            if (0 >= e) f = void 0; else {
              if (1 == e) ua(d); else {
                d[0] = d.pop();
                d = 0;
                c = c.a;
                e = c.length;
                for (var h = c[d]; d < e >> 1; ) {
                  var m = 2 * d + 1, v = 2 * d + 2;
                  m = v < e && c[v].a < c[m].a ? v : m;
                  if (c[m].a > h.a) break;
                  c[d] = c[m];
                  d = m;
                }
                c[d] = h;
              }
              f = f.b;
            }
            f.apply(this, [ b ]);
          }
        };
        g.ma = function(a) {
          Y.H.ma.call(this, a);
          this.ra();
        };
        g.aa = function() {
          Y.H.aa.call(this);
          this.ra();
        };
        g.w = function() {
          Y.H.w.call(this);
          k.clearTimeout(void 0);
          ua(this.f.a);
          this.f = null;
        };
        function Z(a, b, c, d) {
          this.l = a;
          this.j = !!d;
          Y.call(this, b, c);
        }
        u(Z, Y);
        Z.prototype.pa = function() {
          var a = new T(), b = this.l;
          b && b.forEach(function(b, d) {
            a.headers.set(d, b);
          });
          this.j && (a.o = !0);
          return a;
        };
        Z.prototype.sa = function(a) {
          return !a.i && !a.a;
        };
        Qe.prototype.createWebChannel = Qe.prototype.a;
        W.prototype.send = W.prototype.gb;
        W.prototype.open = W.prototype.fb;
        W.prototype.close = W.prototype.close;
        Fc.NO_ERROR = 0;
        Fc.TIMEOUT = 8;
        Fc.HTTP_ERROR = 6;
        Gc.COMPLETE = "complete";
        Kc.EventType = Lc;
        Lc.OPEN = "a";
        Lc.CLOSE = "b";
        Lc.ERROR = "c";
        Lc.MESSAGE = "d";
        B.prototype.listen = B.prototype.Ia;
        Z.prototype.getObject = Z.prototype.da;
        Z.prototype.releaseObject = Z.prototype.ob;
        T.prototype.listenOnce = T.prototype.Ja;
        T.prototype.getLastError = T.prototype.hb;
        T.prototype.getLastErrorCode = T.prototype.Ga;
        T.prototype.getStatus = T.prototype.W;
        T.prototype.getStatusText = T.prototype.Ha;
        T.prototype.getResponseJson = T.prototype.eb;
        T.prototype.getResponseText = T.prototype.V;
        T.prototype.getResponseText = T.prototype.V;
        T.prototype.send = T.prototype.fa;
        module.exports = {
          createWebChannelTransport: Ue,
          ErrorCode: Fc,
          EventType: Gc,
          WebChannel: Kc,
          XhrIoPool: Z
        };
      }).call("undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  18: [ function(require, module, exports) {
    module.exports = after;
    function after(count, callback, err_cb) {
      var bail = false;
      err_cb = err_cb || noop;
      proxy.count = count;
      return 0 === count ? callback() : proxy;
      function proxy(err, result) {
        if (proxy.count <= 0) throw new Error("after called too many times");
        --proxy.count;
        if (err) {
          bail = true;
          callback(err);
          callback = err_cb;
        } else 0 !== proxy.count || bail || callback(null, result);
      }
    }
    function noop() {}
  }, {} ],
  19: [ function(require, module, exports) {
    module.exports = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
      if (arraybuffer.slice) return arraybuffer.slice(start, end);
      start < 0 && (start += bytes);
      end < 0 && (end += bytes);
      end > bytes && (end = bytes);
      if (start >= bytes || start >= end || 0 === bytes) return new ArrayBuffer(0);
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start, ii = 0; i < end; i++, ii++) result[ii] = abv[i];
      return result.buffer;
    };
  }, {} ],
  20: [ function(require, module, exports) {
    module.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = 0 == (1 & Math.floor(10 * rand)) ? ms - deviation : ms + deviation;
      }
      return 0 | Math.min(ms, this.max);
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }, {} ],
  21: [ function(require, module, exports) {
    (function() {
      "use strict";
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = new Uint8Array(256);
      for (var i = 0; i < chars.length; i++) lookup[chars.charCodeAt(i)] = i;
      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
        for (i = 0; i < len; i += 3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[(3 & bytes[i]) << 4 | bytes[i + 1] >> 4];
          base64 += chars[(15 & bytes[i + 1]) << 2 | bytes[i + 2] >> 6];
          base64 += chars[63 & bytes[i + 2]];
        }
        len % 3 === 2 ? base64 = base64.substring(0, base64.length - 1) + "=" : len % 3 === 1 && (base64 = base64.substring(0, base64.length - 2) + "==");
        return base64;
      };
      exports.decode = function(base64) {
        var bufferLength = .75 * base64.length, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
        if ("=" === base64[base64.length - 1]) {
          bufferLength--;
          "=" === base64[base64.length - 2] && bufferLength--;
        }
        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = lookup[base64.charCodeAt(i)];
          encoded2 = lookup[base64.charCodeAt(i + 1)];
          encoded3 = lookup[base64.charCodeAt(i + 2)];
          encoded4 = lookup[base64.charCodeAt(i + 3)];
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (15 & encoded2) << 4 | encoded3 >> 2;
          bytes[p++] = (3 & encoded3) << 6 | 63 & encoded4;
        }
        return arraybuffer;
      };
    })();
  }, {} ],
  22: [ function(require, module, exports) {
    (function(global) {
      var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
      var blobSupported = function() {
        try {
          var a = new Blob([ "hi" ]);
          return 2 === a.size;
        } catch (e) {
          return false;
        }
      }();
      var blobSupportsArrayBufferView = blobSupported && function() {
        try {
          var b = new Blob([ new Uint8Array([ 1, 2 ]) ]);
          return 2 === b.size;
        } catch (e) {
          return false;
        }
      }();
      var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
      function mapArrayBufferViews(ary) {
        for (var i = 0; i < ary.length; i++) {
          var chunk = ary[i];
          if (chunk.buffer instanceof ArrayBuffer) {
            var buf = chunk.buffer;
            if (chunk.byteLength !== buf.byteLength) {
              var copy = new Uint8Array(chunk.byteLength);
              copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
              buf = copy.buffer;
            }
            ary[i] = buf;
          }
        }
      }
      function BlobBuilderConstructor(ary, options) {
        options = options || {};
        var bb = new BlobBuilder();
        mapArrayBufferViews(ary);
        for (var i = 0; i < ary.length; i++) bb.append(ary[i]);
        return options.type ? bb.getBlob(options.type) : bb.getBlob();
      }
      function BlobConstructor(ary, options) {
        mapArrayBufferViews(ary);
        return new Blob(ary, options || {});
      }
      module.exports = function() {
        return blobSupported ? blobSupportsArrayBufferView ? global.Blob : BlobConstructor : blobBuilderSupported ? BlobBuilderConstructor : void 0;
      }();
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  23: [ function(require, module, exports) {
    var slice = [].slice;
    module.exports = function(obj, fn) {
      "string" == typeof fn && (fn = obj[fn]);
      if ("function" != typeof fn) throw new Error("bind() requires a function");
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.concat(slice.call(arguments)));
      };
    };
  }, {} ],
  24: [ function(require, module, exports) {
    "undefined" !== typeof module && (module.exports = Emitter);
    function Emitter(obj) {
      if (obj) return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key];
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks) return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1), callbacks = this._callbacks["$" + event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) callbacks[i].apply(this, args);
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }, {} ],
  25: [ function(require, module, exports) {
    module.exports = function(a, b) {
      var fn = function() {};
      fn.prototype = b.prototype;
      a.prototype = new fn();
      a.prototype.constructor = a;
    };
  }, {} ],
  26: [ function(require, module, exports) {
    module.exports = require("./socket");
    module.exports.parser = require("engine.io-parser");
  }, {
    "./socket": 27,
    "engine.io-parser": 37
  } ],
  27: [ function(require, module, exports) {
    (function(global) {
      var transports = require("./transports/index");
      var Emitter = require("component-emitter");
      var debug = require("debug")("engine.io-client:socket");
      var index = require("indexof");
      var parser = require("engine.io-parser");
      var parseuri = require("parseuri");
      var parseqs = require("parseqs");
      module.exports = Socket;
      function Socket(uri, opts) {
        if (!(this instanceof Socket)) return new Socket(uri, opts);
        opts = opts || {};
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = parseuri(uri);
          opts.hostname = uri.host;
          opts.secure = "https" === uri.protocol || "wss" === uri.protocol;
          opts.port = uri.port;
          uri.query && (opts.query = uri.query);
        } else opts.host && (opts.hostname = parseuri(opts.host).host);
        this.secure = null != opts.secure ? opts.secure : global.location && "https:" === location.protocol;
        opts.hostname && !opts.port && (opts.port = this.secure ? "443" : "80");
        this.agent = opts.agent || false;
        this.hostname = opts.hostname || (global.location ? location.hostname : "localhost");
        this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
        this.query = opts.query || {};
        "string" === typeof this.query && (this.query = parseqs.decode(this.query));
        this.upgrade = false !== opts.upgrade;
        this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/";
        this.forceJSONP = !!opts.forceJSONP;
        this.jsonp = false !== opts.jsonp;
        this.forceBase64 = !!opts.forceBase64;
        this.enablesXDR = !!opts.enablesXDR;
        this.timestampParam = opts.timestampParam || "t";
        this.timestampRequests = opts.timestampRequests;
        this.transports = opts.transports || [ "polling", "websocket" ];
        this.transportOptions = opts.transportOptions || {};
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.policyPort = opts.policyPort || 843;
        this.rememberUpgrade = opts.rememberUpgrade || false;
        this.binaryType = null;
        this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
        this.perMessageDeflate = false !== opts.perMessageDeflate && (opts.perMessageDeflate || {});
        true === this.perMessageDeflate && (this.perMessageDeflate = {});
        this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024);
        this.pfx = opts.pfx || null;
        this.key = opts.key || null;
        this.passphrase = opts.passphrase || null;
        this.cert = opts.cert || null;
        this.ca = opts.ca || null;
        this.ciphers = opts.ciphers || null;
        this.rejectUnauthorized = void 0 === opts.rejectUnauthorized || opts.rejectUnauthorized;
        this.forceNode = !!opts.forceNode;
        var freeGlobal = "object" === typeof global && global;
        if (freeGlobal.global === freeGlobal) {
          opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0 && (this.extraHeaders = opts.extraHeaders);
          opts.localAddress && (this.localAddress = opts.localAddress);
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingIntervalTimer = null;
        this.pingTimeoutTimer = null;
        this.open();
      }
      Socket.priorWebsocketSuccess = false;
      Emitter(Socket.prototype);
      Socket.protocol = parser.protocol;
      Socket.Socket = Socket;
      Socket.Transport = require("./transport");
      Socket.transports = require("./transports/index");
      Socket.parser = require("engine.io-parser");
      Socket.prototype.createTransport = function(name) {
        debug('creating transport "%s"', name);
        var query = clone(this.query);
        query.EIO = parser.protocol;
        query.transport = name;
        var options = this.transportOptions[name] || {};
        this.id && (query.sid = this.id);
        var transport = new transports[name]({
          query: query,
          socket: this,
          agent: options.agent || this.agent,
          hostname: options.hostname || this.hostname,
          port: options.port || this.port,
          secure: options.secure || this.secure,
          path: options.path || this.path,
          forceJSONP: options.forceJSONP || this.forceJSONP,
          jsonp: options.jsonp || this.jsonp,
          forceBase64: options.forceBase64 || this.forceBase64,
          enablesXDR: options.enablesXDR || this.enablesXDR,
          timestampRequests: options.timestampRequests || this.timestampRequests,
          timestampParam: options.timestampParam || this.timestampParam,
          policyPort: options.policyPort || this.policyPort,
          pfx: options.pfx || this.pfx,
          key: options.key || this.key,
          passphrase: options.passphrase || this.passphrase,
          cert: options.cert || this.cert,
          ca: options.ca || this.ca,
          ciphers: options.ciphers || this.ciphers,
          rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
          perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
          extraHeaders: options.extraHeaders || this.extraHeaders,
          forceNode: options.forceNode || this.forceNode,
          localAddress: options.localAddress || this.localAddress,
          requestTimeout: options.requestTimeout || this.requestTimeout,
          protocols: options.protocols || void 0
        });
        return transport;
      };
      function clone(obj) {
        var o = {};
        for (var i in obj) obj.hasOwnProperty(i) && (o[i] = obj[i]);
        return o;
      }
      Socket.prototype.open = function() {
        var transport;
        if (this.rememberUpgrade && Socket.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) transport = "websocket"; else {
          if (0 === this.transports.length) {
            var self = this;
            setTimeout(function() {
              self.emit("error", "No transports available");
            }, 0);
            return;
          }
          transport = this.transports[0];
        }
        this.readyState = "opening";
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      };
      Socket.prototype.setTransport = function(transport) {
        debug("setting transport %s", transport.name);
        var self = this;
        if (this.transport) {
          debug("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", function() {
          self.onDrain();
        }).on("packet", function(packet) {
          self.onPacket(packet);
        }).on("error", function(e) {
          self.onError(e);
        }).on("close", function() {
          self.onClose("transport close");
        });
      };
      Socket.prototype.probe = function(name) {
        debug('probing transport "%s"', name);
        var transport = this.createTransport(name, {
          probe: 1
        });
        var failed = false;
        var self = this;
        Socket.priorWebsocketSuccess = false;
        function onTransportOpen() {
          if (self.onlyBinaryUpgrades) {
            var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
            failed = failed || upgradeLosesBinary;
          }
          if (failed) return;
          debug('probe transport "%s" opened', name);
          transport.send([ {
            type: "ping",
            data: "probe"
          } ]);
          transport.once("packet", function(msg) {
            if (failed) return;
            if ("pong" === msg.type && "probe" === msg.data) {
              debug('probe transport "%s" pong', name);
              self.upgrading = true;
              self.emit("upgrading", transport);
              if (!transport) return;
              Socket.priorWebsocketSuccess = "websocket" === transport.name;
              debug('pausing current transport "%s"', self.transport.name);
              self.transport.pause(function() {
                if (failed) return;
                if ("closed" === self.readyState) return;
                debug("changing transport and sending upgrade packet");
                cleanup();
                self.setTransport(transport);
                transport.send([ {
                  type: "upgrade"
                } ]);
                self.emit("upgrade", transport);
                transport = null;
                self.upgrading = false;
                self.flush();
              });
            } else {
              debug('probe transport "%s" failed', name);
              var err = new Error("probe error");
              err.transport = transport.name;
              self.emit("upgradeError", err);
            }
          });
        }
        function freezeTransport() {
          if (failed) return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        function onerror(err) {
          var error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          debug('probe transport "%s" failed because of error: %s', name, err);
          self.emit("upgradeError", error);
        }
        function onTransportClose() {
          onerror("transport closed");
        }
        function onclose() {
          onerror("socket closed");
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        function cleanup() {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          self.removeListener("close", onclose);
          self.removeListener("upgrading", onupgrade);
        }
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      };
      Socket.prototype.onOpen = function() {
        debug("socket open");
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emit("open");
        this.flush();
        if ("open" === this.readyState && this.upgrade && this.transport.pause) {
          debug("starting upgrade probes");
          for (var i = 0, l = this.upgrades.length; i < l; i++) this.probe(this.upgrades[i]);
        }
      };
      Socket.prototype.onPacket = function(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emit("packet", packet);
          this.emit("heartbeat");
          switch (packet.type) {
           case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;

           case "pong":
            this.setPing();
            this.emit("pong");
            break;

           case "error":
            var err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;

           case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
          }
        } else debug('packet received with socket readyState "%s"', this.readyState);
      };
      Socket.prototype.onHandshake = function(data) {
        this.emit("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        if ("closed" === this.readyState) return;
        this.setPing();
        this.removeListener("heartbeat", this.onHeartbeat);
        this.on("heartbeat", this.onHeartbeat);
      };
      Socket.prototype.onHeartbeat = function(timeout) {
        clearTimeout(this.pingTimeoutTimer);
        var self = this;
        self.pingTimeoutTimer = setTimeout(function() {
          if ("closed" === self.readyState) return;
          self.onClose("ping timeout");
        }, timeout || self.pingInterval + self.pingTimeout);
      };
      Socket.prototype.setPing = function() {
        var self = this;
        clearTimeout(self.pingIntervalTimer);
        self.pingIntervalTimer = setTimeout(function() {
          debug("writing ping packet - expecting pong within %sms", self.pingTimeout);
          self.ping();
          self.onHeartbeat(self.pingTimeout);
        }, self.pingInterval);
      };
      Socket.prototype.ping = function() {
        var self = this;
        this.sendPacket("ping", function() {
          self.emit("ping");
        });
      };
      Socket.prototype.onDrain = function() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
      };
      Socket.prototype.flush = function() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          debug("flushing %d packets in socket", this.writeBuffer.length);
          this.transport.send(this.writeBuffer);
          this.prevBufferLen = this.writeBuffer.length;
          this.emit("flush");
        }
      };
      Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      };
      Socket.prototype.sendPacket = function(type, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = void 0;
        }
        if ("function" === typeof options) {
          fn = options;
          options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) return;
        options = options || {};
        options.compress = false !== options.compress;
        var packet = {
          type: type,
          data: data,
          options: options
        };
        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet);
        fn && this.once("flush", fn);
        this.flush();
      };
      Socket.prototype.close = function() {
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";
          var self = this;
          this.writeBuffer.length ? this.once("drain", function() {
            this.upgrading ? waitForUpgrade() : close();
          }) : this.upgrading ? waitForUpgrade() : close();
        }
        function close() {
          self.onClose("forced close");
          debug("socket closing - telling transport to close");
          self.transport.close();
        }
        function cleanupAndClose() {
          self.removeListener("upgrade", cleanupAndClose);
          self.removeListener("upgradeError", cleanupAndClose);
          close();
        }
        function waitForUpgrade() {
          self.once("upgrade", cleanupAndClose);
          self.once("upgradeError", cleanupAndClose);
        }
        return this;
      };
      Socket.prototype.onError = function(err) {
        debug("socket error %j", err);
        Socket.priorWebsocketSuccess = false;
        this.emit("error", err);
        this.onClose("transport error", err);
      };
      Socket.prototype.onClose = function(reason, desc) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug('socket close with reason: "%s"', reason);
          var self = this;
          clearTimeout(this.pingIntervalTimer);
          clearTimeout(this.pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          this.readyState = "closed";
          this.id = null;
          this.emit("close", reason, desc);
          self.writeBuffer = [];
          self.prevBufferLen = 0;
        }
      };
      Socket.prototype.filterUpgrades = function(upgrades) {
        var filteredUpgrades = [];
        for (var i = 0, j = upgrades.length; i < j; i++) ~index(this.transports, upgrades[i]) && filteredUpgrades.push(upgrades[i]);
        return filteredUpgrades;
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./transport": 28,
    "./transports/index": 29,
    "component-emitter": 24,
    debug: 35,
    "engine.io-parser": 37,
    indexof: 43,
    parseqs: 46,
    parseuri: 47
  } ],
  28: [ function(require, module, exports) {
    var parser = require("engine.io-parser");
    var Emitter = require("component-emitter");
    module.exports = Transport;
    function Transport(opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = "";
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }
    Emitter(Transport.prototype);
    Transport.prototype.onError = function(msg, desc) {
      var err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    };
    Transport.prototype.open = function() {
      if ("closed" === this.readyState || "" === this.readyState) {
        this.readyState = "opening";
        this.doOpen();
      }
      return this;
    };
    Transport.prototype.close = function() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.doClose();
        this.onClose();
      }
      return this;
    };
    Transport.prototype.send = function(packets) {
      if ("open" !== this.readyState) throw new Error("Transport not open");
      this.write(packets);
    };
    Transport.prototype.onOpen = function() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    };
    Transport.prototype.onData = function(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };
    Transport.prototype.onPacket = function(packet) {
      this.emit("packet", packet);
    };
    Transport.prototype.onClose = function() {
      this.readyState = "closed";
      this.emit("close");
    };
  }, {
    "component-emitter": 24,
    "engine.io-parser": 37
  } ],
  29: [ function(require, module, exports) {
    (function(global) {
      var XMLHttpRequest = require("xmlhttprequest-ssl");
      var XHR = require("./polling-xhr");
      var JSONP = require("./polling-jsonp");
      var websocket = require("./websocket");
      exports.polling = polling;
      exports.websocket = websocket;
      function polling(opts) {
        var xhr;
        var xd = false;
        var xs = false;
        var jsonp = false !== opts.jsonp;
        if (global.location) {
          var isSSL = "https:" === location.protocol;
          var port = location.port;
          port || (port = isSSL ? 443 : 80);
          xd = opts.hostname !== location.hostname || port !== opts.port;
          xs = opts.secure !== isSSL;
        }
        opts.xdomain = xd;
        opts.xscheme = xs;
        xhr = new XMLHttpRequest(opts);
        if ("open" in xhr && !opts.forceJSONP) return new XHR(opts);
        if (!jsonp) throw new Error("JSONP disabled");
        return new JSONP(opts);
      }
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./polling-jsonp": 30,
    "./polling-xhr": 31,
    "./websocket": 33,
    "xmlhttprequest-ssl": 34
  } ],
  30: [ function(require, module, exports) {
    (function(global) {
      var Polling = require("./polling");
      var inherit = require("component-inherit");
      module.exports = JSONPPolling;
      var rNewline = /\n/g;
      var rEscapedNewline = /\\n/g;
      var callbacks;
      function empty() {}
      function JSONPPolling(opts) {
        Polling.call(this, opts);
        this.query = this.query || {};
        if (!callbacks) {
          global.___eio || (global.___eio = []);
          callbacks = global.___eio;
        }
        this.index = callbacks.length;
        var self = this;
        callbacks.push(function(msg) {
          self.onData(msg);
        });
        this.query.j = this.index;
        global.document && global.addEventListener && global.addEventListener("beforeunload", function() {
          self.script && (self.script.onerror = empty);
        }, false);
      }
      inherit(JSONPPolling, Polling);
      JSONPPolling.prototype.supportsBinary = false;
      JSONPPolling.prototype.doClose = function() {
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        if (this.form) {
          this.form.parentNode.removeChild(this.form);
          this.form = null;
          this.iframe = null;
        }
        Polling.prototype.doClose.call(this);
      };
      JSONPPolling.prototype.doPoll = function() {
        var self = this;
        var script = document.createElement("script");
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        script.async = true;
        script.src = this.uri();
        script.onerror = function(e) {
          self.onError("jsonp poll error", e);
        };
        var insertAt = document.getElementsByTagName("script")[0];
        insertAt ? insertAt.parentNode.insertBefore(script, insertAt) : (document.head || document.body).appendChild(script);
        this.script = script;
        var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
        isUAgecko && setTimeout(function() {
          var iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      };
      JSONPPolling.prototype.doWrite = function(data, fn) {
        var self = this;
        if (!this.form) {
          var form = document.createElement("form");
          var area = document.createElement("textarea");
          var id = this.iframeId = "eio_iframe_" + this.index;
          var iframe;
          form.className = "socketio";
          form.style.position = "absolute";
          form.style.top = "-1000px";
          form.style.left = "-1000px";
          form.target = id;
          form.method = "POST";
          form.setAttribute("accept-charset", "utf-8");
          area.name = "d";
          form.appendChild(area);
          document.body.appendChild(form);
          this.form = form;
          this.area = area;
        }
        this.form.action = this.uri();
        function complete() {
          initIframe();
          fn();
        }
        function initIframe() {
          if (self.iframe) try {
            self.form.removeChild(self.iframe);
          } catch (e) {
            self.onError("jsonp polling iframe removal error", e);
          }
          try {
            var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
            iframe = document.createElement(html);
          } catch (e) {
            iframe = document.createElement("iframe");
            iframe.name = self.iframeId;
            iframe.src = "javascript:0";
          }
          iframe.id = self.iframeId;
          self.form.appendChild(iframe);
          self.iframe = iframe;
        }
        initIframe();
        data = data.replace(rEscapedNewline, "\\\n");
        this.area.value = data.replace(rNewline, "\\n");
        try {
          this.form.submit();
        } catch (e) {}
        this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
          "complete" === self.iframe.readyState && complete();
        } : this.iframe.onload = complete;
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./polling": 32,
    "component-inherit": 25
  } ],
  31: [ function(require, module, exports) {
    (function(global) {
      var XMLHttpRequest = require("xmlhttprequest-ssl");
      var Polling = require("./polling");
      var Emitter = require("component-emitter");
      var inherit = require("component-inherit");
      var debug = require("debug")("engine.io-client:polling-xhr");
      module.exports = XHR;
      module.exports.Request = Request;
      function empty() {}
      function XHR(opts) {
        Polling.call(this, opts);
        this.requestTimeout = opts.requestTimeout;
        this.extraHeaders = opts.extraHeaders;
        if (global.location) {
          var isSSL = "https:" === location.protocol;
          var port = location.port;
          port || (port = isSSL ? 443 : 80);
          this.xd = opts.hostname !== global.location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
      }
      inherit(XHR, Polling);
      XHR.prototype.supportsBinary = true;
      XHR.prototype.request = function(opts) {
        opts = opts || {};
        opts.uri = this.uri();
        opts.xd = this.xd;
        opts.xs = this.xs;
        opts.agent = this.agent || false;
        opts.supportsBinary = this.supportsBinary;
        opts.enablesXDR = this.enablesXDR;
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        opts.requestTimeout = this.requestTimeout;
        opts.extraHeaders = this.extraHeaders;
        return new Request(opts);
      };
      XHR.prototype.doWrite = function(data, fn) {
        var isBinary = "string" !== typeof data && void 0 !== data;
        var req = this.request({
          method: "POST",
          data: data,
          isBinary: isBinary
        });
        var self = this;
        req.on("success", fn);
        req.on("error", function(err) {
          self.onError("xhr post error", err);
        });
        this.sendXhr = req;
      };
      XHR.prototype.doPoll = function() {
        debug("xhr poll");
        var req = this.request();
        var self = this;
        req.on("data", function(data) {
          self.onData(data);
        });
        req.on("error", function(err) {
          self.onError("xhr poll error", err);
        });
        this.pollXhr = req;
      };
      function Request(opts) {
        this.method = opts.method || "GET";
        this.uri = opts.uri;
        this.xd = !!opts.xd;
        this.xs = !!opts.xs;
        this.async = false !== opts.async;
        this.data = void 0 !== opts.data ? opts.data : null;
        this.agent = opts.agent;
        this.isBinary = opts.isBinary;
        this.supportsBinary = opts.supportsBinary;
        this.enablesXDR = opts.enablesXDR;
        this.requestTimeout = opts.requestTimeout;
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
        this.extraHeaders = opts.extraHeaders;
        this.create();
      }
      Emitter(Request.prototype);
      Request.prototype.create = function() {
        var opts = {
          agent: this.agent,
          xdomain: this.xd,
          xscheme: this.xs,
          enablesXDR: this.enablesXDR
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        var xhr = this.xhr = new XMLHttpRequest(opts);
        var self = this;
        try {
          debug("xhr open %s: %s", this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (var i in this.extraHeaders) this.extraHeaders.hasOwnProperty(i) && xhr.setRequestHeader(i, this.extraHeaders[i]);
            }
          } catch (e) {}
          if ("POST" === this.method) try {
            this.isBinary ? xhr.setRequestHeader("Content-type", "application/octet-stream") : xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {}
          "withCredentials" in xhr && (xhr.withCredentials = true);
          this.requestTimeout && (xhr.timeout = this.requestTimeout);
          if (this.hasXDR()) {
            xhr.onload = function() {
              self.onLoad();
            };
            xhr.onerror = function() {
              self.onError(xhr.responseText);
            };
          } else xhr.onreadystatechange = function() {
            if (2 === xhr.readyState) try {
              var contentType = xhr.getResponseHeader("Content-Type");
              self.supportsBinary && "application/octet-stream" === contentType && (xhr.responseType = "arraybuffer");
            } catch (e) {}
            if (4 !== xhr.readyState) return;
            200 === xhr.status || 1223 === xhr.status ? self.onLoad() : setTimeout(function() {
              self.onError(xhr.status);
            }, 0);
          };
          debug("xhr data %s", this.data);
          xhr.send(this.data);
        } catch (e) {
          setTimeout(function() {
            self.onError(e);
          }, 0);
          return;
        }
        if (global.document) {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      };
      Request.prototype.onSuccess = function() {
        this.emit("success");
        this.cleanup();
      };
      Request.prototype.onData = function(data) {
        this.emit("data", data);
        this.onSuccess();
      };
      Request.prototype.onError = function(err) {
        this.emit("error", err);
        this.cleanup(true);
      };
      Request.prototype.cleanup = function(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) return;
        this.hasXDR() ? this.xhr.onload = this.xhr.onerror = empty : this.xhr.onreadystatechange = empty;
        if (fromError) try {
          this.xhr.abort();
        } catch (e) {}
        global.document && delete Request.requests[this.index];
        this.xhr = null;
      };
      Request.prototype.onLoad = function() {
        var data;
        try {
          var contentType;
          try {
            contentType = this.xhr.getResponseHeader("Content-Type");
          } catch (e) {}
          data = "application/octet-stream" === contentType && this.xhr.response || this.xhr.responseText;
        } catch (e) {
          this.onError(e);
        }
        null != data && this.onData(data);
      };
      Request.prototype.hasXDR = function() {
        return "undefined" !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
      };
      Request.prototype.abort = function() {
        this.cleanup();
      };
      Request.requestsCount = 0;
      Request.requests = {};
      global.document && (global.attachEvent ? global.attachEvent("onunload", unloadHandler) : global.addEventListener && global.addEventListener("beforeunload", unloadHandler, false));
      function unloadHandler() {
        for (var i in Request.requests) Request.requests.hasOwnProperty(i) && Request.requests[i].abort();
      }
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./polling": 32,
    "component-emitter": 24,
    "component-inherit": 25,
    debug: 35,
    "xmlhttprequest-ssl": 34
  } ],
  32: [ function(require, module, exports) {
    var Transport = require("../transport");
    var parseqs = require("parseqs");
    var parser = require("engine.io-parser");
    var inherit = require("component-inherit");
    var yeast = require("yeast");
    var debug = require("debug")("engine.io-client:polling");
    module.exports = Polling;
    var hasXHR2 = function() {
      var XMLHttpRequest = require("xmlhttprequest-ssl");
      var xhr = new XMLHttpRequest({
        xdomain: false
      });
      return null != xhr.responseType;
    }();
    function Polling(opts) {
      var forceBase64 = opts && opts.forceBase64;
      hasXHR2 && !forceBase64 || (this.supportsBinary = false);
      Transport.call(this, opts);
    }
    inherit(Polling, Transport);
    Polling.prototype.name = "polling";
    Polling.prototype.doOpen = function() {
      this.poll();
    };
    Polling.prototype.pause = function(onPause) {
      var self = this;
      this.readyState = "pausing";
      function pause() {
        debug("paused");
        self.readyState = "paused";
        onPause();
      }
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else pause();
    };
    Polling.prototype.poll = function() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    };
    Polling.prototype.onData = function(data) {
      var self = this;
      debug("polling got data %s", data);
      var callback = function(packet, index, total) {
        "opening" === self.readyState && self.onOpen();
        if ("close" === packet.type) {
          self.onClose();
          return false;
        }
        self.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType, callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emit("pollComplete");
        "open" === this.readyState ? this.poll() : debug('ignoring poll - transport state "%s"', this.readyState);
      }
    };
    Polling.prototype.doClose = function() {
      var self = this;
      function close() {
        debug("writing close packet");
        self.write([ {
          type: "close"
        } ]);
      }
      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    };
    Polling.prototype.write = function(packets) {
      var self = this;
      this.writable = false;
      var callbackfn = function() {
        self.writable = true;
        self.emit("drain");
      };
      parser.encodePayload(packets, this.supportsBinary, function(data) {
        self.doWrite(data, callbackfn);
      });
    };
    Polling.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? "https" : "http";
      var port = "";
      false !== this.timestampRequests && (query[this.timestampParam] = yeast());
      this.supportsBinary || query.sid || (query.b64 = 1);
      query = parseqs.encode(query);
      this.port && ("https" === schema && 443 !== Number(this.port) || "http" === schema && 80 !== Number(this.port)) && (port = ":" + this.port);
      query.length && (query = "?" + query);
      var ipv6 = -1 !== this.hostname.indexOf(":");
      return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
    };
  }, {
    "../transport": 28,
    "component-inherit": 25,
    debug: 35,
    "engine.io-parser": 37,
    parseqs: 46,
    "xmlhttprequest-ssl": 34,
    yeast: 63
  } ],
  33: [ function(require, module, exports) {
    (function(global) {
      var Transport = require("../transport");
      var parser = require("engine.io-parser");
      var parseqs = require("parseqs");
      var inherit = require("component-inherit");
      var yeast = require("yeast");
      var debug = require("debug")("engine.io-client:websocket");
      var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
      var NodeWebSocket;
      if ("undefined" === typeof window) try {
        NodeWebSocket = require("ws");
      } catch (e) {}
      var WebSocket = BrowserWebSocket;
      WebSocket || "undefined" !== typeof window || (WebSocket = NodeWebSocket);
      module.exports = WS;
      function WS(opts) {
        var forceBase64 = opts && opts.forceBase64;
        forceBase64 && (this.supportsBinary = false);
        this.perMessageDeflate = opts.perMessageDeflate;
        this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
        this.protocols = opts.protocols;
        this.usingBrowserWebSocket || (WebSocket = NodeWebSocket);
        Transport.call(this, opts);
      }
      inherit(WS, Transport);
      WS.prototype.name = "websocket";
      WS.prototype.supportsBinary = true;
      WS.prototype.doOpen = function() {
        if (!this.check()) return;
        var uri = this.uri();
        var protocols = this.protocols;
        var opts = {
          agent: this.agent,
          perMessageDeflate: this.perMessageDeflate
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        this.extraHeaders && (opts.headers = this.extraHeaders);
        this.localAddress && (opts.localAddress = this.localAddress);
        try {
          this.ws = this.usingBrowserWebSocket ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emit("error", err);
        }
        void 0 === this.ws.binaryType && (this.supportsBinary = false);
        if (this.ws.supports && this.ws.supports.binary) {
          this.supportsBinary = true;
          this.ws.binaryType = "nodebuffer";
        } else this.ws.binaryType = "arraybuffer";
        this.addEventListeners();
      };
      WS.prototype.addEventListeners = function() {
        var self = this;
        this.ws.onopen = function() {
          self.onOpen();
        };
        this.ws.onclose = function() {
          self.onClose();
        };
        this.ws.onmessage = function(ev) {
          self.onData(ev.data);
        };
        this.ws.onerror = function(e) {
          self.onError("websocket error", e);
        };
      };
      WS.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        var total = packets.length;
        for (var i = 0, l = total; i < l; i++) (function(packet) {
          parser.encodePacket(packet, self.supportsBinary, function(data) {
            if (!self.usingBrowserWebSocket) {
              var opts = {};
              packet.options && (opts.compress = packet.options.compress);
              if (self.perMessageDeflate) {
                var len = "string" === typeof data ? global.Buffer.byteLength(data) : data.length;
                len < self.perMessageDeflate.threshold && (opts.compress = false);
              }
            }
            try {
              self.usingBrowserWebSocket ? self.ws.send(data) : self.ws.send(data, opts);
            } catch (e) {
              debug("websocket closed before onclose event");
            }
            --total || done();
          });
        })(packets[i]);
        function done() {
          self.emit("flush");
          setTimeout(function() {
            self.writable = true;
            self.emit("drain");
          }, 0);
        }
      };
      WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this);
      };
      WS.prototype.doClose = function() {
        "undefined" !== typeof this.ws && this.ws.close();
      };
      WS.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? "wss" : "ws";
        var port = "";
        this.port && ("wss" === schema && 443 !== Number(this.port) || "ws" === schema && 80 !== Number(this.port)) && (port = ":" + this.port);
        this.timestampRequests && (query[this.timestampParam] = yeast());
        this.supportsBinary || (query.b64 = 1);
        query = parseqs.encode(query);
        query.length && (query = "?" + query);
        var ipv6 = -1 !== this.hostname.indexOf(":");
        return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
      };
      WS.prototype.check = function() {
        return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "../transport": 28,
    "component-inherit": 25,
    debug: 35,
    "engine.io-parser": 37,
    parseqs: 46,
    ws: 2,
    yeast: 63
  } ],
  34: [ function(require, module, exports) {
    (function(global) {
      var hasCORS = require("has-cors");
      module.exports = function(opts) {
        var xdomain = opts.xdomain;
        var xscheme = opts.xscheme;
        var enablesXDR = opts.enablesXDR;
        try {
          if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) return new XMLHttpRequest();
        } catch (e) {}
        try {
          if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) return new XDomainRequest();
        } catch (e) {}
        if (!xdomain) try {
          return new (global[[ "Active" ].concat("Object").join("X")])("Microsoft.XMLHTTP");
        } catch (e) {}
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "has-cors": 42
  } ],
  35: [ function(require, module, exports) {
    (function(process) {
      exports = module.exports = require("./debug");
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];
      function useColors() {
        if ("undefined" !== typeof window && window.process && "renderer" === window.process.type) return true;
        if ("undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
        return "undefined" !== typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      exports.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };
      function formatArgs(args) {
        var useColors = this.useColors;
        args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
        if (!useColors) return;
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
          if ("%%" === match) return;
          index++;
          "%c" === match && (lastC = index);
        });
        args.splice(lastC, 0, c);
      }
      function log() {
        return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
        } catch (e) {}
      }
      function load() {
        var r;
        try {
          r = exports.storage.debug;
        } catch (e) {}
        !r && "undefined" !== typeof process && "env" in process && (r = process.env.DEBUG);
        return r;
      }
      exports.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }).call(this, require("_process"));
  }, {
    "./debug": 36,
    _process: 6
  } ],
  36: [ function(require, module, exports) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.instances = [];
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled) return;
        var self = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) args[i] = arguments[i];
        args[0] = exports.coerce(args[0]);
        "string" !== typeof args[0] && args.unshift("%O");
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if ("%%" === match) return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      "function" === typeof exports.init && exports.init(debug);
      exports.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = exports.instances.indexOf(this);
      if (-1 !== index) {
        exports.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var i;
      var split = ("string" === typeof namespaces ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        "-" === namespaces[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$"));
      }
      for (i = 0; i < exports.instances.length; i++) {
        var instance = exports.instances[i];
        instance.enabled = exports.enabled(instance.namespace);
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      if ("*" === name[name.length - 1]) return true;
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;
      for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }, {
    ms: 45
  } ],
  37: [ function(require, module, exports) {
    (function(global) {
      var keys = require("./keys");
      var hasBinary = require("has-binary2");
      var sliceBuffer = require("arraybuffer.slice");
      var after = require("after");
      var utf8 = require("./utf8");
      var base64encoder;
      global && global.ArrayBuffer && (base64encoder = require("base64-arraybuffer"));
      var isAndroid = "undefined" !== typeof navigator && /Android/i.test(navigator.userAgent);
      var isPhantomJS = "undefined" !== typeof navigator && /PhantomJS/i.test(navigator.userAgent);
      var dontSendBlobs = isAndroid || isPhantomJS;
      exports.protocol = 3;
      var packets = exports.packets = {
        open: 0,
        close: 1,
        ping: 2,
        pong: 3,
        message: 4,
        upgrade: 5,
        noop: 6
      };
      var packetslist = keys(packets);
      var err = {
        type: "error",
        data: "parser error"
      };
      var Blob = require("blob");
      exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
        if ("function" === typeof supportsBinary) {
          callback = supportsBinary;
          supportsBinary = false;
        }
        if ("function" === typeof utf8encode) {
          callback = utf8encode;
          utf8encode = null;
        }
        var data = void 0 === packet.data ? void 0 : packet.data.buffer || packet.data;
        if (global.ArrayBuffer && data instanceof ArrayBuffer) return encodeArrayBuffer(packet, supportsBinary, callback);
        if (Blob && data instanceof global.Blob) return encodeBlob(packet, supportsBinary, callback);
        if (data && data.base64) return encodeBase64Object(packet, callback);
        var encoded = packets[packet.type];
        void 0 !== packet.data && (encoded += utf8encode ? utf8.encode(String(packet.data), {
          strict: false
        }) : String(packet.data));
        return callback("" + encoded);
      };
      function encodeBase64Object(packet, callback) {
        var message = "b" + exports.packets[packet.type] + packet.data.data;
        return callback(message);
      }
      function encodeArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
        var data = packet.data;
        var contentArray = new Uint8Array(data);
        var resultBuffer = new Uint8Array(1 + data.byteLength);
        resultBuffer[0] = packets[packet.type];
        for (var i = 0; i < contentArray.length; i++) resultBuffer[i + 1] = contentArray[i];
        return callback(resultBuffer.buffer);
      }
      function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
        var fr = new FileReader();
        fr.onload = function() {
          packet.data = fr.result;
          exports.encodePacket(packet, supportsBinary, true, callback);
        };
        return fr.readAsArrayBuffer(packet.data);
      }
      function encodeBlob(packet, supportsBinary, callback) {
        if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
        if (dontSendBlobs) return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
        var length = new Uint8Array(1);
        length[0] = packets[packet.type];
        var blob = new Blob([ length.buffer, packet.data ]);
        return callback(blob);
      }
      exports.encodeBase64Packet = function(packet, callback) {
        var message = "b" + exports.packets[packet.type];
        if (Blob && packet.data instanceof global.Blob) {
          var fr = new FileReader();
          fr.onload = function() {
            var b64 = fr.result.split(",")[1];
            callback(message + b64);
          };
          return fr.readAsDataURL(packet.data);
        }
        var b64data;
        try {
          b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
        } catch (e) {
          var typed = new Uint8Array(packet.data);
          var basic = new Array(typed.length);
          for (var i = 0; i < typed.length; i++) basic[i] = typed[i];
          b64data = String.fromCharCode.apply(null, basic);
        }
        message += global.btoa(b64data);
        return callback(message);
      };
      exports.decodePacket = function(data, binaryType, utf8decode) {
        if (void 0 === data) return err;
        if ("string" === typeof data) {
          if ("b" === data.charAt(0)) return exports.decodeBase64Packet(data.substr(1), binaryType);
          if (utf8decode) {
            data = tryDecode(data);
            if (false === data) return err;
          }
          var type = data.charAt(0);
          if (Number(type) != type || !packetslist[type]) return err;
          return data.length > 1 ? {
            type: packetslist[type],
            data: data.substring(1)
          } : {
            type: packetslist[type]
          };
        }
        var asArray = new Uint8Array(data);
        var type = asArray[0];
        var rest = sliceBuffer(data, 1);
        Blob && "blob" === binaryType && (rest = new Blob([ rest ]));
        return {
          type: packetslist[type],
          data: rest
        };
      };
      function tryDecode(data) {
        try {
          data = utf8.decode(data, {
            strict: false
          });
        } catch (e) {
          return false;
        }
        return data;
      }
      exports.decodeBase64Packet = function(msg, binaryType) {
        var type = packetslist[msg.charAt(0)];
        if (!base64encoder) return {
          type: type,
          data: {
            base64: true,
            data: msg.substr(1)
          }
        };
        var data = base64encoder.decode(msg.substr(1));
        "blob" === binaryType && Blob && (data = new Blob([ data ]));
        return {
          type: type,
          data: data
        };
      };
      exports.encodePayload = function(packets, supportsBinary, callback) {
        if ("function" === typeof supportsBinary) {
          callback = supportsBinary;
          supportsBinary = null;
        }
        var isBinary = hasBinary(packets);
        if (supportsBinary && isBinary) {
          if (Blob && !dontSendBlobs) return exports.encodePayloadAsBlob(packets, callback);
          return exports.encodePayloadAsArrayBuffer(packets, callback);
        }
        if (!packets.length) return callback("0:");
        function setLengthHeader(message) {
          return message.length + ":" + message;
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, !!isBinary && supportsBinary, false, function(message) {
            doneCallback(null, setLengthHeader(message));
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(results.join(""));
        });
      };
      function map(ary, each, done) {
        var result = new Array(ary.length);
        var next = after(ary.length, done);
        var eachWithIndex = function(i, el, cb) {
          each(el, function(error, msg) {
            result[i] = msg;
            cb(error, result);
          });
        };
        for (var i = 0; i < ary.length; i++) eachWithIndex(i, ary[i], next);
      }
      exports.decodePayload = function(data, binaryType, callback) {
        if ("string" !== typeof data) return exports.decodePayloadAsBinary(data, binaryType, callback);
        if ("function" === typeof binaryType) {
          callback = binaryType;
          binaryType = null;
        }
        var packet;
        if ("" === data) return callback(err, 0, 1);
        var length = "", n, msg;
        for (var i = 0, l = data.length; i < l; i++) {
          var chr = data.charAt(i);
          if (":" !== chr) {
            length += chr;
            continue;
          }
          if ("" === length || length != (n = Number(length))) return callback(err, 0, 1);
          msg = data.substr(i + 1, n);
          if (length != msg.length) return callback(err, 0, 1);
          if (msg.length) {
            packet = exports.decodePacket(msg, binaryType, false);
            if (err.type === packet.type && err.data === packet.data) return callback(err, 0, 1);
            var ret = callback(packet, i + n, l);
            if (false === ret) return;
          }
          i += n;
          length = "";
        }
        if ("" !== length) return callback(err, 0, 1);
      };
      exports.encodePayloadAsArrayBuffer = function(packets, callback) {
        if (!packets.length) return callback(new ArrayBuffer(0));
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(data) {
            return doneCallback(null, data);
          });
        }
        map(packets, encodeOne, function(err, encodedPackets) {
          var totalLength = encodedPackets.reduce(function(acc, p) {
            var len;
            len = "string" === typeof p ? p.length : p.byteLength;
            return acc + len.toString().length + len + 2;
          }, 0);
          var resultArray = new Uint8Array(totalLength);
          var bufferIndex = 0;
          encodedPackets.forEach(function(p) {
            var isString = "string" === typeof p;
            var ab = p;
            if (isString) {
              var view = new Uint8Array(p.length);
              for (var i = 0; i < p.length; i++) view[i] = p.charCodeAt(i);
              ab = view.buffer;
            }
            resultArray[bufferIndex++] = isString ? 0 : 1;
            var lenStr = ab.byteLength.toString();
            for (var i = 0; i < lenStr.length; i++) resultArray[bufferIndex++] = parseInt(lenStr[i]);
            resultArray[bufferIndex++] = 255;
            var view = new Uint8Array(ab);
            for (var i = 0; i < view.length; i++) resultArray[bufferIndex++] = view[i];
          });
          return callback(resultArray.buffer);
        });
      };
      exports.encodePayloadAsBlob = function(packets, callback) {
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(encoded) {
            var binaryIdentifier = new Uint8Array(1);
            binaryIdentifier[0] = 1;
            if ("string" === typeof encoded) {
              var view = new Uint8Array(encoded.length);
              for (var i = 0; i < encoded.length; i++) view[i] = encoded.charCodeAt(i);
              encoded = view.buffer;
              binaryIdentifier[0] = 0;
            }
            var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
            var lenStr = len.toString();
            var lengthAry = new Uint8Array(lenStr.length + 1);
            for (var i = 0; i < lenStr.length; i++) lengthAry[i] = parseInt(lenStr[i]);
            lengthAry[lenStr.length] = 255;
            if (Blob) {
              var blob = new Blob([ binaryIdentifier.buffer, lengthAry.buffer, encoded ]);
              doneCallback(null, blob);
            }
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(new Blob(results));
        });
      };
      exports.decodePayloadAsBinary = function(data, binaryType, callback) {
        if ("function" === typeof binaryType) {
          callback = binaryType;
          binaryType = null;
        }
        var bufferTail = data;
        var buffers = [];
        while (bufferTail.byteLength > 0) {
          var tailArray = new Uint8Array(bufferTail);
          var isString = 0 === tailArray[0];
          var msgLength = "";
          for (var i = 1; ;i++) {
            if (255 === tailArray[i]) break;
            if (msgLength.length > 310) return callback(err, 0, 1);
            msgLength += tailArray[i];
          }
          bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
          msgLength = parseInt(msgLength);
          var msg = sliceBuffer(bufferTail, 0, msgLength);
          if (isString) try {
            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
          } catch (e) {
            var typed = new Uint8Array(msg);
            msg = "";
            for (var i = 0; i < typed.length; i++) msg += String.fromCharCode(typed[i]);
          }
          buffers.push(msg);
          bufferTail = sliceBuffer(bufferTail, msgLength);
        }
        var total = buffers.length;
        buffers.forEach(function(buffer, i) {
          callback(exports.decodePacket(buffer, binaryType, true), i, total);
        });
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./keys": 38,
    "./utf8": 39,
    after: 18,
    "arraybuffer.slice": 19,
    "base64-arraybuffer": 21,
    blob: 22,
    "has-binary2": 41
  } ],
  38: [ function(require, module, exports) {
    module.exports = Object.keys || function keys(obj) {
      var arr = [];
      var has = Object.prototype.hasOwnProperty;
      for (var i in obj) has.call(obj, i) && arr.push(i);
      return arr;
    };
  }, {} ],
  39: [ function(require, module, exports) {
    (function(global) {
      (function(root) {
        var freeExports = "object" == typeof exports && exports;
        var freeModule = "object" == typeof module && module && module.exports == freeExports && module;
        var freeGlobal = "object" == typeof global && global;
        freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal || (root = freeGlobal);
        var stringFromCharCode = String.fromCharCode;
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          var value;
          var extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if (56320 == (64512 & extra)) output.push(((1023 & value) << 10) + (1023 & extra) + 65536); else {
                output.push(value);
                counter--;
              }
            } else output.push(value);
          }
          return output;
        }
        function ucs2encode(array) {
          var length = array.length;
          var index = -1;
          var value;
          var output = "";
          while (++index < length) {
            value = array[index];
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | 1023 & value;
            }
            output += stringFromCharCode(value);
          }
          return output;
        }
        function checkScalarValue(codePoint, strict) {
          if (codePoint >= 55296 && codePoint <= 57343) {
            if (strict) throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
            return false;
          }
          return true;
        }
        function createByte(codePoint, shift) {
          return stringFromCharCode(codePoint >> shift & 63 | 128);
        }
        function encodeCodePoint(codePoint, strict) {
          if (0 == (4294967168 & codePoint)) return stringFromCharCode(codePoint);
          var symbol = "";
          if (0 == (4294965248 & codePoint)) symbol = stringFromCharCode(codePoint >> 6 & 31 | 192); else if (0 == (4294901760 & codePoint)) {
            checkScalarValue(codePoint, strict) || (codePoint = 65533);
            symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
            symbol += createByte(codePoint, 6);
          } else if (0 == (4292870144 & codePoint)) {
            symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
            symbol += createByte(codePoint, 12);
            symbol += createByte(codePoint, 6);
          }
          symbol += stringFromCharCode(63 & codePoint | 128);
          return symbol;
        }
        function utf8encode(string, opts) {
          opts = opts || {};
          var strict = false !== opts.strict;
          var codePoints = ucs2decode(string);
          var length = codePoints.length;
          var index = -1;
          var codePoint;
          var byteString = "";
          while (++index < length) {
            codePoint = codePoints[index];
            byteString += encodeCodePoint(codePoint, strict);
          }
          return byteString;
        }
        function readContinuationByte() {
          if (byteIndex >= byteCount) throw Error("Invalid byte index");
          var continuationByte = 255 & byteArray[byteIndex];
          byteIndex++;
          if (128 == (192 & continuationByte)) return 63 & continuationByte;
          throw Error("Invalid continuation byte");
        }
        function decodeSymbol(strict) {
          var byte1;
          var byte2;
          var byte3;
          var byte4;
          var codePoint;
          if (byteIndex > byteCount) throw Error("Invalid byte index");
          if (byteIndex == byteCount) return false;
          byte1 = 255 & byteArray[byteIndex];
          byteIndex++;
          if (0 == (128 & byte1)) return byte1;
          if (192 == (224 & byte1)) {
            byte2 = readContinuationByte();
            codePoint = (31 & byte1) << 6 | byte2;
            if (codePoint >= 128) return codePoint;
            throw Error("Invalid continuation byte");
          }
          if (224 == (240 & byte1)) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            codePoint = (15 & byte1) << 12 | byte2 << 6 | byte3;
            if (codePoint >= 2048) return checkScalarValue(codePoint, strict) ? codePoint : 65533;
            throw Error("Invalid continuation byte");
          }
          if (240 == (248 & byte1)) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            byte4 = readContinuationByte();
            codePoint = (7 & byte1) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (codePoint >= 65536 && codePoint <= 1114111) return codePoint;
          }
          throw Error("Invalid UTF-8 detected");
        }
        var byteArray;
        var byteCount;
        var byteIndex;
        function utf8decode(byteString, opts) {
          opts = opts || {};
          var strict = false !== opts.strict;
          byteArray = ucs2decode(byteString);
          byteCount = byteArray.length;
          byteIndex = 0;
          var codePoints = [];
          var tmp;
          while (false !== (tmp = decodeSymbol(strict))) codePoints.push(tmp);
          return ucs2encode(codePoints);
        }
        var utf8 = {
          version: "2.1.2",
          encode: utf8encode,
          decode: utf8decode
        };
        if ("function" == typeof define && "object" == typeof define.amd && define.amd) define(function() {
          return utf8;
        }); else if (freeExports && !freeExports.nodeType) if (freeModule) freeModule.exports = utf8; else {
          var object = {};
          var hasOwnProperty = object.hasOwnProperty;
          for (var key in utf8) hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
        } else root.utf8 = utf8;
      })(this);
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  40: [ function(require, module, exports) {
    "use strict";
    function _interopDefault(ex) {
      return ex && "object" === typeof ex && "default" in ex ? ex["default"] : ex;
    }
    require("@firebase/polyfill");
    var firebase = _interopDefault(require("@firebase/app"));
    require("@firebase/auth");
    require("@firebase/database");
    require("@firebase/firestore");
    require("@firebase/functions");
    require("@firebase/messaging");
    require("@firebase/storage");
    console.warn("\nIt looks like you're using the development build of the Firebase JS SDK.\nWhen deploying Firebase apps to production, it is advisable to only import\nthe individual SDK components you intend to use.\n\nFor the module builds, these are available in the following manner\n(replace <PACKAGE> with the name of a component - i.e. auth, database, etc):\n\nCommonJS Modules:\nconst firebase = require('firebase/app');\nrequire('firebase/<PACKAGE>');\n\nES Modules:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n");
    module.exports = firebase;
  }, {
    "@firebase/app": 7,
    "@firebase/auth": 8,
    "@firebase/database": 9,
    "@firebase/firestore": 10,
    "@firebase/functions": 11,
    "@firebase/messaging": 13,
    "@firebase/polyfill": 14,
    "@firebase/storage": 15
  } ],
  41: [ function(require, module, exports) {
    (function(Buffer) {
      var isArray = require("isarray");
      var toString = Object.prototype.toString;
      var withNativeBlob = "function" === typeof Blob || "undefined" !== typeof Blob && "[object BlobConstructor]" === toString.call(Blob);
      var withNativeFile = "function" === typeof File || "undefined" !== typeof File && "[object FileConstructor]" === toString.call(File);
      module.exports = hasBinary;
      function hasBinary(obj) {
        if (!obj || "object" !== typeof obj) return false;
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) if (hasBinary(obj[i])) return true;
          return false;
        }
        if ("function" === typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(obj) || "function" === typeof ArrayBuffer && obj instanceof ArrayBuffer || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) return true;
        if (obj.toJSON && "function" === typeof obj.toJSON && 1 === arguments.length) return hasBinary(obj.toJSON(), true);
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;
        return false;
      }
    }).call(this, require("buffer").Buffer);
  }, {
    buffer: 3,
    isarray: 44
  } ],
  42: [ function(require, module, exports) {
    try {
      module.exports = "undefined" !== typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
      module.exports = false;
    }
  }, {} ],
  43: [ function(require, module, exports) {
    var indexOf = [].indexOf;
    module.exports = function(arr, obj) {
      if (indexOf) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) if (arr[i] === obj) return i;
      return -1;
    };
  }, {} ],
  44: [ function(require, module, exports) {
    arguments[4][4][0].apply(exports, arguments);
  }, {
    dup: 4
  } ],
  45: [ function(require, module, exports) {
    var s = 1e3;
    var m = 60 * s;
    var h = 60 * m;
    var d = 24 * h;
    var y = 365.25 * d;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if ("string" === type && val.length > 0) return parse(val);
      if ("number" === type && false === isNaN(val)) return options.long ? fmtLong(val) : fmtShort(val);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
       case "years":
       case "year":
       case "yrs":
       case "yr":
       case "y":
        return n * y;

       case "days":
       case "day":
       case "d":
        return n * d;

       case "hours":
       case "hour":
       case "hrs":
       case "hr":
       case "h":
        return n * h;

       case "minutes":
       case "minute":
       case "mins":
       case "min":
       case "m":
        return n * m;

       case "seconds":
       case "second":
       case "secs":
       case "sec":
       case "s":
        return n * s;

       case "milliseconds":
       case "millisecond":
       case "msecs":
       case "msec":
       case "ms":
        return n;

       default:
        return;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) return Math.round(ms / d) + "d";
      if (ms >= h) return Math.round(ms / h) + "h";
      if (ms >= m) return Math.round(ms / m) + "m";
      if (ms >= s) return Math.round(ms / s) + "s";
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < 1.5 * n) return Math.floor(ms / n) + " " + name;
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }, {} ],
  46: [ function(require, module, exports) {
    exports.encode = function(obj) {
      var str = "";
      for (var i in obj) if (obj.hasOwnProperty(i)) {
        str.length && (str += "&");
        str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
      }
      return str;
    };
    exports.decode = function(qs) {
      var qry = {};
      var pairs = qs.split("&");
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
  }, {} ],
  47: [ function(require, module, exports) {
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ];
    module.exports = function parseuri(str) {
      var src = str, b = str.indexOf("["), e = str.indexOf("]");
      -1 != b && -1 != e && (str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length));
      var m = re.exec(str || ""), uri = {}, i = 14;
      while (i--) uri[parts[i]] = m[i] || "";
      if (-1 != b && -1 != e) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      return uri;
    };
  }, {} ],
  48: [ function(require, module, exports) {
    var url = require("./url");
    var parser = require("socket.io-parser");
    var Manager = require("./manager");
    var debug = require("debug")("socket.io-client");
    module.exports = exports = lookup;
    var cache = exports.managers = {};
    function lookup(uri, opts) {
      if ("object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      var parsed = url(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache[id] && path in cache[id].nsps;
      var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
      var io;
      if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug("new io instance for %s", source);
          cache[id] = Manager(source, opts);
        }
        io = cache[id];
      }
      parsed.query && !opts.query && (opts.query = parsed.query);
      return io.socket(parsed.path, opts);
    }
    exports.protocol = parser.protocol;
    exports.connect = lookup;
    exports.Manager = require("./manager");
    exports.Socket = require("./socket");
  }, {
    "./manager": 49,
    "./socket": 51,
    "./url": 52,
    debug: 53,
    "socket.io-parser": 56
  } ],
  49: [ function(require, module, exports) {
    var eio = require("engine.io-client");
    var Socket = require("./socket");
    var Emitter = require("component-emitter");
    var parser = require("socket.io-parser");
    var on = require("./on");
    var bind = require("component-bind");
    var debug = require("debug")("socket.io-client:manager");
    var indexOf = require("indexof");
    var Backoff = require("backo2");
    var has = Object.prototype.hasOwnProperty;
    module.exports = Manager;
    function Manager(uri, opts) {
      if (!(this instanceof Manager)) return new Manager(uri, opts);
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(false !== opts.reconnection);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor(opts.randomizationFactor || .5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
      this.readyState = "closed";
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      var _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this.autoConnect = false !== opts.autoConnect;
      this.autoConnect && this.open();
    }
    Manager.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) has.call(this.nsps, nsp) && this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    };
    Manager.prototype.updateSocketIds = function() {
      for (var nsp in this.nsps) has.call(this.nsps, nsp) && (this.nsps[nsp].id = this.generateId(nsp));
    };
    Manager.prototype.generateId = function(nsp) {
      return ("/" === nsp ? "" : nsp + "#") + this.engine.id;
    };
    Emitter(Manager.prototype);
    Manager.prototype.reconnection = function(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    };
    Manager.prototype.reconnectionAttempts = function(v) {
      if (!arguments.length) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    Manager.prototype.reconnectionDelay = function(v) {
      if (!arguments.length) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };
    Manager.prototype.randomizationFactor = function(v) {
      if (!arguments.length) return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };
    Manager.prototype.reconnectionDelayMax = function(v) {
      if (!arguments.length) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };
    Manager.prototype.timeout = function(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    };
    Manager.prototype.maybeReconnectOnOpen = function() {
      !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
    };
    Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
      debug("readyState %s", this.readyState);
      if (~this.readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = "opening";
      this.skipReconnect = false;
      var openSub = on(socket, "open", function() {
        self.onopen();
        fn && fn();
      });
      var errorSub = on(socket, "error", function(data) {
        debug("connect_error");
        self.cleanup();
        self.readyState = "closed";
        self.emitAll("connect_error", data);
        if (fn) {
          var err = new Error("Connection error");
          err.data = data;
          fn(err);
        } else self.maybeReconnectOnOpen();
      });
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        var timer = setTimeout(function() {
          debug("connect attempt timed out after %d", timeout);
          openSub.destroy();
          socket.close();
          socket.emit("error", "timeout");
          self.emitAll("connect_timeout", timeout);
        }, timeout);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    };
    Manager.prototype.onopen = function() {
      debug("open");
      this.cleanup();
      this.readyState = "open";
      this.emit("open");
      var socket = this.engine;
      this.subs.push(on(socket, "data", bind(this, "ondata")));
      this.subs.push(on(socket, "ping", bind(this, "onping")));
      this.subs.push(on(socket, "pong", bind(this, "onpong")));
      this.subs.push(on(socket, "error", bind(this, "onerror")));
      this.subs.push(on(socket, "close", bind(this, "onclose")));
      this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")));
    };
    Manager.prototype.onping = function() {
      this.lastPing = new Date();
      this.emitAll("ping");
    };
    Manager.prototype.onpong = function() {
      this.emitAll("pong", new Date() - this.lastPing);
    };
    Manager.prototype.ondata = function(data) {
      this.decoder.add(data);
    };
    Manager.prototype.ondecoded = function(packet) {
      this.emit("packet", packet);
    };
    Manager.prototype.onerror = function(err) {
      debug("error", err);
      this.emitAll("error", err);
    };
    Manager.prototype.socket = function(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self = this;
        socket.on("connecting", onConnecting);
        socket.on("connect", function() {
          socket.id = self.generateId(nsp);
        });
        this.autoConnect && onConnecting();
      }
      function onConnecting() {
        ~indexOf(self.connecting, socket) || self.connecting.push(socket);
      }
      return socket;
    };
    Manager.prototype.destroy = function(socket) {
      var index = indexOf(this.connecting, socket);
      ~index && this.connecting.splice(index, 1);
      if (this.connecting.length) return;
      this.close();
    };
    Manager.prototype.packet = function(packet) {
      debug("writing packet %j", packet);
      var self = this;
      packet.query && 0 === packet.type && (packet.nsp += "?" + packet.query);
      if (self.encoding) self.packetBuffer.push(packet); else {
        self.encoding = true;
        this.encoder.encode(packet, function(encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) self.engine.write(encodedPackets[i], packet.options);
          self.encoding = false;
          self.processPacketQueue();
        });
      }
    };
    Manager.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };
    Manager.prototype.cleanup = function() {
      debug("cleanup");
      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }
      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;
      this.decoder.destroy();
    };
    Manager.prototype.close = Manager.prototype.disconnect = function() {
      debug("disconnect");
      this.skipReconnect = true;
      this.reconnecting = false;
      "opening" === this.readyState && this.cleanup();
      this.backoff.reset();
      this.readyState = "closed";
      this.engine && this.engine.close();
    };
    Manager.prototype.onclose = function(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this.readyState = "closed";
      this.emit("close", reason);
      this._reconnection && !this.skipReconnect && this.reconnect();
    };
    Manager.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect) return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitAll("reconnect_failed");
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this.reconnecting = true;
        var timer = setTimeout(function() {
          if (self.skipReconnect) return;
          debug("attempting reconnect");
          self.emitAll("reconnect_attempt", self.backoff.attempts);
          self.emitAll("reconnecting", self.backoff.attempts);
          if (self.skipReconnect) return;
          self.open(function(err) {
            if (err) {
              debug("reconnect attempt error");
              self.reconnecting = false;
              self.reconnect();
              self.emitAll("reconnect_error", err.data);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
    };
    Manager.prototype.onreconnect = function() {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll("reconnect", attempt);
    };
  }, {
    "./on": 50,
    "./socket": 51,
    backo2: 20,
    "component-bind": 23,
    "component-emitter": 24,
    debug: 53,
    "engine.io-client": 26,
    indexof: 43,
    "socket.io-parser": 56
  } ],
  50: [ function(require, module, exports) {
    module.exports = on;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return {
        destroy: function() {
          obj.removeListener(ev, fn);
        }
      };
    }
  }, {} ],
  51: [ function(require, module, exports) {
    var parser = require("socket.io-parser");
    var Emitter = require("component-emitter");
    var toArray = require("to-array");
    var on = require("./on");
    var bind = require("component-bind");
    var debug = require("debug")("socket.io-client:socket");
    var parseqs = require("parseqs");
    var hasBin = require("has-binary2");
    module.exports = exports = Socket;
    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };
    var emit = Emitter.prototype.emit;
    function Socket(io, nsp, opts) {
      this.io = io;
      this.nsp = nsp;
      this.json = this;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      opts && opts.query && (this.query = opts.query);
      this.io.autoConnect && this.open();
    }
    Emitter(Socket.prototype);
    Socket.prototype.subEvents = function() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [ on(io, "open", bind(this, "onopen")), on(io, "packet", bind(this, "onpacket")), on(io, "close", bind(this, "onclose")) ];
    };
    Socket.prototype.open = Socket.prototype.connect = function() {
      if (this.connected) return this;
      this.subEvents();
      this.io.open();
      "open" === this.io.readyState && this.onopen();
      this.emit("connecting");
      return this;
    };
    Socket.prototype.send = function() {
      var args = toArray(arguments);
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    };
    Socket.prototype.emit = function(ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }
      var args = toArray(arguments);
      var packet = {
        type: (void 0 !== this.flags.binary ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;
      if ("function" === typeof args[args.length - 1]) {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      this.connected ? this.packet(packet) : this.sendBuffer.push(packet);
      this.flags = {};
      return this;
    };
    Socket.prototype.packet = function(packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };
    Socket.prototype.onopen = function() {
      debug("transport is open - connecting");
      if ("/" !== this.nsp) if (this.query) {
        var query = "object" === typeof this.query ? parseqs.encode(this.query) : this.query;
        debug("sending connect packet with query %s", query);
        this.packet({
          type: parser.CONNECT,
          query: query
        });
      } else this.packet({
        type: parser.CONNECT
      });
    };
    Socket.prototype.onclose = function(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit("disconnect", reason);
    };
    Socket.prototype.onpacket = function(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      var rootNamespaceError = packet.type === parser.ERROR && "/" === packet.nsp;
      if (!sameNamespace && !rootNamespaceError) return;
      switch (packet.type) {
       case parser.CONNECT:
        this.onconnect();
        break;

       case parser.EVENT:
       case parser.BINARY_EVENT:
        this.onevent(packet);
        break;

       case parser.ACK:
       case parser.BINARY_ACK:
        this.onack(packet);
        break;

       case parser.DISCONNECT:
        this.ondisconnect();
        break;

       case parser.ERROR:
        this.emit("error", packet.data);
      }
    };
    Socket.prototype.onevent = function(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);
      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      this.connected ? emit.apply(this, args) : this.receiveBuffer.push(args);
    };
    Socket.prototype.ack = function(id) {
      var self = this;
      var sent = false;
      return function() {
        if (sent) return;
        sent = true;
        var args = toArray(arguments);
        debug("sending ack %j", args);
        self.packet({
          type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
          id: id,
          data: args
        });
      };
    };
    Socket.prototype.onack = function(packet) {
      var ack = this.acks[packet.id];
      if ("function" === typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else debug("bad ack %s", packet.id);
    };
    Socket.prototype.onconnect = function() {
      this.connected = true;
      this.disconnected = false;
      this.emit("connect");
      this.emitBuffered();
    };
    Socket.prototype.emitBuffered = function() {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) emit.apply(this, this.receiveBuffer[i]);
      this.receiveBuffer = [];
      for (i = 0; i < this.sendBuffer.length; i++) this.packet(this.sendBuffer[i]);
      this.sendBuffer = [];
    };
    Socket.prototype.ondisconnect = function() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    };
    Socket.prototype.destroy = function() {
      if (this.subs) {
        for (var i = 0; i < this.subs.length; i++) this.subs[i].destroy();
        this.subs = null;
      }
      this.io.destroy(this);
    };
    Socket.prototype.close = Socket.prototype.disconnect = function() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: parser.DISCONNECT
        });
      }
      this.destroy();
      this.connected && this.onclose("io client disconnect");
      return this;
    };
    Socket.prototype.compress = function(compress) {
      this.flags.compress = compress;
      return this;
    };
    Socket.prototype.binary = function(binary) {
      this.flags.binary = binary;
      return this;
    };
  }, {
    "./on": 50,
    "component-bind": 23,
    "component-emitter": 24,
    debug: 53,
    "has-binary2": 41,
    parseqs: 46,
    "socket.io-parser": 56,
    "to-array": 60
  } ],
  52: [ function(require, module, exports) {
    (function(global) {
      var parseuri = require("parseuri");
      var debug = require("debug")("socket.io-client:url");
      module.exports = url;
      function url(uri, loc) {
        var obj = uri;
        loc = loc || global.location;
        null == uri && (uri = loc.protocol + "//" + loc.host);
        if ("string" === typeof uri) {
          "/" === uri.charAt(0) && (uri = "/" === uri.charAt(1) ? loc.protocol + uri : loc.host + uri);
          if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            uri = "undefined" !== typeof loc ? loc.protocol + "//" + uri : "https://" + uri;
          }
          debug("parse %s", uri);
          obj = parseuri(uri);
        }
        obj.port || (/^(http|ws)$/.test(obj.protocol) ? obj.port = "80" : /^(http|ws)s$/.test(obj.protocol) && (obj.port = "443"));
        obj.path = obj.path || "/";
        var ipv6 = -1 !== obj.host.indexOf(":");
        var host = ipv6 ? "[" + obj.host + "]" : obj.host;
        obj.id = obj.protocol + "://" + host + ":" + obj.port;
        obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
        return obj;
      }
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    debug: 53,
    parseuri: 47
  } ],
  53: [ function(require, module, exports) {
    arguments[4][35][0].apply(exports, arguments);
  }, {
    "./debug": 54,
    _process: 6,
    dup: 35
  } ],
  54: [ function(require, module, exports) {
    arguments[4][36][0].apply(exports, arguments);
  }, {
    dup: 36,
    ms: 45
  } ],
  55: [ function(require, module, exports) {
    (function(global) {
      var isArray = require("isarray");
      var isBuf = require("./is-buffer");
      var toString = Object.prototype.toString;
      var withNativeBlob = "function" === typeof global.Blob || "[object BlobConstructor]" === toString.call(global.Blob);
      var withNativeFile = "function" === typeof global.File || "[object FileConstructor]" === toString.call(global.File);
      exports.deconstructPacket = function(packet) {
        var buffers = [];
        var packetData = packet.data;
        var pack = packet;
        pack.data = _deconstructPacket(packetData, buffers);
        pack.attachments = buffers.length;
        return {
          packet: pack,
          buffers: buffers
        };
      };
      function _deconstructPacket(data, buffers) {
        if (!data) return data;
        if (isBuf(data)) {
          var placeholder = {
            _placeholder: true,
            num: buffers.length
          };
          buffers.push(data);
          return placeholder;
        }
        if (isArray(data)) {
          var newData = new Array(data.length);
          for (var i = 0; i < data.length; i++) newData[i] = _deconstructPacket(data[i], buffers);
          return newData;
        }
        if ("object" === typeof data && !(data instanceof Date)) {
          var newData = {};
          for (var key in data) newData[key] = _deconstructPacket(data[key], buffers);
          return newData;
        }
        return data;
      }
      exports.reconstructPacket = function(packet, buffers) {
        packet.data = _reconstructPacket(packet.data, buffers);
        packet.attachments = void 0;
        return packet;
      };
      function _reconstructPacket(data, buffers) {
        if (!data) return data;
        if (data && data._placeholder) return buffers[data.num];
        if (isArray(data)) for (var i = 0; i < data.length; i++) data[i] = _reconstructPacket(data[i], buffers); else if ("object" === typeof data) for (var key in data) data[key] = _reconstructPacket(data[key], buffers);
        return data;
      }
      exports.removeBlobs = function(data, callback) {
        function _removeBlobs(obj, curKey, containingObject) {
          if (!obj) return obj;
          if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
            pendingBlobs++;
            var fileReader = new FileReader();
            fileReader.onload = function() {
              containingObject ? containingObject[curKey] = this.result : bloblessData = this.result;
              --pendingBlobs || callback(bloblessData);
            };
            fileReader.readAsArrayBuffer(obj);
          } else if (isArray(obj)) for (var i = 0; i < obj.length; i++) _removeBlobs(obj[i], i, obj); else if ("object" === typeof obj && !isBuf(obj)) for (var key in obj) _removeBlobs(obj[key], key, obj);
        }
        var pendingBlobs = 0;
        var bloblessData = data;
        _removeBlobs(bloblessData);
        pendingBlobs || callback(bloblessData);
      };
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {
    "./is-buffer": 57,
    isarray: 44
  } ],
  56: [ function(require, module, exports) {
    var debug = require("debug")("socket.io-parser");
    var Emitter = require("component-emitter");
    var binary = require("./binary");
    var isArray = require("isarray");
    var isBuf = require("./is-buffer");
    exports.protocol = 4;
    exports.types = [ "CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK" ];
    exports.CONNECT = 0;
    exports.DISCONNECT = 1;
    exports.EVENT = 2;
    exports.ACK = 3;
    exports.ERROR = 4;
    exports.BINARY_EVENT = 5;
    exports.BINARY_ACK = 6;
    exports.Encoder = Encoder;
    exports.Decoder = Decoder;
    function Encoder() {}
    var ERROR_PACKET = exports.ERROR + '"encode error"';
    Encoder.prototype.encode = function(obj, callback) {
      debug("encoding packet %j", obj);
      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) encodeAsBinary(obj, callback); else {
        var encoding = encodeAsString(obj);
        callback([ encoding ]);
      }
    };
    function encodeAsString(obj) {
      var str = "" + obj.type;
      exports.BINARY_EVENT !== obj.type && exports.BINARY_ACK !== obj.type || (str += obj.attachments + "-");
      obj.nsp && "/" !== obj.nsp && (str += obj.nsp + ",");
      null != obj.id && (str += obj.id);
      if (null != obj.data) {
        var payload = tryStringify(obj.data);
        if (false === payload) return ERROR_PACKET;
        str += payload;
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    function tryStringify(str) {
      try {
        return JSON.stringify(str);
      } catch (e) {
        return false;
      }
    }
    function encodeAsBinary(obj, callback) {
      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
        buffers.unshift(pack);
        callback(buffers);
      }
      binary.removeBlobs(obj, writeEncoding);
    }
    function Decoder() {
      this.reconstructor = null;
    }
    Emitter(Decoder.prototype);
    Decoder.prototype.add = function(obj) {
      var packet;
      if ("string" === typeof obj) {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
          this.reconstructor = new BinaryReconstructor(packet);
          0 === this.reconstructor.reconPack.attachments && this.emit("decoded", packet);
        } else this.emit("decoded", packet);
      } else {
        if (!isBuf(obj) && !obj.base64) throw new Error("Unknown type: " + obj);
        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          this.emit("decoded", packet);
        }
      }
    };
    function decodeString(str) {
      var i = 0;
      var p = {
        type: Number(str.charAt(0))
      };
      if (null == exports.types[p.type]) return error("unknown packet type " + p.type);
      if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
        var buf = "";
        while ("-" !== str.charAt(++i)) {
          buf += str.charAt(i);
          if (i == str.length) break;
        }
        if (buf != Number(buf) || "-" !== str.charAt(i)) throw new Error("Illegal attachments");
        p.attachments = Number(buf);
      }
      if ("/" === str.charAt(i + 1)) {
        p.nsp = "";
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          p.nsp += c;
          if (i === str.length) break;
        }
      } else p.nsp = "/";
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        p.id = "";
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          p.id += str.charAt(i);
          if (i === str.length) break;
        }
        p.id = Number(p.id);
      }
      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));
        var isPayloadValid = false !== payload && (p.type === exports.ERROR || isArray(payload));
        if (!isPayloadValid) return error("invalid payload");
        p.data = payload;
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
    function tryParse(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return false;
      }
    }
    Decoder.prototype.destroy = function() {
      this.reconstructor && this.reconstructor.finishedReconstruction();
    };
    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };
    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };
    function error(msg) {
      return {
        type: exports.ERROR,
        data: "parser error: " + msg
      };
    }
  }, {
    "./binary": 55,
    "./is-buffer": 57,
    "component-emitter": 24,
    debug: 58,
    isarray: 44
  } ],
  57: [ function(require, module, exports) {
    (function(global) {
      module.exports = isBuf;
      var withNativeBuffer = "function" === typeof global.Buffer && "function" === typeof global.Buffer.isBuffer;
      var withNativeArrayBuffer = "function" === typeof global.ArrayBuffer;
      var isView = function() {
        return withNativeArrayBuffer && "function" === typeof global.ArrayBuffer.isView ? global.ArrayBuffer.isView : function(obj) {
          return obj.buffer instanceof global.ArrayBuffer;
        };
      }();
      function isBuf(obj) {
        return withNativeBuffer && global.Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj));
      }
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  58: [ function(require, module, exports) {
    arguments[4][35][0].apply(exports, arguments);
  }, {
    "./debug": 59,
    _process: 6,
    dup: 35
  } ],
  59: [ function(require, module, exports) {
    arguments[4][36][0].apply(exports, arguments);
  }, {
    dup: 36,
    ms: 45
  } ],
  60: [ function(require, module, exports) {
    module.exports = toArray;
    function toArray(list, index) {
      var array = [];
      index = index || 0;
      for (var i = index || 0; i < list.length; i++) array[i - index] = list[i];
      return array;
    }
  }, {} ],
  61: [ function(require, module, exports) {
    (function(global) {
      var __extends;
      var __assign;
      var __rest;
      var __decorate;
      var __param;
      var __metadata;
      var __awaiter;
      var __generator;
      var __exportStar;
      var __values;
      var __read;
      var __spread;
      var __await;
      var __asyncGenerator;
      var __asyncDelegator;
      var __asyncValues;
      var __makeTemplateObject;
      var __importStar;
      var __importDefault;
      (function(factory) {
        var root = "object" === typeof global ? global : "object" === typeof self ? self : "object" === typeof this ? this : {};
        "function" === typeof define && define.amd ? define("tslib", [ "exports" ], function(exports) {
          factory(createExporter(root, createExporter(exports)));
        }) : "object" === typeof module && "object" === typeof module.exports ? factory(createExporter(root, createExporter(module.exports))) : factory(createExporter(root));
        function createExporter(exports, previous) {
          exports !== root && ("function" === typeof Object.create ? Object.defineProperty(exports, "__esModule", {
            value: true
          }) : exports.__esModule = true);
          return function(id, v) {
            return exports[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        };
        __extends = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
          }
          return t;
        };
        __rest = function(s, e) {
          var t = {};
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
          if (null != s && "function" === typeof Object.getOwnPropertySymbols) for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && (t[p[i]] = s[p[i]]);
          return t;
        };
        __decorate = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata = function(metadataKey, metadataValue) {
          if ("object" === typeof Reflect && "function" === typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter = function(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : new P(function(resolve) {
                resolve(result.value);
              }).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator = function(thisArg, body) {
          var _ = {
            label: 0,
            sent: function() {
              if (1 & t[0]) throw t[1];
              return t[1];
            },
            trys: [],
            ops: []
          }, f, y, t, g;
          return g = {
            next: verb(0),
            throw: verb(1),
            return: verb(2)
          }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([ n, v ]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
              if (f = 1, y && (t = y[2 & op[0] ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
              (y = 0, t) && (op = [ 0, t.value ]);
              switch (op[0]) {
               case 0:
               case 1:
                t = op;
                break;

               case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };

               case 5:
                _.label++;
                y = op[1];
                op = [ 0 ];
                continue;

               case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;

               default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                  _ = 0;
                  continue;
                }
                if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (6 === op[0] && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop();
                _.trys.pop();
                continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [ 6, e ];
              y = 0;
            } finally {
              f = t = 0;
            }
            if (5 & op[0]) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true
            };
          }
        };
        __exportStar = function(m, exports) {
          for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);
        };
        __values = function(o) {
          var m = "function" === typeof Symbol && o[Symbol.iterator], i = 0;
          if (m) return m.call(o);
          return {
            next: function() {
              o && i >= o.length && (o = void 0);
              return {
                value: o && o[i++],
                done: !o
              };
            }
          };
        };
        __read = function(o, n) {
          var m = "function" === typeof Symbol && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((void 0 === n || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          } catch (error) {
            e = {
              error: error
            };
          } finally {
            try {
              r && !r.done && (m = i["return"]) && m.call(i);
            } finally {
              if (e) throw e.error;
            }
          }
          return ar;
        };
        __spread = function() {
          for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
          return ar;
        };
        __await = function(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        };
        __asyncGenerator = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            g[n] && (i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([ n, v, a, b ]) > 1 || resume(n, v);
              });
            });
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            (f(v), q.shift(), q.length) && resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            o[n] && (i[n] = function(v) {
              return (p = !p) ? {
                value: __await(o[n](v)),
                done: "return" === n
              } : f ? f(v) : v;
            });
          }
        };
        __asyncValues = function(o) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator];
          return m ? m.call(o) : "function" === typeof __values ? __values(o) : o[Symbol.iterator]();
        };
        __makeTemplateObject = function(cooked, raw) {
          Object.defineProperty ? Object.defineProperty(cooked, "raw", {
            value: raw
          }) : cooked.raw = raw;
          return cooked;
        };
        __importStar = function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (null != mod) for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
          result["default"] = mod;
          return result;
        };
        __importDefault = function(mod) {
          return mod && mod.__esModule ? mod : {
            default: mod
          };
        };
        exporter("__extends", __extends);
        exporter("__assign", __assign);
        exporter("__rest", __rest);
        exporter("__decorate", __decorate);
        exporter("__param", __param);
        exporter("__metadata", __metadata);
        exporter("__awaiter", __awaiter);
        exporter("__generator", __generator);
        exporter("__exportStar", __exportStar);
        exporter("__values", __values);
        exporter("__read", __read);
        exporter("__spread", __spread);
        exporter("__await", __await);
        exporter("__asyncGenerator", __asyncGenerator);
        exporter("__asyncDelegator", __asyncDelegator);
        exporter("__asyncValues", __asyncValues);
        exporter("__makeTemplateObject", __makeTemplateObject);
        exporter("__importStar", __importStar);
        exporter("__importDefault", __importDefault);
      });
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  62: [ function(require, module, exports) {
    (function(self) {
      "use strict";
      if (self.fetch) return;
      var support = {
        searchParams: "URLSearchParams" in self,
        iterable: "Symbol" in self && "iterator" in Symbol,
        blob: "FileReader" in self && "Blob" in self && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self,
        arrayBuffer: "ArrayBuffer" in self
      };
      if (support.arrayBuffer) {
        var viewClasses = [ "[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]" ];
        var isDataView = function(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        };
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        "string" !== typeof name && (name = String(name));
        if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) throw new TypeError("Invalid character in header field name");
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        "string" !== typeof value && (value = String(value));
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return {
              done: void 0 === value,
              value: value
            };
          }
        };
        support.iterable && (iterator[Symbol.iterator] = function() {
          return iterator;
        });
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        headers instanceof Headers ? headers.forEach(function(value, name) {
          this.append(name, value);
        }, this) : Array.isArray(headers) ? headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this) : headers && Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + "," + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) this.map.hasOwnProperty(name) && callback.call(thisArg, this.map[name], name, this);
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([ name, value ]);
        });
        return iteratorFor(items);
      };
      support.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
      function consumed(body) {
        if (body.bodyUsed) return Promise.reject(new TypeError("Already read"));
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) chars[i] = String.fromCharCode(view[i]);
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) return buf.slice(0);
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (body) if ("string" === typeof body) this._bodyText = body; else if (support.blob && Blob.prototype.isPrototypeOf(body)) this._bodyBlob = body; else if (support.formData && FormData.prototype.isPrototypeOf(body)) this._bodyFormData = body; else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) this._bodyText = body.toString(); else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([ this._bodyArrayBuffer ]);
          } else {
            if (!support.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(body) && !isArrayBufferView(body)) throw new Error("unsupported BodyInit type");
            this._bodyArrayBuffer = bufferClone(body);
          } else this._bodyText = "";
          this.headers.get("content-type") || ("string" === typeof body ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) return rejected;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([ this._bodyArrayBuffer ]));
            if (this._bodyFormData) throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([ this._bodyText ]));
          };
          this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? consumed(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(readBlobAsArrayBuffer);
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) return rejected;
          if (this._bodyBlob) return readBlobAsText(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          if (this._bodyFormData) throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        };
        support.formData && (this.formData = function() {
          return this.text().then(decode);
        });
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = [ "DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT" ];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) throw new TypeError("Already read");
          this.url = input.url;
          this.credentials = input.credentials;
          options.headers || (this.headers = new Headers(input.headers));
          this.method = input.method;
          this.mode = input.mode;
          if (!body && null != input._bodyInit) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else this.url = String(input);
        this.credentials = options.credentials || this.credentials || "omit";
        !options.headers && this.headers || (this.headers = new Headers(options.headers));
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.referrer = null;
        if (("GET" === this.method || "HEAD" === this.method) && body) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, {
          body: this._bodyInit
        });
      };
      function decode(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        options || (options = {});
        this.type = "default";
        this.status = void 0 === options.status ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, {
          status: 0,
          statusText: ""
        });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [ 301, 302, 303, 307, 308 ];
      Response.redirect = function(url, status) {
        if (-1 === redirectStatuses.indexOf(status)) throw new RangeError("Invalid status code");
        return new Response(null, {
          status: status,
          headers: {
            location: url
          }
        });
      };
      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;
      self.fetch = function(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          var xhr = new XMLHttpRequest();
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.open(request.method, request.url, true);
          "include" === request.credentials ? xhr.withCredentials = true : "omit" === request.credentials && (xhr.withCredentials = false);
          "responseType" in xhr && support.blob && (xhr.responseType = "blob");
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          xhr.send("undefined" === typeof request._bodyInit ? null : request._bodyInit);
        });
      };
      self.fetch.polyfill = true;
    })("undefined" !== typeof self ? self : this);
  }, {} ],
  63: [ function(require, module, exports) {
    "use strict";
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {}, seed = 0, i = 0, prev;
    function encode(num) {
      var encoded = "";
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    function decode(str) {
      var decoded = 0;
      for (i = 0; i < str.length; i++) decoded = decoded * length + map[str.charAt(i)];
      return decoded;
    }
    function yeast() {
      var now = encode(+new Date());
      if (now !== prev) return seed = 0, prev = now;
      return now + "." + encode(seed++);
    }
    for (;i < length; i++) map[alphabet[i]] = i;
    yeast.encode = encode;
    yeast.decode = decode;
    module.exports = yeast;
  }, {} ],
  EditText: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "de6c8w7vVRAw4DK0kstnxhS", "EditText");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        labelName: {
          default: null,
          type: cc.Node
        },
        startString: "Enter your name...",
        editBox: {
          default: null,
          type: cc.EditBox
        }
      },
      setText: function setText(data) {
        if ("" == data) {
          this.label.string = this.startString;
          this.labelName.color = cc.hexToColor("#7F7F7F");
        } else {
          if (0 == this.editBox.inputFlag) {
            var input = "";
            for (i = 0; i < data.length; i++) input += "*";
            this.label.string = input;
          } else this.label.string = data;
          255 != this.labelName.color.b && (this.labelName.color = cc.hexToColor("#000000"));
        }
      },
      startGetName: function startGetName() {
        this.label.string == this.startString && (this.label.string = "");
      },
      endGetName: function endGetName(data) {
        if ("" == this.label.string) {
          this.label.string = this.startString;
          this.labelName.color = cc.hexToColor("#7F7F7F");
        }
      },
      onLoad: function onLoad() {
        this.label = this.labelName.getComponent(cc.Label);
      },
      start: function start() {}
    });
    cc._RF.pop();
  }, {} ],
  Enemy: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4c743AEbghOGZ3ALTYwONbx", "Enemy");
    "use strict";
    var _cc$Class;
    function _defineProperty(obj, key, value) {
      key in obj ? Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      }) : obj[key] = value;
      return obj;
    }
    cc.Class((_cc$Class = {
      extends: cc.Component,
      properties: {
        runSpeed: 0,
        action: "jump"
      },
      onCollisionEnter: function onCollisionEnter(other, self) {},
      playerAction: function playerAction(playerComp) {
        if ("jump" == this.action) playerComp.accTop = true; else if ("duck" == this.action) {
          if (!playerComp.duckAnimState.isPlaying && null != playerComp.anim._clips) {
            playerComp.anim.play("dino_duck");
            if (!playerComp.duckCollider.enabled) {
              playerComp.duckCollider.enabled = true;
              playerComp.standCollider.enabled = false;
            }
          }
          setTimeout(function() {
            if (!playerComp.runAnimState.isPlaying && null != playerComp.anim._clips) {
              playerComp.anim.play("dino");
              if (!playerComp.standCollider.enabled) {
                playerComp.duckCollider.enabled = false;
                playerComp.standCollider.enabled = true;
              }
            }
          }, 500);
        }
      }
    }, _defineProperty(_cc$Class, "onCollisionEnter", function onCollisionEnter(other, self) {
      if ("Bot" == other.node.group) {
        var comp = other.node.getComponent("Bot");
        this.playerAction(comp);
      }
    }), _defineProperty(_cc$Class, "onLoad", function onLoad() {
      var manager = cc.director.getCollisionManager();
      manager.enabled = true;
      manager.enabledDebugDraw = false;
    }), _defineProperty(_cc$Class, "start", function start() {
      var box = this.node.addComponent(cc.BoxCollider);
      box.offset.x = -75;
      box.offset.y = 0;
      box.size.width = 45;
      box.size.height = 45;
      box.tag = 1;
    }), _defineProperty(_cc$Class, "update", function update(dt) {
      if (!this.game.isGameOver) {
        this.node.x -= this.runSpeed;
        this.node.x <= -1500 && this.node.destroy();
      }
    }), _cc$Class));
    cc._RF.pop();
  }, {} ],
  FullScreen: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d8406mmG0JPaqDDxhkc7+17", "FullScreen");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {},
      start: function start() {
        cc.view.setDesignResolutionSize(1200, 560, cc.ResolutionPolicy.EXACT_FIT);
      }
    });
    cc._RF.pop();
  }, {} ],
  GameController: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "cc280HRfRpLo7Xm7xmhcdLJ", "GameController");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        groundYPos: 0,
        ground: {
          default: null,
          type: cc.Prefab
        },
        grounds: {
          default: null,
          type: cc.Node
        },
        player: {
          default: null,
          type: cc.Node
        },
        gameOverDisplay: {
          default: null,
          type: cc.Label
        },
        playAgain: {
          default: null,
          type: cc.Node
        },
        scoreDisplay: {
          default: null,
          type: cc.Label
        },
        highScoreDisplay: {
          default: null,
          type: cc.Label
        },
        buttonJump: {
          default: null,
          type: cc.Node
        },
        buttonDuck: {
          default: null,
          type: cc.Node
        }
      },
      CreateNewGround: function CreateNewGround() {
        var newGround = cc.instantiate(this.ground);
        this.grounds.addChild(newGround);
        newGround.setPosition(cc.p(900, this.groundYPos));
        newGround.getComponent("Ground").game = this;
        this.lowestGround++;
        this.listGround[0] = this.listGround[1];
        this.listGround[1] = this.listGround[2];
        this.listGround[2] = newGround;
      },
      GameOver: function GameOver() {
        console.log("Game over");
        this.isGameOver = true;
        this.playerScript.accel = 0;
        this.gameOverDisplay.enabled = true;
        this.playAgain.active = true;
        this.socket.isGameOver = true;
        this.socket.socket.disconnect();
        null == this.highScore ? cc.sys.localStorage.setItem("HighScore", this.score) : this.score > this.highScore && cc.sys.localStorage.setItem("HighScore", this.score);
        for (i = 0; i < 5; i++) {
          var scoreComp = this.socket.leaderBoardScore[i].getComponent("Score");
          scoreComp.isStartUpdate = false;
        }
      },
      onLoad: function onLoad() {
        this.isGameStarted = false;
        this.isGameOver = false;
        this.highScore = cc.sys.localStorage.getItem("HighScore");
        this.socket = this.getComponent("Socket");
        this.playerScript = this.player.getComponent("Player");
        this.playerScript.game = this;
        this.gameOverDisplay.enabled = false;
        this.playAgain.active = false;
        this.listGround = [];
        this.lowestGround = 1;
        for (var i = 0; i < 3; i++) {
          var newGround = cc.instantiate(this.ground);
          this.grounds.addChild(newGround);
          newGround.setPosition(cc.p(600 * i - 300 - 5, this.groundYPos));
          newGround.getComponent("Ground").game = this;
          this.listGround.push(newGround);
        }
        this.score = 0;
        this.setInputControl();
        this.setButtonControl();
        if ("Windows" == cc.sys.os) {
          this.buttonDuck.active = false;
          this.buttonJump.active = false;
        }
      },
      setInputControl: function setInputControl() {
        var self = this;
        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, function(event) {
          switch (event.keyCode) {
           case cc.KEY.up:
            if (!self.isGameStarted && "" != self.socket.enemyData) {
              console.log("Create interval");
              var scoreInterval = setInterval(function() {
                if (self.isGameOver) clearInterval(scoreInterval); else {
                  self.score += 1;
                  self.scoreDisplay.string = self.score;
                }
              }, 100);
              self.socket.sendDataStartMove();
              self.socket.sendDataGetLeaderBoard();
              self.isGameStarted = true;
            }
          }
        });
      },
      setButtonControl: function setButtonControl() {
        var self = this;
        this.buttonJump.on(cc.Node.EventType.TOUCH_START, function(event) {
          if (!self.isGameStarted && "" != self.socket.enemyData) {
            console.log("Create interval");
            var scoreInterval = setInterval(function() {
              if (self.isGameOver) clearInterval(scoreInterval); else {
                self.score += 1;
                self.scoreDisplay.string = self.score;
              }
            }, 100);
            self.socket.sendDataStartMove();
            self.socket.sendDataGetLeaderBoard();
            self.isGameStarted = true;
          }
        });
      },
      start: function start() {
        null == this.highScore ? this.highScoreDisplay.string = "HI  0" : this.highScoreDisplay.string = "HI  " + this.highScore;
        cc.view.setDesignResolutionSize(1200, 560, cc.ResolutionPolicy.EXACT_FIT);
      },
      update: function update(dt) {}
    });
    cc._RF.pop();
  }, {} ],
  Ground: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8a0000Ob6dBEqbl3vFvHh3p", "Ground");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        runSpeed: 0
      },
      onLoad: function onLoad() {
        this.isCreateSelf = false;
      },
      start: function start() {},
      update: function update(dt) {
        if (this.game.isGameOver || !this.game.isGameStarted) {
          this.runSpeed = 0;
          return;
        }
        this.runSpeed = 5;
        this.node.x -= this.runSpeed;
        this.node.x <= -900 && this.node.destroy();
        if (this.node.x <= -900 && !this.isCreateSelf) {
          this.game.CreateNewGround();
          this.isCreateSelf = true;
        }
      }
    });
    cc._RF.pop();
  }, {} ],
  Logged: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "030302/R+VKnZr+YIW/yyYq", "Logged");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        playerName: {
          default: null,
          type: cc.Label
        },
        highScore: {
          default: null,
          type: cc.Label
        },
        avatar: {
          default: null,
          type: cc.Sprite
        }
      }
    });
    cc._RF.pop();
  }, {} ],
  MenuHandle: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1bc5a37CDpEtZ2XKSAmDRgc", "MenuHandle");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        logged: {
          default: null,
          type: cc.Node
        },
        notLogged: {
          default: null,
          type: cc.Node
        },
        email: {
          default: null,
          type: cc.EditBox
        },
        password: {
          default: null,
          type: cc.EditBox
        },
        loginForm: {
          default: null,
          type: cc.Node
        },
        registerForm: {
          default: null,
          type: cc.Node
        },
        error: {
          default: null,
          type: cc.Label
        },
        gameMenu: {
          default: null,
          type: cc.Node
        },
        loginPage: {
          default: null,
          type: cc.Node
        }
      },
      onLoad: function onLoad() {
        this.fbInit = "";
        this.firebase = "";
        this.isLogin = cc.sys.localStorage.getItem("isLogin");
        this.loginMethod = cc.sys.localStorage.getItem("loginMethod");
        if (!cc.sys.isNative) {
          this.facebook();
          this.twitter();
        }
      },
      twitter: function twitter() {
        this.firebase = require("firebase");
        var config = {
          apiKey: "AIzaSyARrKc0Y-una2Ui82l8H07ZJBCSNuQGzTQ",
          authDomain: "dino-5e78a.firebaseapp.com",
          databaseURL: "https://dino-5e78a.firebaseio.com",
          projectId: "dino-5e78a",
          storageBucket: "",
          messagingSenderId: "1072649185974"
        };
        this.firebase.initializeApp(config);
        this.firebase.auth().useDeviceLanguage();
      },
      facebook: function facebook() {
        var self = this;
        window.fbAsyncInit = function() {
          FB.init({
            appId: "662647887110255",
            xfbml: true,
            version: "v2.8"
          });
          self.fbInit = FB;
        };
        (function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s);
          js.id = id;
          js.src = "https://connect.facebook.net/vi_VN/sdk.js#xfbml=1&version=v3.1&appId=662647887110255&autoLogAppEvents=1";
          fjs.parentNode.insertBefore(js, fjs);
        })(document, "script", "facebook-jssdk");
      },
      loginFacebook: function loginFacebook() {
        var self = this;
        this.fbInit.login(function(response) {
          response.authResponse ? self.fbInit.api("/me", {
            fields: "id,name,email,picture.type(large)"
          }, function(response) {
            var avatarUrl = response.picture.data.url;
            response.url = avatarUrl;
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
              if (4 == xhr.readyState && xhr.status >= 200 && xhr.status < 400) {
                var result = JSON.parse(xhr.responseText);
                cc.textureCache.addImageAsync(result.url, function(data) {
                  loggedComp.avatar.spriteFrame.setTexture(data);
                }, this);
                loggedComp.playerName.string = response.name;
                loggedComp.highScore.string = "Highest score: " + result.highScore;
                cc.sys.localStorage.setItem("isLogin", true);
                cc.sys.localStorage.setItem("loginMethod", "facebook");
                cc.sys.localStorage.setItem("name", response.name);
                cc.sys.localStorage.setItem("HighScore", result.highScore);
                cc.sys.localStorage.setItem("avatar", result.url);
                self.showGameMenu();
              }
            };
            xhr.open("POST", "http://45.33.124.160/Dino/saveUserFb.php");
            xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
            xhr.send(JSON.stringify(response));
            self.logged.active = true;
            self.notLogged.active = false;
            var loggedComp = self.logged.getComponent("Logged");
          }) : console.log("User cancelled login or did not fully authorize.");
        });
      },
      loginTwitter: function loginTwitter() {
        var self = this;
        var provider = new this.firebase.auth.TwitterAuthProvider();
        provider.setCustomParameters({
          lang: "en"
        });
        this.firebase.auth().signInWithPopup(provider).then(function(result) {
          var user = new Object();
          user.email = result.additionalUserInfo.profile.email;
          user.id = result.additionalUserInfo.profile.id_str;
          user.name = result.additionalUserInfo.profile.name;
          user.url = result.additionalUserInfo.profile.profile_image_url;
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (4 == xhr.readyState && xhr.status >= 200 && xhr.status < 400) {
              var result1 = JSON.parse(xhr.responseText);
              cc.textureCache.addImageAsync(result1.url, function(data) {
                loggedComp.avatar.spriteFrame.setTexture(data);
              }, this);
              loggedComp.playerName.string = result.additionalUserInfo.profile.name;
              loggedComp.highScore.string = "Highest score: " + result1.highScore;
              cc.sys.localStorage.setItem("isLogin", true);
              cc.sys.localStorage.setItem("loginMethod", "twitter");
              cc.sys.localStorage.setItem("name", result.additionalUserInfo.profile.name);
              cc.sys.localStorage.setItem("HighScore", result1.highScore);
              cc.sys.localStorage.setItem("avatar", result1.url);
              self.showGameMenu();
            }
          };
          xhr.open("POST", "http://45.33.124.160/Dino/saveUserTw.php");
          xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
          var loggedComp = self.logged.getComponent("Logged");
          xhr.send(JSON.stringify(user));
          self.logged.active = true;
          self.notLogged.active = false;
        }).catch(function(error) {
          console.log(error);
        });
      },
      loginGoogle: function loginGoogle() {
        var self = this;
        var provider = new this.firebase.auth.GoogleAuthProvider();
        provider.addScope("https://www.googleapis.com/auth/userinfo.email");
        provider.setCustomParameters({
          lang: "en"
        });
        this.firebase.auth().signInWithPopup(provider).then(function(result) {
          var user = new Object();
          user.email = result.additionalUserInfo.profile.email;
          user.id = result.additionalUserInfo.profile.id;
          user.name = result.additionalUserInfo.profile.name;
          user.url = result.additionalUserInfo.profile.picture;
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (4 == xhr.readyState && xhr.status >= 200 && xhr.status < 400) {
              var result1 = JSON.parse(xhr.responseText);
              cc.textureCache.addImageAsync(result1.url, function(data) {
                loggedComp.avatar.spriteFrame.setTexture(data);
              }, this);
              loggedComp.playerName.string = result.additionalUserInfo.profile.name;
              loggedComp.highScore.string = "Highest score: " + result1.highScore;
              cc.sys.localStorage.setItem("isLogin", true);
              cc.sys.localStorage.setItem("loginMethod", "google");
              cc.sys.localStorage.setItem("name", result.additionalUserInfo.profile.name);
              cc.sys.localStorage.setItem("HighScore", result1.highScore);
              cc.sys.localStorage.setItem("avatar", result1.url);
              self.showGameMenu();
            }
          };
          xhr.open("POST", "http://45.33.124.160/Dino/saveUserGg.php");
          xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
          var loggedComp = self.logged.getComponent("Logged");
          xhr.send(JSON.stringify(user));
          self.logged.active = true;
          self.notLogged.active = false;
        }).catch(function(error) {
          console.log(error);
        });
      },
      logout: function logout() {
        var self = this;
        cc.sys.localStorage.setItem("isLogin", false);
        self.logged.active = false;
        self.notLogged.active = true;
      },
      login: function login() {
        if ("" == this.email.string) {
          this.error.node.active = true;
          this.error.string = "Please enter user name!";
        } else if ("" == this.password.string) {
          this.error.node.active = true;
          this.error.string = "Please enter password!";
        } else {
          var self = this;
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (4 == xhr.readyState && xhr.status >= 200 && xhr.status < 400) {
              var result1 = JSON.parse(xhr.responseText);
              if (result1.success) {
                cc.sys.localStorage.setItem("isLogin", true);
                cc.sys.localStorage.setItem("loginMethod", "name");
                cc.sys.localStorage.setItem("name", result1.user_name);
                cc.sys.localStorage.setItem("HighScore", result1.highScore);
                cc.sys.localStorage.setItem("avatar", result1.url);
                loggedComp.playerName.string = result1.user_name;
                loggedComp.highScore.string = "Highest score: " + result1.highScore;
                self.showGameMenu();
              } else {
                self.error.node.active = true;
                self.error.string = result1.msg;
              }
            }
          };
          xhr.open("POST", "http://45.33.124.160/Dino/login.php");
          var loggedComp = self.logged.getComponent("Logged");
          var user = new Object();
          user.user_name = this.email.string;
          user.pw = this.password.string;
          xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
          xhr.send(JSON.stringify(user));
        }
      },
      register: function register() {
        if ("" == this.email.string) {
          this.error.node.active = true;
          this.error.string = "Please enter user name!";
        } else if ("" == this.password.string) {
          this.error.node.active = true;
          this.error.string = "Please enter password!";
        } else {
          var self = this;
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (4 == xhr.readyState && xhr.status >= 200 && xhr.status < 400) {
              var result1 = JSON.parse(xhr.responseText);
              if (result1.success) {
                cc.sys.localStorage.setItem("isLogin", true);
                cc.sys.localStorage.setItem("loginMethod", "name");
                cc.sys.localStorage.setItem("name", result1.name);
                cc.sys.localStorage.setItem("HighScore", result1.highScore);
                cc.sys.localStorage.setItem("avatar", result1.url);
                loggedComp.playerName.string = result1.user_name;
                loggedComp.highScore.string = "Highest score: " + result1.highScore;
                self.showGameMenu();
              } else {
                self.error.node.active = true;
                self.error.string = result1.msg;
              }
            }
          };
          xhr.open("POST", "http://45.33.124.160/Dino/saveUserName.php");
          var loggedComp = self.logged.getComponent("Logged");
          var user = new Object();
          user.user_name = this.email.string;
          user.pw = this.password.string;
          xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
          xhr.send(JSON.stringify(user));
        }
      },
      showRegForm: function showRegForm() {
        this.registerForm.active = true;
        this.loginForm.active = false;
      },
      showLoginForm: function showLoginForm() {
        this.registerForm.active = false;
        this.loginForm.active = true;
      },
      showLoginPage: function showLoginPage() {
        this.loginPage.active = true;
        this.gameMenu.active = false;
      },
      showGameMenu: function showGameMenu() {
        this.loginPage.active = false;
        this.gameMenu.active = true;
      }
    });
    cc._RF.pop();
  }, {
    firebase: 40
  } ],
  NetworkPlayer: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4fa6fFE+FVJlqBvsaTf7Sb7", "NetworkPlayer");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        accel: 0,
        fallingPoint: 0,
        max: 0,
        groundPoint: 0,
        moveSpeed: 7,
        netWorkPlayerName: {
          default: null,
          type: cc.Node
        }
      },
      jump: function jump() {
        this.accTop = true;
      },
      cancleJump: function cancleJump() {
        this.accTop = false;
      },
      duck: function duck() {
        if (!this.duckAnimState.isPlaying && null != this.anim._clips) {
          this.anim.play("dino_duck");
          if (!this.duckCollider.enabled) {
            this.duckCollider.enabled = true;
            this.standCollider.enabled = false;
          }
        }
      },
      stand: function stand() {
        if (!this.runAnimState.isPlaying && null != this.anim._clips) {
          this.anim.play("dino");
          if (!this.standCollider.enabled) {
            this.duckCollider.enabled = false;
            this.standCollider.enabled = true;
          }
        }
      },
      onLoad: function onLoad() {
        this.isDead = false;
        this.isFalling = false;
        this.isGrowing = false;
        this.accTop = true;
        this.isBotDead = false;
        this.xSpeed = 0;
        this.ySpeed = 0;
        this.netWorkPlayerNameComp = this.netWorkPlayerName.getComponent(cc.Label);
        this.anim = this.getComponent(cc.Animation);
        this.runAnimState = this.anim.getAnimationState("dino");
        this.jumpAnimState = this.anim.getAnimationState("dino_jump");
        this.deadAnimState = this.anim.getAnimationState("dino_dead");
        this.duckAnimState = this.anim.getAnimationState("dino_duck");
        this.colliders = this.node.getComponents(cc.PolygonCollider);
        this.standCollider = this.colliders[0];
        this.duckCollider = this.colliders[1];
        var manager = cc.director.getCollisionManager();
        manager.enabled = true;
        manager.enabledDebugDraw = false;
      },
      update: function update(dt) {
        if (this.game.isGameOver && this.isDead) return;
        if (this.isDead) {
          this.node.x -= this.moveSpeed;
          this.node.x <= -1500 && this.node.destroy();
          return;
        }
        this.accTop && !this.isFalling && this.isGrowing ? this.ySpeed += this.accel * dt : this.ySpeed -= 50 * this.accel / 100 * dt;
        this.ySpeed >= this.max && (this.ySpeed = this.max);
        this.node.y += this.ySpeed * dt;
        if (this.node.y <= this.groundPoint) {
          this.ySpeed = 0;
          this.node.y = this.groundPoint;
          this.isFalling = false;
          this.isGrowing = true;
          this.runAnimState.isPlaying || this.isDead || this.duckAnimState.isPlaying || this.anim.play("dino");
        }
        this.node.y >= this.fallingPoint && (this.isFalling = true);
        if (this.game.isGameOver || !this.game.isGameStarted) {
          this.node.x += this.moveSpeed;
          this.node.x >= 900 && this.node.destroy();
        }
      }
    });
    cc._RF.pop();
  }, {} ],
  PlayAgain: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "832ddKYiJ5EPptSDrK+qtP+", "PlayAgain");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {},
      callback: function callback() {
        cc.director.loadScene("game", function() {
          console.log("Loaded");
        });
      }
    });
    cc._RF.pop();
  }, {} ],
  Player: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bf7dfKcPAdAnpJu7zqMNFsd", "Player");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        accel: 0,
        fallingPoint: 0,
        max: 0,
        groundPoint: 0,
        playerName: {
          default: null,
          type: cc.Node
        },
        buttonJump: {
          default: null,
          type: cc.Node
        },
        buttonDuck: {
          default: null,
          type: cc.Node
        }
      },
      jump: function jump() {
        console.log("Jump");
      },
      duck: function duck() {
        console.log("duck");
      },
      setButtonControl: function setButtonControl() {
        var self = this;
        var anim1 = self.anim;
        var runAnimState1 = self.anim.getAnimationState("dino");
        var jumpAnimState1 = self.anim.getAnimationState("dino_jump");
        var duckAnimState1 = self.anim.getAnimationState("dino_duck");
        this.buttonJump.on(cc.Node.EventType.TOUCH_START, function(event) {
          self.accTop = true;
          jumpAnimState1.isPlaying || null != anim1._clips && anim1.play("dino_jump");
        });
        this.buttonJump.on(cc.Node.EventType.TOUCH_END, function(event) {
          self.accTop = false;
          self.isGrowing = false;
        });
        this.buttonDuck.on(cc.Node.EventType.TOUCH_START, function(event) {
          if (!duckAnimState1.isPlaying && null != anim1._clips) {
            anim1.play("dino_duck");
            if (!self.duckCollider.enabled) {
              self.duckCollider.enabled = true;
              self.standCollider.enabled = false;
            }
          }
        });
        this.buttonDuck.on(cc.Node.EventType.TOUCH_END, function(event) {
          if (!runAnimState1.isPlaying && null != anim1._clips) {
            anim1.play("dino");
            if (!self.standCollider.enabled) {
              self.duckCollider.enabled = false;
              self.standCollider.enabled = true;
            }
          }
        });
      },
      setInputControl: function setInputControl() {
        if (!this.game.isGameOver) {
          var self = this;
          var anim1 = self.anim;
          var runAnimState1 = self.anim.getAnimationState("dino");
          var jumpAnimState1 = self.anim.getAnimationState("dino_jump");
          var duckAnimState1 = self.anim.getAnimationState("dino_duck");
          var node1 = self.node;
          cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, function(event) {
            switch (event.keyCode) {
             case cc.KEY.w:
             case cc.KEY.up:
              self.accTop = true;
              jumpAnimState1.isPlaying || null != anim1._clips && anim1.play("dino_jump");
              break;

             case cc.KEY.down:
              if (!duckAnimState1.isPlaying && null != anim1._clips) {
                anim1.play("dino_duck");
                if (!self.duckCollider.enabled) {
                  self.duckCollider.enabled = true;
                  self.standCollider.enabled = false;
                }
              }
            }
          });
          cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, function(event) {
            switch (event.keyCode) {
             case cc.KEY.w:
              console.log("Key Up");
              self.accTop = false;
              self.isGrowing = false;
              break;

             case cc.KEY.up:
              self.accTop = false;
              self.isGrowing = false;
              break;

             case cc.KEY.down:
              if (!runAnimState1.isPlaying && null != anim1._clips) {
                anim1.play("dino");
                if (!self.standCollider.enabled) {
                  self.duckCollider.enabled = false;
                  self.standCollider.enabled = true;
                }
              }
            }
          });
        }
      },
      onLoad: function onLoad() {
        this.isDead = false;
        this.isFalling = false;
        this.isGrowing = false;
        this.accTop = false;
        this.xSpeed = 0;
        this.ySpeed = 0;
        this.playerName.getComponent(cc.Label).string = cc.sys.localStorage.getItem("guest_name");
        this.anim = this.getComponent(cc.Animation);
        this.runAnimState = this.anim.getAnimationState("dino");
        this.jumpAnimState = this.anim.getAnimationState("dino_jump");
        this.deadAnimState = this.anim.getAnimationState("dino_dead");
        this.duckAnimState = this.anim.getAnimationState("dino_duck");
        this.colliders = this.node.getComponents(cc.PolygonCollider);
        this.standCollider = this.colliders[0];
        this.duckCollider = this.colliders[1];
        var manager = cc.director.getCollisionManager();
        manager.enabled = true;
        manager.enabledDebugDraw = false;
        this.setInputControl();
        this.setButtonControl();
      },
      onCollisionEnter: function onCollisionEnter(other, self) {
        if (0 == other.tag) {
          this.game.GameOver();
          if (!this.deadAnimState.isPlaying) {
            this.isDead = true;
            this.anim.play("dino_dead");
          }
        }
      },
      start: function start() {},
      update: function update(dt) {
        if (!this.game.isGameOver && this.game.isGameStarted) {
          this.accTop && !this.isFalling && this.isGrowing ? this.ySpeed += this.accel * dt : this.ySpeed -= 50 * this.accel / 100 * dt;
          this.ySpeed >= this.max && (this.ySpeed = this.max);
          this.node.y += this.ySpeed * dt;
          if (this.node.y <= this.groundPoint) {
            this.ySpeed = 0;
            this.node.y = this.groundPoint;
            this.isFalling = false;
            this.isGrowing = true;
            this.runAnimState.isPlaying || this.isDead || this.duckAnimState.isPlaying || this.anim.play("dino");
          }
          if (this.node.y >= this.fallingPoint) {
            this.accTop = false;
            this.isFalling = true;
          }
        }
      }
    });
    cc._RF.pop();
  }, {} ],
  Score: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f58e1UegxJIyIWCbqyJQaQN", "Score");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        score: 0
      },
      updateScore: function updateScore() {
        var self = this;
        setTimeout(function() {
          self.label.string = self.score;
          self.score += 1;
          self.isStartUpdate && self.updateScore();
        }, 100);
      },
      onLoad: function onLoad() {
        this.label = this.node.getComponent(cc.Label);
        this.isStartUpdate = false;
      }
    });
    cc._RF.pop();
  }, {} ],
  Socket: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "20c76JTYuRJ+IOtZHW+Mupy", "Socket");
    "use strict";
    cc.Class({
      extends: cc.Component,
      properties: {
        enemies: {
          default: [],
          type: cc.Prefab,
          tooltip: "List enemy"
        },
        parentEnemy: {
          default: null,
          type: cc.Node
        },
        player: {
          default: null,
          type: cc.Node
        },
        bot: {
          default: null,
          type: cc.Prefab,
          tooltip: "Bot"
        },
        networkPlayer: {
          default: null,
          type: cc.Prefab,
          tooltip: "Network Player"
        },
        serverSocket: "http://45.33.124.160:1339",
        gameSpeed: 7,
        maxGameSpeed: 12,
        leaderBoardName: {
          default: [],
          type: cc.Node
        },
        leaderBoardScore: {
          default: [],
          type: cc.Node
        },
        buttonJump: {
          default: null,
          type: cc.Node
        },
        buttonDuck: {
          default: null,
          type: cc.Node
        }
      },
      createEnemy: function createEnemy(data, index, duration) {
        if (!this.isGameOver) {
          var self = this;
          setTimeout(function() {
            var enemy = data[index].split(",");
            var enemyIndex = enemy[0];
            var enemyDuration = parseInt(enemy[1]);
            enemyDuration -= 30 * (self.gameSpeed - 7);
            var newEnemy = cc.instantiate(self.enemies[enemyIndex]);
            self.parentEnemy.addChild(newEnemy);
            newEnemy.setPosition(cc.p(700, -33.5));
            newEnemy.getComponent("Enemy").game = self;
            newEnemy.getComponent("Enemy").runSpeed = self.gameSpeed;
            index++;
            index == data.length && (index = 0);
            self.createEnemy(data, index, enemyDuration);
          }, duration);
        }
      },
      sendDataJump: function sendDataJump() {
        this.socket.emit("jump", "");
      },
      sendDataDuck: function sendDataDuck() {
        this.socket.emit("duck", "");
      },
      sendDataCancleJump: function sendDataCancleJump() {
        this.socket.emit("cancleJump", "");
      },
      sendDataCancleDuck: function sendDataCancleDuck() {
        this.socket.emit("cancleDuck", "");
      },
      sendDataStartMove: function sendDataStartMove() {
        this.socket.emit("startMove", "");
      },
      sendDataGetLeaderBoard: function sendDataGetLeaderBoard() {
        console.log("Get leaderBoard");
        this.socket.emit("getLeaderBoard", "");
      },
      setInputControl: function setInputControl() {
        var self = this;
        if (!self.gameController.isGameOver) {
          cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, function(event) {
            switch (event.keyCode) {
             case cc.KEY.up:
              if (!self.isHoldingButton && null != self.socket) {
                self.sendDataJump();
                self.isHoldingButton = true;
              }
              break;

             case cc.KEY.down:
              if (!self.isHoldingButton && null != self.socket) {
                self.sendDataDuck();
                self.isHoldingButton = true;
              }
            }
          });
          cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, function(event) {
            switch (event.keyCode) {
             case cc.KEY.up:
              if (null != self.socket) {
                self.isHoldingButton = false;
                self.sendDataCancleJump();
              }
              break;

             case cc.KEY.down:
              if (null != self.socket) {
                self.isHoldingButton = false;
                self.sendDataCancleDuck();
              }
            }
          });
        }
      },
      setButtonControl: function setButtonControl() {
        var self = this;
        this.buttonJump.on(cc.Node.EventType.TOUCH_START, function(event) {
          self.sendDataJump();
          self.isHoldingButton = true;
        });
        this.buttonJump.on(cc.Node.EventType.TOUCH_END, function(event) {
          if (null != self.socket) {
            self.isHoldingButton = false;
            self.sendDataCancleJump();
          }
        });
        this.buttonDuck.on(cc.Node.EventType.TOUCH_START, function(event) {
          if (!self.isHoldingButton && null != self.socket) {
            self.sendDataDuck();
            self.isHoldingButton = true;
          }
        });
        this.buttonDuck.on(cc.Node.EventType.TOUCH_END, function(event) {
          if (null != self.socket) {
            self.isHoldingButton = false;
            self.sendDataCancleDuck();
          }
        });
      },
      onLoad: function onLoad() {
        this.increateSpeed = 300;
        this.isHoldingButton = false;
        this.gameController = this.getComponent("GameController");
        this.name = cc.sys.localStorage.getItem("guest_name");
        this.isGameOver = this.gameController.isGameOver;
        var newSocket = require("socket.io-client")(this.serverSocket);
        var self = this;
        this.isCreatedEnemy = false;
        this.enemyData = "";
        var pro5 = new Object();
        pro5.name = this.name;
        pro5.room = "global";
        pro5.type = "player";
        var result = JSON.stringify(pro5);
        newSocket.emit("register", result);
        newSocket.on("registerComplete", function(data) {
          self.enemyData = data.split(";");
          console.log(newSocket.id);
        });
        newSocket.on("startMove", function(data) {
          var newPlayer = JSON.parse(data);
          if ("bot" == newPlayer.type) {
            if (!self.gameController.isGameStarted) {
              var newBot = cc.instantiate(self.bot);
              self.node.addChild(newBot);
              newBot.setPosition(cc.p(-237, -56));
              newBot.getComponent("Bot").game = self.gameController;
              newBot.getComponent("Bot").botNameComp.string = newPlayer.name;
            }
          } else if (!self.gameController.isGameStarted) {
            var newNetworkPlayer = cc.instantiate(self.networkPlayer);
            self.node.addChild(newNetworkPlayer);
            newNetworkPlayer.setPosition(cc.p(-237, -56));
            newNetworkPlayer.getComponent("NetworkPlayer").game = self.gameController;
            newNetworkPlayer.getComponent("NetworkPlayer").netWorkPlayerNameComp.string = newPlayer.name;
            newNetworkPlayer.name = newPlayer.id;
          }
        });
        newSocket.on("jump", function(data) {
          var child = self.node.getChildByName(data);
          null != child && child.getComponent("NetworkPlayer").jump();
        });
        newSocket.on("cancleJump", function(data) {
          var child = self.node.getChildByName(data);
          null != child && child.getComponent("NetworkPlayer").cancleJump();
        });
        newSocket.on("duck", function(data) {
          var child = self.node.getChildByName(data);
          null != child && child.getComponent("NetworkPlayer").duck();
        });
        newSocket.on("cancleDuck", function(data) {
          var child = self.node.getChildByName(data);
          null != child && child.getComponent("NetworkPlayer").stand();
        });
        newSocket.on("getLeaderBoard", function(data) {
          var leaderBoard = JSON.parse(data);
          for (i = 0; i < 5; i++) if (i < leaderBoard.length) {
            var obj = leaderBoard[i];
            if (obj.id == newSocket.id) {
              self.leaderBoardName[i].color = cc.hexToColor("#E43131");
              self.leaderBoardScore[i].color = cc.hexToColor("#E43131");
            } else {
              self.leaderBoardName[i].color = cc.hexToColor("#000000");
              self.leaderBoardScore[i].color = cc.hexToColor("#000000");
            }
            self.leaderBoardName[i].getComponent(cc.Label).string = i + 1 + ". " + obj.name;
            var scoreComp = self.leaderBoardScore[i].getComponent("Score");
            if (scoreComp.isStartUpdate) scoreComp.score = obj.score + 1; else {
              scoreComp.score = obj.score;
              scoreComp.updateScore();
              scoreComp.isStartUpdate = true;
            }
          } else {
            self.leaderBoardName[i].getComponent(cc.Label).string = i + 1;
            self.leaderBoardScore[i].getComponent(cc.Label).string = 0;
            self.leaderBoardName[i].color = cc.hexToColor("#000000");
            self.leaderBoardScore[i].color = cc.hexToColor("#000000");
          }
        });
        this.socket = newSocket;
      },
      start: function start() {
        this.setInputControl();
        this.setButtonControl();
      },
      update: function update(dt) {
        if (this.gameController.score >= this.increateSpeed && this.gameSpeed <= this.maxGameSpeed) {
          console.log("Increate Speed");
          this.gameSpeed++;
          this.increateSpeed += 300;
        }
        if (!this.gameController.isGameStarted) return;
        if (this.isCreatedEnemy) return;
        this.createEnemy(this.enemyData, 0, 1500);
        this.isCreatedEnemy = true;
      }
    });
    cc._RF.pop();
  }, {
    "socket.io-client": 48
  } ]
}, {}, [ "Bot", "ButtonHold", "ButtonPlayGame", "CollusionManager", "EditText", "Enemy", "FullScreen", "GameController", "Ground", "MenuHandle", "Logged", "NetworkPlayer", "PlayAgain", "Player", "Score", "Socket" ]);